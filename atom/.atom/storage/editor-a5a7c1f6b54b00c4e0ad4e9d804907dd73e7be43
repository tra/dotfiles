{"mode":"editor","version":1,"windowDimensions":{"x":345,"y":23,"width":1856,"height":1359,"maximized":false},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{"/Users/tra/src/intellisource/apollo/features/control_rules/cancel_control_events.feature":"source.ruby"}},"project":{"path":"/Users/tra/src/intellisource","buffers":[{"text":"require \"spec_helper\"\n\ndescribe BasicStatusPayloadParser do\n  before do\n    @valid_cool_payload = \"9C 0B 02 1B 05 00 00 03 49 04 8E 04 8E 46 46 01 09 34 26 00 00 00 00 00 04 03 00 00 08 05 00 7E DD\"\n    @cool_parser = BasicStatusPayloadParser.new( @valid_cool_payload )\n\n    @valid_heat_payload = \"9C 0B 02 1B 01 00 00 00 41 04 4A 04 2A 41 4C 04 10 24 3B 00 00 00 00 01 21 00 00 00 04 05 05 03 83\"\n    @heat_parser = BasicStatusPayloadParser.new( @valid_heat_payload )\n\n    @valid_auto_payload = \"9C 0B 02 1B 05 00 00 04 4E 04 AF 04 AF 46 46 01 0D 0A 15 00 00 00 00 00 00 01 00 00 08 05 02 08 17\"\n    @auto_parser = BasicStatusPayloadParser.new( @valid_auto_payload )\n  end\n\n  it \"should return the real control status\" do\n    # cool\n    @cool_parser.active_control_status.should == \"cool\"\n    @cool_parser.real_control_status.should == \"cool\"\n\n    # heat\n    @heat_parser.active_control_status.should == \"heat\"\n    @heat_parser.real_control_status.should == \"heat\"\n\n    # auto / heat\n    @auto_parser.active_control_status.should == \"auto\"\n    @auto_parser.real_control_status.should == \"heat\"\n  end\n\n  it \"should return the correct active control status code\" do\n    # cool\n    @cool_parser.active_control_status_code.should == 3\n\n    # heat\n    @heat_parser.active_control_status_code.should == 0\n\n    # auto\n    @auto_parser.active_control_status_code.should == 4\n  end\n\n  it \"should return the correct active control status\" do\n    @cool_parser.active_control_status.should == \"cool\"\n    @heat_parser.active_control_status.should == \"heat\"\n    @auto_parser.active_control_status.should == \"auto\"\n  end\n\n  it \"should return the correct working set point temperature\" do\n    @cool_parser.working_set_point_temperature.should == 73\n    @heat_parser.working_set_point_temperature.should == 65\n    @auto_parser.working_set_point_temperature.should == 78\n  end\n\n  it \"should return the correct buffered display temperature\" do\n    @cool_parser.display_temperature.should == 72.88\n    @heat_parser.display_temperature.should == 68.62\n    @auto_parser.display_temperature.should == 74.94\n  end\n\n  it \"should return the correct instantatious indoor temperature\" do\n    @cool_parser.indoor_temperature.should == 72.88\n    @heat_parser.indoor_temperature.should == 66.62\n    @auto_parser.indoor_temperature.should == 74.94\n  end\n\n  it \"should return the correct heat set point temperature\" do\n    @cool_parser.heat_set_point_temperature.should == 70\n    @heat_parser.heat_set_point_temperature.should == 65\n    @auto_parser.heat_set_point_temperature.should == 70\n  end\n\n  it \"should return the correct cool set point temperature\" do\n    @cool_parser.cool_set_point_temperature.should == 70\n    @heat_parser.cool_set_point_temperature.should == 76\n    @auto_parser.cool_set_point_temperature.should == 70\n  end\n\n  it \"should return the correct hold status\" do\n    @cool_parser.permanent_hold.should == true\n    @cool_parser.temporary_hold.should == true\n\n    @heat_parser.permanent_hold.should == false\n    @heat_parser.temporary_hold.should == false\n\n    @auto_parser.permanent_hold.should == true\n    @auto_parser.temporary_hold.should == false\n  end\n\n  it \"should return the correct current day of the week\" do\n    # tuesday\n    @cool_parser.current_day_of_week.should == 2\n\n    # friday\n    @heat_parser.current_day_of_week.should == 5\n\n    # tuesday\n    @auto_parser.current_day_of_week.should == 2\n  end\n\n  it \"should return the correct current hour\" do\n    @cool_parser.current_hour.should == 9\n    @heat_parser.current_hour.should == 16\n    @auto_parser.current_hour.should == 13\n  end\n\n  it \"should return the correct current minute\" do\n    @cool_parser.current_minute.should == 52\n    @heat_parser.current_minute.should == 36\n    @auto_parser.current_minute.should == 10\n  end\n\n  it \"should return the correct current second\" do\n    @cool_parser.current_second.should == 38\n    @heat_parser.current_second.should == 59\n    @auto_parser.current_second.should == 21\n  end\n\n  it \"should return the correct current time\" do\n    @cool_parser.current_time.hour.should == 9\n    @cool_parser.current_time.min.should == 52\n    @cool_parser.current_time.sec.should == 38\n\n    @heat_parser.current_time.hour.should == 16\n    @heat_parser.current_time.min.should == 36\n    @heat_parser.current_time.sec.should == 59\n\n    @auto_parser.current_time.hour.should == 13\n    @auto_parser.current_time.min.should == 10\n    @auto_parser.current_time.sec.should == 21\n  end\n\n  it \"should return the filter time in hours\" do\n    @cool_parser.filter_time_hours_remaining.should == 0\n    @heat_parser.filter_time_hours_remaining.should == 0\n    @auto_parser.filter_time_hours_remaining.should == 0\n  end\n\n  it \"should return the filter time in minutes\" do\n    @cool_parser.filter_time_minutes_remaining.should == 0\n    @heat_parser.filter_time_minutes_remaining.should == 0\n    @auto_parser.filter_time_minutes_remaining.should == 0\n  end\n\n  it \"should return the compressor runtime in hours\" do\n    @cool_parser.compressor_run_time.should == 4\n    @heat_parser.compressor_run_time.should == 289\n    @auto_parser.compressor_run_time.should == 0\n  end\n\n  it \"should return the cool runtime in minutes\" do\n    @cool_parser.cool_runtime_in_minutes.should == 240\n    @heat_parser.cool_runtime_in_minutes.should == 17340\n    @auto_parser.cool_runtime_in_minutes.should == 0\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[61,0],[61,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":32,"autoscroll":true,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/intellisource/apollo/spec/models/basic_status_payload_parser_spec.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"1750ba4c0ff2a8c449bc03a300ce37496b7e2325","deserializer":"TextBuffer"},{"text":"class ControlEvent < FullyPlannedControlEvent\n  belongs_to :standby_control_event\n\n  validate :start_time_not_before_standby_start_time\n  validate :end_time_not_after_standby_end_time\n  validate :dispatched_event_rate_contracts\n  validate :dispatched_event_nodes\n\n  def scheduled?\n    standby_control_event.present?\n  end\n\n  def included_in_standby?\n    standby_control_event.present?\n  end\n\nprotected\n  def has_standby_event?\n    self.standby_control_event_id.present?\n  end\n\n  def start_time_not_before_standby_start_time\n    if has_standby_event?\n      errors.add(:start_time, \"must not be before associated standby control event's start time\") if self.standby_control_event.start_time > self.start_time\n    end\n  end\n\n  def end_time_not_after_standby_end_time\n    if has_standby_event?\n      errors.add(:end_time, \"must not be after associated standby control event's end time\") if self.standby_control_event.end_time < self.end_time\n    end\n  end\n\n  def dispatched_event_rate_contracts\n    if has_standby_event? && array_contents_are_not_equal(self.rate_contracts, self.standby_control_event.rate_contracts)\n      errors.add(:base, \"Rate contracts for dispatched events must match the standby event\")\n    end\n  end\n\n  def dispatched_event_nodes\n    if has_standby_event? && array_contents_are_not_equal(self.nodes, self.standby_control_event.nodes)\n      errors.add(:base, \"Nodes for dispatched events must match the standby event\")\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":42,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/intellisource/common/app/models/control_event.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"a13c8ec91dee1f34bda7455132d1ec17fdd48b73","deserializer":"TextBuffer"},{"text":"class RateContract < ActiveRecord::Base\n  include Deactivatable\n  include AsJsonHelpers\n\n  belongs_to :equipment_type\n\n  delegate :ttm_type, to: :equipment_type, allow_nil: true\n\n  has_many :control_event_rate_contracts, foreign_key: :rate_contract_id\n  has_many :control_events, through: :control_event_rate_contracts\n\n  has_many :rate_contracts_excluded_participant_types\n  has_many :excluded_participant_types, class_name: ParticipantType.name, through: :rate_contracts_excluded_participant_types\n  has_many :promo_codes\n\n  INDIRECT_TYPES = ['IndirectControlRateContract', 'PjmEconomicRateContract', 'PjmCapacityRateContract']\n\n  scope :indirect_control,     -> { where(type: INDIRECT_TYPES) }\n  scope :pjm_economic,         -> { where(type: 'PjmEconomicRateContract') }\n  scope :pjm_capacity,         -> { where(type: 'PjmCapacityRateContract') }\n  scope :direct_control,       -> { where(type: 'DirectControlRateContract') }\n  scope :tou,                  -> { where(type: 'TouRateContract') }\n  scope :ptr,                  -> { where(type: 'PtrRateContract') }\n  scope :non_indirect_control, -> { where('type NOT IN (?)', INDIRECT_TYPES) }\n\n  scope :for_participant_type, lambda { |participant_type|\n    where(\"id NOT IN (SELECT rate_contract_id FROM rate_contracts_excluded_participant_types WHERE excluded_participant_type_id = ?)\", participant_type.id)\n  }\n\n  has_many :rate_contract_restrictions, dependent: :destroy do\n    def for_date(date=Time.zone.now)\n      if season = Season.for_date(date)\n        find_by_season_id(season)\n      end\n    end\n  end\n\n  DEFAULT_INCREMENT = 5.minutes\n  VALID_PORTAL_USER_SSO_VALUES = ['email', 'account_number']\n\n  validates_inclusion_of :portal_user_sso_login, in: RateContract::VALID_PORTAL_USER_SSO_VALUES, allow_nil: true\n\n  validates_numericality_of :max_hours_this_year, :max_events_this_year,\n                            greater_than_or_equal_to: 0, allow_nil: true\n  validates_numericality_of :pre_event_alert_minutes\n\n  validate :validate_only_one_default\n\n  has_paper_trail\n\n  def self.default\n    count == 1 ? first : self.where(is_default: true).first\n  end\n\n  def self.load_by_rate_contract\n    hash = {}\n    RateContract.all.each do |rc|\n      hash[rc.name] = rc.total_load\n    end\n    hash\n  end\n\n  def c_and_i?\n    false\n  end\n\n  # Returns true if all configured rate contracts are indirect control\n  def self.all_indirect?\n    RateContract.exists? && !RateContract.where(\"type IS NULL OR type NOT IN (?)\", INDIRECT_TYPES).exists?\n  end\n\n  def devices_under_nodes(nodes)\n    conditions = if rate_address_ids.blank?\n      #Just looking for C&I meters bound to this rate contract through rate_contract_committables\n      [\"rate_contract_committables.indirect_control_rate_contract_id = ?\", self.id]\n    else\n      #Looking for stats bound to this rate contract through rate_address, or C&I meters bound to this rate contract through rate_contract_committables\n      [\"rate_address_id IN (?) OR rate_contract_committables.indirect_control_rate_contract_id = ?\", rate_address_ids, self.id]\n    end\n    Device.under_nodes(nodes).includes(:device_type, :rate_contract_committables).where(conditions).references(:rate_contract_committables)\n  end\n\n  def transmitters\n    @transmitters ||= rate_addresses.map( &:transmitters ).flatten.uniq\n  end\n\n  def rate_addresses\n    @rate_addresses ||= RateAddress.for_rate_contract(self)\n  end\n\n  def rate_address_ids\n    @rate_address_ids ||= rate_addresses.collect(&:id)\n  end\n\n  def self.select_list\n    order('name ASC').map{ |rc| [rc.name, rc.id] }\n  end\n\n  def self.configured?\n    DirectControlRateContract.configured? || IndirectControlRateContract.configured? || TouRateContract.configured?\n  end\n\n  def direct?\n    false\n  end\n\n  def indirect?\n    false\n  end\n\n  def tou?\n    false\n  end\n\n  def pjm?\n    false\n  end\n\n  def pjm_economic?\n    false\n  end\n\n  def pjm_capacity?\n    false\n  end\n\n  def ptr?\n    false\n  end\n\n  # total for all rate contracts\n  def self.total_load\n    self.all.inject((0..0)) {|range, rc| range += rc.total_load}\n  end\n\n  def contract_limits\n    @contract_limits ||= begin\n      limits = []\n      if max_hours_this_year.to_i > 0\n        limits << { name: 'Hour Limit',\n                    used: hours_used_this_year,\n                    percent_used: (hours_used_this_year / max_hours_this_year * 100).round,\n                    limit: max_hours_this_year }\n      end\n      if max_events_this_year.to_i > 0\n        limits << { name: 'Event Limit',\n                    used: number_of_events_this_year,\n                    percent_used: (number_of_events_this_year / max_events_this_year.to_f * 100).round,\n                    limit: max_events_this_year }\n      end\n      limits\n    end\n  end\n\n  def hours_used_this_year\n    @hours_used_this_year ||= control_events.real_events.year_to_date.map( &:duration_in_minutes ).sum.to_f / 60\n  end\n\n  def number_of_events_this_year\n    @number_of_events_this_year ||= control_events.real_events.year_to_date.count\n  end\n\n  def percent_used\n    contract_limits.map { | h | h[:percent_used] }.max || 0\n  end\n\n  # Returns true if the limits for events per year and day are all nil\n  def no_limits?\n    max_events_this_year.nil? &&\n      max_hours_this_year.nil? &&\n      max_events_this_day.nil? &&\n      max_hours_this_day.nil?\n  end\n\n  def self.start_times(increment=DEFAULT_INCREMENT)\n    midnight = Time.zone.now.midnight\n    [].tap do |results|\n      series = TimeSeries.new(midnight-1.second, midnight+1.day-1.second, increment, 1.second).each do |t|\n        results << I18n.l(t, format: :time_optional_meridiem).downcase\n      end\n    end\n  end\n\n  def available_start_times\n    RateContract.start_times(start_time_increment)\n  end\n\n  def start_time_increment\n    DEFAULT_INCREMENT\n  end\n\n  def notification_buffer_in_seconds\n    if shutdown_notification && shutdown_notification_type\n      shutdown_notification.send(\"#{shutdown_notification_type}\")\n    else\n      0.seconds\n    end\n  end\n\nprotected\n  def validate_only_one_default\n    if self.is_default? && RateContract.where(is_default: true).where(\"id != ?\", self.id).exists?\n      errors.add(:is_default, \"can only be set for one rate contract in the system\")\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":50,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/intellisource/common/app/models/rate_contract.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"943060b750660b8cfaf0d11ee3f0dfc8ba4a8d44","deserializer":"TextBuffer"},{"text":"class DirectControlRateContract < RateContract\n  has_many :rate_contract_control_strategies\n  has_many :control_strategies, :through => :rate_contract_control_strategies do\n    def default\n      where(['rate_contract_control_strategies.default = ?', true]).first\n    end\n  end\n\n  accepts_nested_attributes_for :rate_contract_restrictions\n  accepts_nested_attributes_for :rate_contract_control_strategies, :allow_destroy => true\n\n  before_validation :set_default_load_potential\n\n  validates_presence_of :name, :load_potential\n  validates_presence_of :rate_contract_control_strategies\n  validate :control_strategy_types_match\n  validates_uniqueness_of :name\n\n  scope :ordered_list, -> { order(:name) }\n\n  stampable\n  record_activities\n\n  def is_default_control_strategy?(cs)\n    control_strategies.default == cs\n  end\n\n  def can_destroy?\n    #Override deactivatable\n    true\n  end\n\n  def available_durations(cs = self.control_strategies.default)\n    cs.available_durations\n  end\n\n  def duration(cs = nil)\n    cs.duration\n  end\n\n  def repeats(start, stop, cs = self.control_strategies.default)\n    cs.repeats(start, stop)\n  end\n\n  def cycle_time( cs = self.control_strategies.default)\n    cs.cycle_time\n  end\n\n  def temp_offset?( cs = self.control_strategies.default)\n    cs.temp_offset?\n  end\n\n  def graph_for_load(control_event, cs = self.control_strategies.default)\n    #flot has no support for time zones, so deal with it server side\n    localized_start = control_event.start_time + control_event.start_time.gmtoff\n    localized_end = control_event.end_time + control_event.end_time.gmtoff\n\n    points = cs.graph_for_load(localized_start, localized_end, self.total_load(control_event.nodes))\n    Graph.new(points, localized_start, localized_end)\n  end\n\n  def allow_control?(time=Time.zone.now)\n    if restriction = self.rate_contract_restrictions.for_date(time)\n      restriction.allow_control?(time)\n    else\n      true\n    end\n  end\n\n  def self.configured?\n    Season.configured? && ControlStrategy.configured? && self.count > 0\n  end\n\n  def four_period_graph\n    start_of_day = 0\n\n    [[start_of_day, 4],\n     [start_of_day + 6.hours / 60, 4],\n     [start_of_day + 6.hours / 60, 6],\n     [start_of_day + 12.hours / 60, 6],\n     [start_of_day + 12.hours / 60, 8],\n     [start_of_day + 18.hours / 60, 8],\n     [start_of_day + 18.hours / 60, 5],\n     [start_of_day + 24.hours / 60, 5]\n    ]\n  end\n\n  def three_period_graph\n    start_of_day = 0\n\n    [[start_of_day, 4],\n     [start_of_day + 8.hours / 60, 4],\n     [start_of_day + 8.hours / 60, 6],\n     [start_of_day + 16.hours / 60, 6],\n     [start_of_day + 16.hours / 60, 2],\n     [start_of_day + 24.hours / 60, 2],\n    ]\n  end\n  def two_period_graph\n    start_of_day = 0\n\n    [[start_of_day, 4],\n     [start_of_day + 12.hours / 60, 4],\n     [start_of_day + 12.hours / 60, 6],\n     [start_of_day + 24.hours / 60, 6],\n    ]\n  end\n  def one_period_graph\n    start_of_day = 0\n\n    [[start_of_day, 4],\n     [start_of_day + 24.hours / 60, 4],\n    ]\n  end\n\n  def four_period_constraints\n    {\n      :moveable => [\"y\",\n                    \"x\",\n                    \"y\",\n                    \"x\",\n                    \"y\",\n                    \"x\",\n                    \"y\",\n                    \"none\"],\n      :y_snap_value => 1,\n      :x_snap_value => 15,\n      :no_snap => []\n     }\n  end\n\n  def three_period_constraints\n    {\n      :moveable => [\"y\",\n                    \"x\",\n                    \"y\",\n                    \"x\",\n                    \"y\",\n                    \"none\"],\n      :y_snap_value => 1,\n      :x_snap_value => 15,\n      :no_snap => []\n     }\n  end\n\n  def two_period_constraints\n    {\n      :moveable => [\"y\",\n                    \"x\",\n                    \"y\",\n                    \"none\"],\n      :y_snap_value => 1,\n      :x_snap_value => 15,\n      :no_snap => []\n     }\n  end\n\n  def one_period_constraints\n    {\n      :moveable => [\"y\",\n                    \"none\"],\n      :y_snap_value => 1,\n      :x_snap_value => 15,\n      :no_snap => []\n     }\n  end\n\n  def tier_for_date_time(date_time)\n    if ts = tou_schedules.for_date(date_time)\n      ts.tier(date_time)\n    end\n  end\n\n  def total_load(nodes = nil)\n    load = if nodes\n      EndPoint.active.commissioned.serviced.attached.for_rate_contract(self).under_nodes(nodes).sum(:connected_load_in_kw)\n    else\n      EndPoint.active.commissioned.serviced.attached.for_rate_contract(self).sum(:connected_load_in_kw)\n    end\n    rounded = (load * 100).round.to_f / 100\n    (rounded..rounded)\n  end\n\n  # Quick way to cast subclasses as direct control\n  def as_direct\n    becomes(DirectControlRateContract)\n  end\n\n  def direct?\n    true\n  end\n\nprotected\n  def set_default_load_potential\n    self.load_potential ||= 1.0\n  end\n\n  def control_strategy_types_match\n    if self.rate_contract_control_strategies.any? { | rc_cs | rc_cs.control_strategy.tou? }\n      self.errors.add(:base, \"TOU control strategies are not valid for this rate contract\")\n    end\n  end\nend\n\nrequire_dependency 'tou_rate_contract'\nrequire_dependency 'ptr_rate_contract'\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":54,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/intellisource/common/app/models/direct_control_rate_contract.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"2adf9140bf6014ecf58fa2bcf3cf449954e4fd7e","deserializer":"TextBuffer"},{"text":"class ControlRecord < ActiveRecord::Base\n  belongs_to :end_point\n  belongs_to :rate_contract\n  belongs_to :control_event, :class_name => \"BaseControlEvent\"\n  belongs_to :node\n  belongs_to :curtailment_service_provider\n\n  belongs_to :standby_control_event, :foreign_key => 'control_event_id'\n\n  has_one :premise, :through => :end_point\n\n  validates_uniqueness_of :end_point_id, :scope => :control_event_id\n\n  # TODO: Come up with a better name for scheduled, since it means two distinct things in control event\n  scope :scheduled,   -> { joins(:control_event).where(\"base_control_events.standby_control_event_id IS NOT NULL\") }\n  scope :unscheduled, -> { joins(:control_event).where(\"base_control_events.standby_control_event_id IS NULL\") }\n  scope :actual,      -> { joins(:control_event).where(\"base_control_events.type NOT IN ('SelfTestControlEvent', 'CommunicationOnlyControlEvent', 'StandbyControlEvent')\") }\n  scope :non_test,    -> { joins(:control_event).where(\"base_control_events.test_event IS NULL OR base_control_events.test_event = 0\") }\n  scope :standby,     -> { joins(:control_event).where(\"base_control_events.type = 'StandbyControlEvent'\") }\n\n  scope :for_premise,        ->(premise)        { joins(:end_point).where(\"end_points.premise_id = ?\", premise) }\n  scope :for_end_points,     ->(end_points)     { where(\"control_records.end_point_id IN (?)\", Array.wrap(end_points).map(&:id)) }\n  scope :for_control_events, ->(control_events) { where(\"control_event_id IN (?)\", Array.wrap(control_events).map(&:id))}\n  scope :for_rate_contracts, ->(rate_contracts) { where(\"rate_contract_id IN (?)\", Array.wrap(rate_contracts).map(&:id))}\n  scope :for_nodes,          ->(nodes)          { where(\"control_records.node_id IN (?)\", Array.wrap(nodes).map(&:id)) }\n  scope :for_csps,           ->(csps)           { where(\"curtailment_service_provider_id IN (?)\", Array.wrap(csps).map(&:id)) }\n  scope :between,            ->(start, stop)    { where(\"(control_records.end_time BETWEEN ? AND ?) OR (control_records.start_time BETWEEN ? AND ?)\", start, stop, start, stop) }\n  scope :for_month,          ->(month)          { between(month.beginning_of_month, month.end_of_month) }\n  scope :meters,             ->                 { joins(end_point: {device: :device_type}).where(device_types: {name: DeviceType::METERS}) }\n\n  scope :active_and_upcoming, -> {\n    where([\n      \"start_time <= ? AND end_time >= ?\",\n      Time.zone.now + 1.hour,\n      Time.zone.now - 1.hour\n    ]).order('start_time ASC')\n  }\n\n  scope :with_real_not_canceled_unstarted_events, -> {\n    joins(:control_event)\n    .merge(BaseControlEvent.real_events)\n    .merge(BaseControlEvent.not_canceled)\n    .merge(BaseControlEvent.finished)\n  }\n\n  scope :indoor_temp_delta_with_number_of_events, -> (delta, delta_operand, number_of_events) {\n    with_real_not_canceled_unstarted_events\n    .where(\"indoor_temperature_delta #{delta_operand} #{delta} and indoor_temperature_delta is NOT NULL\")\n    .having(\"count(end_point_id) >= #{number_of_events}\").group(\"end_point_id\")\n  }\n\n  def self.for_csp_account_enrollments(csp)\n    CspAccountEnrollmentScope.new(csp).for_control_record(all, :include_currently_owned => true)\n  end\n\n  # For real-time events, we have no end time\n  # This attr reader makes it so if the end time is\n  # nil, we interpret the end time as now, and so\n  # things like the performance screen will show\n  # the end point as participating up to the current time\n  def end_time\n    return nil if self[:end_time].nil? && start_time.nil?\n    self[:end_time].try(:in_time_zone) || [start_time, Time.zone.now].max\n  end\n\n  def actual_end_time\n    actual_start_time + duration\n  end\n\n  private\n\n  def duration\n    end_time - start_time\n  end\n\n  def randomized_start_time\n    end_point.randomized_control_started.for_event(control_event).first.try(:created_at)\n  end\n\n  def actual_start_time\n    @actual_start_time ||= (randomized_start_time || start_time)\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":86,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[{"patches":[{"oldRange":[[66,0],[66,0]],"newRange":[[66,0],[67,0]],"oldText":"","newText":"    actual_start_time + duration\n","normalizeLineEndings":false,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[67,0],[78,0]],"newRange":[[67,0],[67,0]],"oldText":"    # control event canceled early\n    return control_event_terminated_early_time if control_event_terminated_early_time.present?\n\n    now = Time.zone.now\n    return end_time if now < end_time || control_event_ended?\n\n    # return end_time after a max of two hours after the end time, basically give up\n    return end_time if now > (end_time + 1.hour)\n\n    # must be a random start/end strategy, just add a minute and will check again\n    now + 1.minute\n","newText":"","normalizeLineEndings":false,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[71,0],[71,0]],"newRange":[[71,0],[73,0]],"oldText":"","newText":"  def duration\n    end_time - start_time\n","normalizeLineEndings":false,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[73,0],[75,0]],"newRange":[[73,0],[73,0]],"oldText":"  def control_event_ended?\n    end_point.randomized_control_ended.for_event(control_event).exists?\n","newText":"","normalizeLineEndings":false,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[75,0],[75,0]],"newRange":[[75,0],[77,0]],"oldText":"","newText":"  def randomized_start_time\n    end_point.randomized_control_started.for_event(control_event).first.try(:created_at)\n","normalizeLineEndings":false,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[77,0],[79,0]],"newRange":[[77,0],[77,0]],"oldText":"  def control_event_terminated_early_time\n    end_point.randomized_control_terminated.for_event(control_event).first.try(:created_at)\n","newText":"","normalizeLineEndings":false,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[78,0],[78,0]],"newRange":[[78,0],[82,0]],"oldText":"","newText":"\n  def actual_start_time\n    @actual_start_time ||= (randomized_start_time || start_time)\n  end\n","normalizeLineEndings":false,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"}],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/intellisource/common/app/models/control_record.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"78c51d8442e055101336540b9b13f7611ef43140","deserializer":"TextBuffer"},{"text":"class BaseControlEvent < ActiveRecord::Base\n  include Comverge::Units\n  include ControlEvents\n  include RedisLocking\n\n  alias_attribute :notification_time, :created_at\n\n  has_many :triggers, -> { order(:id) }, :dependent => :destroy, :foreign_key => :control_event_id\n  has_many :control_records, :dependent => :delete_all, :foreign_key => :control_event_id\n  has_many :historical_online_statuses, :foreign_key => :control_event_id\n  has_many :historical_commissioned_statuses, :foreign_key => :control_event_id\n  has_many :control_event_rate_contracts, :dependent => :destroy, :foreign_key => :control_event_id\n  has_many :rate_contracts, :through => :control_event_rate_contracts, :foreign_key => :control_event_id\n  has_many :control_event_nodes, :dependent => :destroy, :foreign_key => :control_event_id\n  has_many :nodes, :through => :control_event_nodes\n  has_many :control_event_c_and_i_premises, :dependent => :destroy, :foreign_key => :control_event_id\n  has_many :c_and_i_premises, :through => :control_event_c_and_i_premises\n  has_many :control_event_end_points, :foreign_key => :control_event_id\n\n  has_many :control_state_events, :as => :reference\n  has_many :portal_premise_surveys, :as => :source\n\n  has_one :control_history_report, :dependent => :destroy, :validate => true, :foreign_key => :control_event_id\n\n  has_one :escalation_path, :validate => true, :foreign_key => :control_event_id\n\n  scope :with_standby, lambda { where(\"base_control_events.standby_control_event_id IS NOT NULL\")}\n\n  scope :events_and_standby_events, lambda {\n    where(:type => [\n      ControlEvent.name,\n      StandbyControlEvent.name,\n      SelfTestControlEvent.name,\n      CommunicationOnlyControlEvent.name,\n      RealTimeControlEvent.name,\n      EmergencyControlEvent.name,\n      PtrControlEvent.name\n    ])\n  }\n\n  scope :non_template, -> { where(\"template IS NULL OR template = ?\", false) }\n  scope :template, -> { where(template: true) }\n\n  scope :pending, -> {\n    { :conditions => [ \"base_control_events.start_time > ? AND canceled_at IS NULL\", Time.zone.now ] }\n  }\n\n  scope :pending_or_in_progress, -> {\n    where(\"base_control_events.end_time > ? AND base_control_events.canceled_at IS NULL\", Time.zone.now)\n  }\n\n  scope :in_progress, -> {\n    pending_or_in_progress.where(\"base_control_events.start_time < ?\", Time.zone.now)\n  }\n\n  scope :pending_canceled, -> {\n    where(\"canceled_at IS NOT NULL AND start_time > canceled_at AND end_time > ?\", Time.zone.now)\n  }\n\n  scope :shortened, -> {\n    where(\"canceled_at IS NOT NULL AND start_time < canceled_at AND end_time > ?\", Time.zone.now)\n  }\n\n  scope :not_canceled, -> { where(canceled_at:  nil) }\n\n  scope :scheduled, lambda {\n    where(\n      \"(end_time IS NULL OR end_time > :now) \" +\n      \"AND canceled_at IS NULL \" +\n      \"AND (template IS NULL OR template = :template)\",\n      { :now => Time.zone.now, :template => false }\n    )\n  }\n\n  scope :today, -> {\n    now = Time.zone.now\n    where(start_time: now.beginning_of_day..now.end_of_day).order(:start_time)\n  }\n\n  def self.after_today\n    future(Time.zone.now.end_of_day)\n  end\n\n  scope :yesterday, -> {\n    yesterday = 1.day.ago\n    where(start_time: yesterday.beginning_of_day..yesterday.end_of_day).order(:start_time)\n  }\n\n  scope :tomorrow, -> {\n    tomorrow = 1.day.from_now\n    where(start_time: tomorrow.beginning_of_day..tomorrow.end_of_day).order(:start_time)\n  }\n\n  scope :future, lambda { |*args|\n    raise ArgumentError.new(\"expecting zero or one argument\") if args.length > 1\n    now = (args.length == 1) ? args[0] : Time.zone.now\n    where('base_control_events.start_time > :time', :time => now).order(:start_time)\n  }\n\n  def self.after(datetime)\n    future(datetime)\n  end\n\n  # If the end time or canceled_at is in the past, we're done with this event.\n  scope :finished, lambda { finished_before(Time.zone.now) }\n\n  scope :finished_before, lambda { |time|\n    where(\"COALESCE(base_control_events.canceled_at, base_control_events.end_time) <= ?\", time)\n  }\n\n  scope :finished_after, lambda { |time|\n    where(\"COALESCE(base_control_events.canceled_at, base_control_events.end_time) > ?\", time)\n  }\n\n  scope :finished_between, lambda { |start, stop|\n    finished_before(stop).finished_after(start)\n  }\n\n  scope :between_dates, ->(start, stop) {\n    where(start_time: start.beginning_of_day..stop.end_of_day).order(:start_time)\n  }\n\n  scope :opt_outs_prevented, -> { where(prevent_opt_outs: true) }\n  scope :for_device, lambda { | device |\n    { :include => { :nodes => :devices }, :conditions => [ \"devices.id = ?\", device.id ] }\n  }\n  scope :for_date, lambda { | date |\n    where(\"base_control_events.start_time BETWEEN ? AND ?\", date.beginning_of_day, date.end_of_day)\n  }\n\n  scope :year_to_date, lambda {\n    now = Time.zone.now\n    { :conditions => [\"base_control_events.start_time BETWEEN ? AND ?\", now.beginning_of_year, now],\n      :order => :start_time }\n  }\n\n  scope :at_time, lambda { |time|\n    where([\"base_control_events.start_time < ? AND (base_control_events.end_time IS NULL OR\n      COALESCE(base_control_events.canceled_at, base_control_events.end_time) >= ?)\", time, time ])\n  }\n\n  scope :for_month, lambda { |month|\n    between_dates(month.beginning_of_month, month.end_of_month)\n  }\n\n  scope :for_c_and_i_premises, lambda {\n    includes(:c_and_i_premises).\n    where(\"control_event_c_and_i_premises.id IS NOT NULL\")\n  }\n\n  scope :for_c_and_i_premise, lambda { |premise|\n    joins(:control_event_c_and_i_premises).\n      where('control_event_c_and_i_premises.c_and_i_premise_id = ?', premise.id)\n  }\n\n  scope :for_csp, lambda {|csp|\n    if csp\n      readonly(false).\n        includes(:control_records => :curtailment_service_provider).references(:curtailment_service_providers).\n        where(\"curtailment_service_providers.id = ?\", csp.id)\n    else\n      all\n    end\n  }\n\n  scope :for_premise, lambda { |premise|\n    if premise\n      joins(:control_records => :end_point).\n      where(\"end_points.premise_id = ?\", premise.id).\n      group('base_control_events.id')\n    else\n      all\n    end\n  }\n\n  # Selects all historical events where the premise either\n  # participated, or should have participated, but opted out\n  scope :all_historical_for_premise, -> (premise) {\n    if premise.blank?\n      where(\"1=2\")\n    else\n      thermostat_ids = \"(\" + premise.devices.for_residential_display.map(&:id).join(\",\") + \")\"\n      select_clause = <<-SQL\n        DISTINCT base_control_events.*,\n                 rate_contracts.name AS premise_rate_contract_name,\n                 ( SELECT COUNT(*) FROM opt_outs\n                   WHERE\n                   opt_outs.device_id IN #{thermostat_ids}\n                   AND opt_outs.opt_out_date = DATE(base_control_events.start_time)\n                   AND opt_outs.created_at < IFNULL(LEAST(base_control_events.end_time, base_control_events.canceled_at), base_control_events.end_time)\n                 ) AS opted_out\n      SQL\n\n      joins_clause = <<-SQL\n         # rate contracts\n         LEFT OUTER JOIN control_event_rate_contracts ON control_event_rate_contracts.control_event_id = base_control_events.id\n         LEFT OUTER JOIN rate_contracts ON control_event_rate_contracts.rate_contract_id = rate_contracts.id\n\n         # tying the control events to a specific premise\n         LEFT OUTER JOIN control_event_nodes ON control_event_nodes.control_event_id = base_control_events.id\n         LEFT OUTER JOIN device_memberships ON device_memberships.node_id = control_event_nodes.node_id\n         LEFT OUTER JOIN devices ON device_memberships.device_id = devices.id AND devices.id IN #{thermostat_ids}\n         LEFT OUTER JOIN end_points ON end_points.device_id = devices.id\n                     AND end_points.premise_id = #{premise.id}\n\n         # rate addresses\n         LEFT OUTER JOIN rate_addresses ON devices.rate_address_id = rate_addresses.id\n\n         # opt-outs\n         LEFT OUTER JOIN opt_outs ON opt_outs.device_id = devices.id\n                     AND opt_outs.opt_out_date = DATE(base_control_events.start_time)\n\n         # control records\n         LEFT OUTER JOIN control_records ON control_records.control_event_id = base_control_events.id\n         LEFT OUTER JOIN end_points AS control_record_end_points ON control_records.end_point_id = control_record_end_points.id\n                     AND control_record_end_points.premise_id = #{premise.id}\n                     AND control_record_end_points.device_id = devices.id\n      SQL\n\n      where_clause = <<-SQL\n        ( base_control_events.canceled_at IS NULL\n          OR\n          base_control_events.canceled_at > base_control_events.start_time )\n        AND\n          base_control_events.end_time <= UTC_TIMESTAMP()\n        AND\n          (\n            ( control_record_end_points.id IS NOT NULL\n              AND\n              control_records.control_event_id = base_control_events.id )\n            OR\n            opt_outs.id IS NOT NULL )\n        AND\n          (\n            (end_points.position = 1 AND rate_addresses.end_point_1_contract_id = control_event_rate_contracts.rate_contract_id)\n            OR\n            (end_points.position = 2 AND rate_addresses.end_point_2_contract_id = control_event_rate_contracts.rate_contract_id)\n            OR\n            (end_points.position = 3 AND rate_addresses.end_point_3_contract_id = control_event_rate_contracts.rate_contract_id)\n            OR\n            (end_points.position = 4 AND rate_addresses.end_point_4_contract_id = control_event_rate_contracts.rate_contract_id)\n          )\n      SQL\n      select(select_clause).joins(joins_clause).where(where_clause).order(\"base_control_events.start_time DESC\")\n    end\n  }\n\n  scope :for_control_record_rate_contracts, lambda { |rate_contracts|\n    if rate_contracts.present?\n      joins(:control_records).\n      where(\"control_records.rate_contract_id\" => rate_contracts)\n    else\n      all\n    end\n  }\n\n  scope :for_control_record_nodes, lambda { |nodes|\n    if nodes.present?\n      leaves = nodes.map(&:self_or_leaves).flatten\n      joins(:control_records).\n      where(\"control_records.node_id\" => leaves)\n    else\n      all\n    end\n  }\n\n  scope :for_committable, lambda { |committable|\n    for_end_points(committable.end_points)\n  }\n\n  scope :for_end_points, lambda { |end_points|\n    select(\"DISTINCT base_control_events.*\").\n      joins(:control_records).\n      where(\"control_records.end_point_id IN (?)\", end_points.to_a)\n  }\n\n  scope :has_control_records, lambda {\n    joins(:control_records).\n    where(\"control_records.id IS NOT NULL\")\n  }\n\n  scope :with_control_record_associations, lambda {\n    includes(:control_records => [:end_point, :rate_contract, :node]).references(:end_point, :rate_contract, :node)\n  }\n\n  scope :self_tests, -> { where(type: \"SelfTestControlEvent\") }\n  scope :real_events, -> { where(test_event: false) }\n  scope :controlling_events, lambda {\n    where(\"`base_control_events`.`type` NOT IN (?)\", [\"CommunicationOnlyControlEvent\", \"StandbyControlEvent\"])\n  }\n  scope :communication_only_tests, -> { where(type: CommunicationOnlyControlEvent) }\n  scope :with_nodes, -> { includes(:nodes) }\n  scope :c_and_i, -> { includes(:rate_contracts).where(rate_contracts: {type: IndirectControlRateContract.name}) }\n\n  scope :actual, lambda { real_events.non_template }\n\n  scope :real_for_end_point_control_times, lambda { |end_point_id, start_time, end_time|\n    select(\"DISTINCT base_control_events.*\").\n      joins(:control_records).\n      where(\"base_control_events.test_event IS NULL OR base_control_events.test_event = 0\").\n      where(\"control_records.end_point_id = ?\", end_point_id).\n      merge(ControlRecord.between(start_time, end_time))\n  }\n\n  scope :for_year, lambda { |year|\n    where(\"YEAR(base_control_events.start_time) = ?\", year)\n  }\n\n  def self.for_csp_account_enrollments(csp)\n    CspAccountEnrollmentScope.new(csp).for_control_event(all, :include_currently_owned => true)\n  end\n\n  validate :check_text_message\n  validate :in_the_past, :if => :start_time_changed?, :unless => :template_or_canceled?\n  validate :far_enough_in_future, :unless => :override_restrictions?\n  validates_uniqueness_of :name, :if => :template?\n  validates_presence_of :name, :if => :template?\n  validate :there_has_to_be_at_least_one_device, :unless => Proc.new { | ce | ce.template? || ce.recurring? }\n  validates_presence_of :start_time, :unless => :template?\n  validate :rate_contract_restrictions_are_respected, :unless => Proc.new { | ce | ce.override_restrictions? || ce.template? }\n  validate :check_c_and_i_respond_tos, :unless => :recurring?\n  validate :check_for_nodes, :if => :requires_nodes?\n  validate :check_for_c_and_i_premises, :if => :requires_c_and_i_premises?\n  validate :end_time_within_bounds?, :unless => :template_or_canceled?\n\n  stampable\n  record_activities\n\n  before_validation :setup_c_and_i_data, :unless => :recurring?, :on => :create\n  after_create :update_selected_control_strategies\n  before_update :increment_modification_number\n\n  attr_accessor :rate_contract_to_selected_control_strategy_mapping\n\n  delegate :devices, :potential_devices, :device_count, :c_and_i_devices, :non_c_and_i_devices,\n           :potential_end_points, :end_points, :fetch_c_and_i_premises, :build_control_event_end_points,\n           :log_control_records, :end_points_by_rate_contract, :start_time_for_end_point, :end_time_for_end_point,\n           :to => :device_delegate\n\n  delegate :contact_emails, :notifiable_contacts,\n           :to => :c_and_i_premise_collection\n\n  def has_control_records?\n    control_records.exists?\n  end\n\n  def control_record_devices\n    Device.joins(:end_points => :control_records).where('control_records.control_event_id' => self.id)\n  end\n\n  def requested_power\n    Power.from_mw(requested_mw) if requested_mw.present?\n  end\n\n  def requested_power=(power)\n    if power.nil?\n      self.requested_mw = nil\n    else\n      self.requested_mw = power.to_mw\n    end\n  end\n\n  def device_delegate\n    @device_delegate ||= if prestores_end_points?\n      ControlEvents::PrestoredDeviceDelegate.new(self)\n    else\n      ControlEvents::DefaultDeviceDelegate.new(self)\n    end\n  end\n\n  def c_and_i_premise_collection\n    PremiseCollection.new(c_and_i_premises)\n  end\n\n  def c_and_i_accounts\n    Account.where(:id => c_and_i_premises.map(&:account_id))\n  end\n\n  def notification_policy\n    ControlEvents::NotificationPolicy.new(self)\n  end\n\n  def send_notifications(lifecycle_event)\n    notification_policy.lifecycle.trigger(lifecycle_event)\n  end\n\n  def template_or_canceled?\n    template? || canceled?\n  end\n\n  def check_text_message\n    return if self.text_message.blank?\n\n    unique_device_types = self.devices.on_elster.unique_device_types\n    check_text_message_size(unique_device_types)\n    check_text_message_format(unique_device_types)\n  end\n\n  def check_text_message_size(devices)\n    text_message_max_size = devices.map do |device|\n        device.perform_capability(:text_message_size) || nil\n    end.compact.min\n\n    if text_message_max_size.present? && text_message.length > text_message_max_size\n      errors.add(:base, \"Text message is too long (Maximum of #{text_message_max_size} characters)\")\n    end\n  end\n\n  def check_text_message_format(devices)\n    valid_chars = devices.inject([]) do |memo, device|\n      if memo.blank?\n        memo = device.perform_capability(:text_message_valid_characters) || []\n      elsif results = device.perform_capability(:text_message_valid_characters)\n        memo = memo & results\n      else\n        memo\n      end\n    end\n\n    if valid_chars.present?\n      if text_message.match(Regexp.new(\"[^#{valid_chars.join}]+\"))\n        errors.add(:base, \"Text message contains invalid characters (Valid characters are \\\"#{valid_chars.join('\\\", \\\"')}\\\")\")\n      end\n    end\n  end\n\n  def supports_text_messages?\n    devices.by_type(DeviceType::IHD).exists?\n  end\n\n  def service_point_status_histories\n    return [] if service_point_status_histories_enabled?\n\n    history_end_time = end_time\n    if canceled_at && start_time <= canceled_at && end_time >= canceled_at\n      history_end_time = canceled_at\n    end\n    ServicePointStatusHistory.between_times(start_time, history_end_time)\n  end\n\n  def service_point_status_histories_enabled?\n    never_started? || serial_addressing? || communication_only? || template || test_event || last_run.nil?\n  end\n\n  # Get either the end point or end point collection (for aggregated premises) for all meters controlled by this event\n  def end_points_or_collections_for_meters\n    EndPointOrCollectionCalculator.new(control_records.meters.includes(:end_point).map(&:end_point), rate_contracts).calculate\n  end\n\n  def recurring?\n    false\n  end\n\n  def standby?\n    false\n  end\n\n  def self_test?\n    false\n  end\n\n  def real_time?\n    false\n  end\n\n  def open_ended?\n    false\n  end\n\n  # Does the addressing part of this go by premise? (Uses nodes by default)\n  def premise_based?\n    false\n  end\n\n  def communication_only?\n    false\n  end\n\n  def requires_nodes?\n    true\n  end\n\n  def requires_c_and_i_premises?\n    false\n  end\n\n  def scheduled?\n    false\n  end\n\n  def emergency?\n    false\n  end\n\n  def ptr?\n    false\n  end\n\n  def actual?\n    !standby? && !template?\n  end\n\n  def no_report?\n    never_started? || !complete?\n  end\n\n  def never_started?\n    canceled? and canceled_at < start_time\n  end\n\n  def should_have_started?\n    start_time < Time.zone.now\n  end\n\n  def ever_started?\n    should_have_started? and\n      (!canceled? or canceled_at > start_time)\n  end\n\n  def shortened?\n    ever_started? and canceled? and canceled_at > start_time\n  end\n\n  def canceled?\n    canceled_at.present? and (end_time.nil? || canceled_at < end_time)\n  end\n\n  def complete?(time=Time.zone.now)\n    end_time && end_time < time\n  end\n\n  def pending?(time=Time.zone.now)\n    !canceled? && !should_have_started?\n  end\n\n  def active?(time=Time.zone.now)\n    !complete?(time) && !pending?(time)\n  end\n\n  def dispatchable?\n    standby? && !canceled? && (pending? || active?)\n  end\n\n  # True if the control event is scheduled to start on the same day as the time given\n  # NOTE: This takes a time object, not a date object!\n  def on_same_day?(time=Time.zone.now)\n    start_time >= time.beginning_of_day && start_time <= time.end_of_day\n  end\n\n  # When should event notifications go out?\n  def notification_trigger_time(notification)\n    start_time - notification\n  end\n\n  def status\n    now = Time.zone.now\n    return 'canceled' if never_started?\n    return 'shortened' if shortened?\n    return 'complete' if complete?(now)\n    return 'pending' if pending?(now)\n    'active'\n  end\n\n  def display_status\n    status.titleize\n  end\n\n  def serial_addressing?\n    false\n  end\n\n  def node_names\n    nodes.inject('') { |str, node| str << node.name + \" \" }\n  end\n\n  def premise_names\n    c_and_i_premises.map(&:display_name).join(' ')\n  end\n\n  def node_or_premise_names\n    premise_based? ? premise_names : node_names\n  end\n\n  def rate_contracts_and_control_strategies(reload=false)\n    if new_record? and (mapping = rate_contract_to_selected_control_strategy_mapping).present?\n      mapping.map do | rate_contract_id, control_strategy_id |\n        control_strategy = control_strategy_id.nil? ? nil : ControlStrategy.find_by_id(control_strategy_id)\n        [ RateContract.find(rate_contract_id.to_i), control_strategy ]\n      end\n    else\n      if new_record? # this check required since rails 4 populates join table records before rails 3 did\n        []           # TODO: check into has_many options to see if this can be removed\n      else\n        control_event_rate_contracts(reload).map { |cerc| [ cerc.rate_contract, cerc.selected_control_strategy ] }\n      end\n    end\n  end\n\n  def total_load\n    rate_contracts.inject(0) do |load, rc|\n      load + rc.total_load(self.nodes)\n    end\n  end\n\n  def actual_end_time\n    canceled_at || end_time\n  end\n\n  def duration\n    if start_time && actual_end_time && start_time < actual_end_time\n      (actual_end_time - start_time).to_i\n    else\n      0\n    end\n  end\n\n  def duration_in_minutes\n    duration / 60\n  end\n\n  # Public: returns a range of hours for which there are relevant load commitments\n  #\n  # For example, an event from 15:00 - 16:00 should return (16 .. 16) (hour ending 16)\n  # whereas an event from 15:30 - 17:30 should return (16 .. 18)\n  #\n  # Returns: a range of integers, representing hours\n  def commitment_hours\n    # add 1 second to start_time here to prevent the case where 15:00 - 16:00 returns [16, 17]\n    # when it should return [16]\n    ( (start_time+1.second).hour_ending.hour .. end_time.hour_ending.hour )\n  end\n\n  # returns the seconds required by the longest running of all strategies to be run\n  def max_duration_in_seconds\n    rate_contracts_and_control_strategies.map { |rc, cs| rc.duration(cs) }.max\n  end\n\n  # returns the minutes required by the longest running of all strategies to be run\n  def max_duration\n    max_duration_in_seconds / 60.0\n  end\n\n  # returns an array of arrays, each inner array contains 2 items\n  # the first is a string representation of the duration, e.g. \"30 minutes\",\n  # the second is a float of the number of minutes, e.g. 30.0\n  def available_durations\n    durations = []\n\n    rate_contracts_and_control_strategies.each do |rc, cs|\n      rc.available_durations(cs).each do |duration|\n        # only allows the most restrictive duration\n        if ExtraRequirementSystem.enabled?(:aggregator)\n          durations << duration if max_duration.zero? || ((duration[1] % max_duration) == 0)\n        else\n          durations << duration if duration[1] >= max_duration\n        end\n      end\n    end\n\n    durations = durations.sort_by(&:last)\n    durations.uniq!\n    durations\n  end\n\n  def available_start_times\n    if (rate_contracts.empty?)\n      RateContract.start_times\n    else\n      most_restrictive_rate_contract.available_start_times\n    end\n  end\n\n  def most_restrictive_rate_contract\n    rate_contracts.min_by { |rc| rc.available_start_times.last }\n  end\n\n  def graph\n    graph_data = []\n    merged_graphs = MergedGraph.new\n    rate_contracts_and_control_strategies.each do |rc, cs|\n      merged_graphs.add_graph rc.graph_for_load(self, cs)\n    end\n    [{ :data => merged_graphs.data }]\n  end\n\n  # Check user rights to see if they can access this\n  # Admin users and control operators can access anything\n  def can_view?(user)\n    (user.administrator? || user.control_operator?)\n  end\n\n  def as_json(options = {})\n    json = super(options.merge(:root => 'control_event'))\n    json = massage_json(json) if respond_to?(:massage_json)\n    json['control_event']['duration'] = self.duration\n    json['control_event']['start_time_js'] = I18n.l(self.start_time, :format => :time_optional_meridiem) if self.start_time\n    { :control_event => json,\n      :node_ids => self.nodes.map( &:id ),\n      :c_and_i_premise_ids => self.c_and_i_premises.map( &:id ),\n      :rate_contracts => self.rate_contracts_and_control_strategies.map { |rc, cs|\n        { :id => rc.id, :control_strategy_id => cs.try(:id) }\n      }\n    }\n  end\n\n  def save_historical_statuses\n    smartgrid_info \"trying to obtain lock\"\n    result = redis_lock do\n      smartgrid_info \"lock attained, saving historical statuses\"\n      save_online_statuses\n      save_commissioned_statuses\n      smartgrid_info \"finished saving historical statuses\"\n    end\n    smartgrid_info \"failed to obtain lock, historical statuses not created\" unless result\n  end\n\n  # called from daemon process\n  def run(messages)\n    send_messages(messages)\n    self.update_attribute(:last_run, Time.zone.now)\n  end\n\n  def max_notification_buffer\n    rate_contracts.collect(&:notification_buffer_in_seconds).max\n  end\n\n  def cancelable?\n    if max_notification_buffer > 0\n      !canceled? and start_time > Time.zone.now + max_notification_buffer\n    else\n      !complete? and !canceled?\n    end\n  end\n\n  ################################################################################\n  # Cancel Logic\n  ################################################################################\n\n  def cancel!(restore_type='graceful')\n    smartgrid_info(\"Cancel Control Event Type: #{restore_type} is active? #{active?}\")\n\n    cancel_active_event(restore_type)  and return self if active?\n    cancel_pending_event(restore_type) and return self if pending?\n    return self\n  end\n\n  # Send restore messages\n  # Update control records to indicate cancel\n  # Deactivate triggers that are yet to be run\n  # Notify the end users.\n  def cancel_active_event(restore_type)\n    update_attribute(:canceled_at, Time.zone.now)\n    send_restore_messages(restore_type)\n    deactivate_triggers\n    ControlEventWorker.enqueue(:log_control_records, nil, self.id)\n    ControlEventNotificationWorker.enqueue(:event_shorten, self.id)\n  end\n\n  # We haven't started yet, deactivate triggers to keep any more messages from\n  # going out, then build and send any restore messages to clean up control\n  # messages that HAVE been sent.\n  #\n  # Also cancel pre-event alert if needed\n  def cancel_pending_event(restore_type)\n    update_attribute(:canceled_at, Time.zone.now)\n    cancel_pre_event_alert\n\n    # Note: this isn't fully correct in mixed-populations where some control\n    # messages may have gone out, and some not.  Fix this later when that matters.\n    send_restore_messages_for_pending_control(restore_type)\n\n    deactivate_triggers\n\n    ControlEventNotificationWorker.enqueue(:event_cancel, self.id)\n  end\n\n  def send_restore_messages_for_pending_control(restore_type)\n    return unless canceled? and any_control_messages_sent?\n\n    # send cancel messages only if their corresponding control\n    # messages have probably already gone out.\n    send_messages cancel_messages(restore_type).select { |message|\n     (start_time - message.class.control_message_lead_time) < Time.zone.now\n    }\n  end\n\n  def send_restore_messages(restore_type)\n    return if restore_type == 'no_message'\n    send_messages(cancel_messages(restore_type))\n  end\n\n  def cancel_messages(restore_type)\n    pregenerated_restore_messages(restore_type) +\n      postgenerated_restore_messages(restore_type)\n  end\n\n  def pregenerated_restore_messages(restore_type)\n    select_trigger_messages(&:cancel?).each do |message|\n      message.restore_type = restore_type\n      message.save if message.changed?\n    end\n  end\n\n  def postgenerated_restore_messages(restore_type)\n    select_trigger_messages(false, &:control?).\n      select(&:generate_restore_messages_at_cancel?).\n      map{ |m| m.generate_cancel(restore_type) }\n  end\n\n  # Don't let any future triggers fire for this event\n  def deactivate_triggers\n    triggers.active.each(&:deactivate!)\n  end\n\n  def cancel_pre_event_alert\n    max_pre_event_alert_minutes = rate_contracts.map(&:pre_event_alert_minutes).compact.max\n    if (self.start_time - Time.zone.now) < max_pre_event_alert_minutes.minutes\n      cancel_alert_messages = select_trigger_messages(&:cancel_alert?)\n      send_messages(cancel_alert_messages)\n    end\n  end\n\n  def any_control_messages_sent?\n    sent_control_messages.any?\n  end\n\n  def sent_control_messages\n    select_trigger_messages(false, &:control?). # any control message, with an active OR inactive trigger.\n      select {|m| m.message_logs.any? }         # And now only those that have message logs\n  end\n\n  ################################################################################\n  # </Cancel Logic>\n  ################################################################################\n\n\n  def uses_non_default_control_strategy?\n    rate_contracts_and_control_strategies.any? { |rc, cs|\n      cs && cs != rc.control_strategies.default\n    }\n  end\n\n  def rate_contract_names\n    rate_contracts.map(&:name).join(', ')\n  end\n\n  def transmitters\n    self.unique_transmitters\n  end\n\n  def group_addressing_for_rate_contract(rc)\n    return [] unless self.rate_contracts.include?(rc)\n    addresses = Set.new\n\n    self.nodes.each do |node|\n\n      areas = node.area_addressing\n\n      RateAddress.for_rate_contract(rc).under_node(node).each do |ra|\n\n        functions = ra.functions_for_rate_contract(rc)\n        rate = {:rate => ra.address}\n\n        areas.each do |area|\n          addressing = area.merge(rate.merge(functions))\n\n          transmitters = Transmitter.for_rate_address_under_node(ra, node)\n          transmitters.each do |t|\n            addressing = addressing.merge(:utility => t.utility) if t.utility.present?\n            addresses << addressing\n          end\n        end\n      end\n\n    end\n\n    addresses.to_a\n  end\n\n  def serial_addressing_for_rate_contract(rc)\n    return [] unless rate_contracts.include?(rc)\n    return [] unless serial_addressing?\n\n    devices.controllable.for_rate_contract(rc).uniq.map do |device|\n      device.serial_addressing_for_rate_contract(rc)\n    end.compact\n  end\n\n  def control_trigger\n    triggers.order(:trigger_datetime).where(:method_name => nil).first\n  end\n\n  def end_point_count_by_rate_contract(rc)\n    end_points_by_rate_contract(rc).count\n  end\n\n  def portal_users_for_rate_contract(rate_contract)\n    PortalUser.active.where(\"portal_user_premises.premise_id in (#{end_points_by_rate_contract(rate_contract).select('end_points.premise_id').to_sql})\").joins(:premises)\n  end\n\n  def online_end_point_count_by_rate_contract(rc)\n    HistoricalOnlineStatus.number_online_for_object(rc, self) || \"No Data\"\n  end\n\n  def online_end_point_load_potential_by_rate_contract(rc)\n    HistoricalOnlineStatus.object_online_load_potential(rc, self).round(1) || \"No Data\"\n  end\n\n  def controlled_end_point_count\n    number = 0\n    rate_contracts_and_control_strategies.each do |rc, cs|\n      number += controlled_end_point_count_for_rate_contract(rc, cs).to_i\n    end\n    number\n  end\n\n  def has_received_all_telemetries?(end_points=nil)\n    applicable_control_records = end_points.blank? ? control_records.meters : control_records.where(:end_point_id => end_points.map(&:id))\n    applicable_control_records.map(&:end_point).all? do |ep|\n      if ep\n        MeterTelemetry.where(\"collected_at >= ?\", end_time).where(:end_point_id => ep.id).first\n      else\n        false\n      end\n    end\n  end\n\n  def transmitters_for_rc(rc)\n    @transmitters ||= {}\n    @transmitters[rc] ||= rc.devices_under_nodes(self.nodes).map(&:transmitter_id).uniq.compact.map {|tid| Transmitter.find(tid) }\n  end\n\n  def all_one_way?(rc)\n    # if there are no transmitters, assume a two-way system\n    @all_one_way ||= {}\n    @all_one_way[rc] ||= begin\n      transmitters = transmitters_for_rc(rc)\n      transmitters.present? ? transmitters.all?{|tx| tx.one_way?} : false\n    end\n  end\n\n  def controlled_end_points_for_rate_contract(rc, cs)\n    return [] unless cs\n    @controlled_end_points_for_rate_contract ||= {}\n    key = cache_key(rc, cs)\n\n    if @controlled_end_points_for_rate_contract[key]\n      @controlled_end_points_for_rate_contract[key]\n    else\n      ep_scope = end_points_by_rate_contract(rc)\n      @controlled_end_points_for_rate_contract[key] = controlled_end_points_by_device_types_or_rate_contracts(ep_scope, rc, cycle_change_range(rc.cycle_time) )\n    end\n  end\n\n  def controlled_end_points_by_device_type(dt, rc = nil)\n    @controlled_end_points_by_device_type ||= {}\n    key = cache_key(dt, rc)\n\n    if @controlled_end_points_by_device_type[key]\n      @controlled_end_points_by_device_type[key]\n    else\n      ep_scope = end_points.by_device_type(dt).select(\"end_points.id\" )\n      @controlled_end_points_by_device_type[key] = controlled_end_points_by_device_types_or_rate_contracts(ep_scope, rc)\n    end\n  end\n\n  def cache_key(obj1, obj2)\n    [obj1, obj2].map {|obj| Array.wrap(obj).map(&:id).sort }.flatten.join '.'\n  end\n\n  # this returns end points that we know were controlled by this event due to\n  # messages they sent us. Each scope we use here should be mutually exclusive\n  # to all other scopes, or we might end up duplicating results.\n  #\n  # Ex: old IT800s only send message acks/naks, but newer ones also send\n  # ControlStarted *AS WELL AS* acks. Counting old ones by ONLY looking for\n  # acks will also include new ones, even if they later send a ControlOptedOut\n  # message. (We exclude this case in the EP scope, but the point is, you need\n  # to be aware of what the other scopes might return when adding a new one\n  # here.)\n  def controlled_from_device_push_message(ep_scope)\n    ep_scope.controlled_via_control_state_event(self) |\n    ep_scope.controlled_via_message_response(self)\n  end\n\n  def controlled_end_points_by_device_types_or_rate_contracts(ep_scope, rc, cycle_range = cycle_change_range)\n    if Array.wrap(rc).any? {|rc| rc.temp_offset? }\n      ep_scope.controlled_via_setback(cycle_range)\n    elsif Array.wrap(rc).any? { |rc| rc.tou? }\n      ep_scope.controlled_via_tou(cycle_range, rc)\n    else\n      ep_scope.controlled_via_cycling(cycle_range)\n    end.uniq | controlled_from_device_push_message(ep_scope)\n  end\n\n  def controlled_end_point_count_for_rate_contract(rc, cs)\n    return nil if all_one_way?(rc)\n    controlled_end_points_for_rate_contract(rc, cs).size\n  end\n\n  def controlled_end_point_load_for_rate_contract(rc, cs)\n    controlled_end_points_for_rate_contract(rc, cs).inject(0.0) {|s,ep| s + ep.connected_load_in_kw.to_f}\n  end\n\n  def commissioned_end_point_count_by_rate_contract(rc)\n    commissioned_by_object(rc)\n  end\n\n  def commissioned_end_point_load_potential_by_rate_contract(rc)\n    HistoricalCommissionedStatus.object_commissioned_load_potential(rc, self).round(1) || \"No Data\"\n  end\n\n  def commissioned_end_point_count_by_device_type(dt)\n    commissioned_by_object(dt)\n  end\n\n  def online_end_point_count_by_device_type(dt)\n    HistoricalOnlineStatus.number_online_for_object(dt, self) || \"No Data\"\n  end\n\n  # the time range in which we should be able to see the cycle counter change\n  def cycle_change_range(cycle_time = longest_cycle_time)\n    sample_time = ::Configuration.telemetry_sample_frequency\n    start_seek_time = start_time - sample_time\n    # go back forward that amount (to start time) and then go forward sample frequency and cycle time to ensure we see the counter jump\n    delta = 2 * sample_time + cycle_time\n    return (start_seek_time..start_seek_time+delta)\n  end\n\n  def any_indirect_control_rate_contracts?\n    rate_contracts.any?(&:c_and_i?)\n  end\n\n  def unique_transmitters\n    @unique_transmitters ||= begin\n      tx_ids = devices.where(rate_address_id: rate_address_ids).uniq.pluck(:transmitter_id).compact\n      Transmitter.find(tx_ids)\n    end\n  end\n\n  def message_builders\n    @message_builders ||= begin\n      dt_ids = devices.where(rate_address_id: rate_address_ids).uniq.pluck(:device_type_id).compact\n      DeviceType.find(dt_ids).map { |dt| dt.message_builder }.compact.uniq.map { |mb| mb.constantize }\n    end\n  end\n\n  def rate_addresses(force_reload=false)\n    flush_device_cache if force_reload\n    unless @rate_addresses\n      @rate_addresses = []\n      rate_contracts.each do |rc|\n        @rate_addresses.concat(rc.rate_addresses)\n      end\n      @rate_addresses.uniq!\n    end\n    @rate_addresses\n  end\n\n  #################################\n  # C&I Manual Notification Stuff\n  #################################\n  #Return all ControlEvents for the given quarter\n  def self.for_quarter(year, quarter)\n    start_month = 3 * (quarter.to_i-1) + 1\n    start_date = Date.civil(year, start_month, 1)\n    end_date = (start_date + 3.months) - 1.day\n    self.between_dates(start_date, end_date)\n  end\n\n  #Return all years from which there are ControlEvents\n  def self.possible_years\n    self.select(\"DISTINCT YEAR(start_time) as year\").order(\"year DESC\").to_a.map { |ce| ce.year.to_s }\n  end\n\n  # Return all control events for the given devices\n  def self.all_for_devices(*devices)\n    order('base_control_events.start_time').select('DISTINCT base_control_events.*').joins(:control_records => :end_point).where(:end_points => { :device_id => devices })\n  end\n\n  # maybe this should return a scope?\n  def self.events_for_device(device)\n    (\n     events_for_device_for_prestored(device.end_point).to_a +\n     events_for_device_not_prestored(device) +\n     self_test_events_for_device(device)\n    ).uniq\n  end\n\n  def self.self_test_events_for_device(device)\n    SelfTestControlEvent.after(1.day.ago).select { |ce| ce.devices.include?(device) }\n  end\n\n  def self.events_for_device_for_prestored(end_point)\n    BaseControlEvent.after(1.day.ago).\n                 with_standby.\n                 joins(:control_event_end_points).\n                 where(:control_event_end_points => { :end_point_id => end_point.id }).\n                 to_enum(:find_each)\n  end\n\n  def self.events_for_device_not_prestored(device)\n    BaseControlEvent.\n      after(1.day.ago).\n      to_enum(:find_each).\n      select {|ce| ce.devices.include?(device) }\n  end\n\n  def aggregator?\n    ExtraRequirementSystem.enabled?(:aggregator)\n  end\n\n  def markets?\n    ExtraRequirementSystem.enabled?(:markets)\n  end\n\n  # This control event includes manual C&I steps iff there is an escalation path associated with it\n  def c_and_i?\n    escalation_path.present?\n  end\n\n  def c_and_i_only?\n    c_and_i? && self.devices.all?(&:c_and_i?)\n  end\n\n  def all_tou?\n    rate_contracts.all?(&:tou?)\n  end\n\n  def any_tou?\n    rate_contracts.any?(&:tou?)\n  end\n\n  def load_provider_count\n    CAndIPremise.under_nodes(self.nodes).load_providers.count\n  end\n\n  def dr_measures_for(premises)\n    Array.wrap(premises).inject([]) do |measures, premise|\n      # Weed out any that don't belong to the rate contracts on this control event\n      premise.dr_measures.inject(measures) do |measures, measure|\n        measures << measure if self.rate_contracts.include?(measure.indirect_control_rate_contract)\n        measures\n      end\n    end\n  end\n\n  #################################\n\n  def m_and_v_premises\n    @m_and_v_premises ||= end_points.m_and_v_metered.map(&:premise).uniq\n  end\n\n  def to_s\n    end_time_string =  self.end_time.blank? ? \"?\" : I18n.l(self.end_time, :format => :control_event)\n    \"#{I18n.l(self.start_time, :format => :control_event)} - #{end_time_string}\"\n  end\n\n  def events_earlier_that_day(end_point)\n    BaseControlEvent.for_date(self.start_time).\n      joins(:control_records).\n      where('base_control_events.start_time < ?', self.start_time).\n      where(type: ['ControlEvent', 'RealTimeControlEvent']).\n      where(control_records: {end_point_id: end_point.end_points.map(&:id)}).\n      order('created_at DESC')\n  end\n\n  def control_record_for_end_point(end_point)\n    control_records.where(:end_point_id => end_point.id).first\n  end\n\n  # In the aggregator extra, we dispatch by device, not by area/rate address,\n  # and the devices will be a subset of the devices under the given nodes and\n  # rate contracts. We pre-store the end points to be used on the event at\n  # the time of event creation, rather than letting #devices recalculate\n  # each time. If any other program starts wanting to do this, this predicate\n  # should be changed to be more complicated. Affects #devices and #end_points\n  def prestores_end_points?\n    self.class.prestores_end_points?\n  end\n\n  def self.prestores_end_points?\n    ExtraRequirementSystem.enabled?(:aggregator)\n  end\n\n  def premises_controlled_by_event_with_telemetry_for_csp(csp)\n    self.c_and_i_premises.for_csp(csp).controlled_via_event_with_telemetry(self)\n  end\n\n  def select_trigger_messages(active=true, &message_selector)\n    scope = self.triggers\n    scope = scope.active if active\n    scope.inject([]) { |acc, trigger|\n      acc.concat(trigger.messages.select(&message_selector))\n    }\n  end\n\n  def humanized_type_name\n    \"#{type.gsub(\"ControlEvent\",\"\").underscore.humanize.titleize}#{test_event? ? \" Test\" : \"\" }\"\n  end\n\n  def controllable_rate_contract_device_types\n    meter_names_sql = DeviceType.meters.map(&:name).map{ |name| \"#{ActiveRecord::Base.connection.quote(name)}\" }.join(',')\n\n    sql = end_points.joins(:device => :device_type).\n      select(\"DISTINCT end_points.position, devices.device_type_id, devices.rate_address_id\").\n      where(\"device_types.name not in (#{meter_names_sql})\").to_sql\n\n    results = ActiveRecord::Base.connection.select_all sql\n\n    results.map do |rcd|\n    end_point_contract = \"end_point_#{rcd['position']}_contract\".to_sym\n      {\n        :device_type => DeviceType.find(rcd['device_type_id']),\n        :rate_contract => RateAddress.find(rcd['rate_address_id']).send(end_point_contract)\n      }\n    end.compact\n  end\n\n  def has_two_way_devices?\n    devices.any? { |d| d.capability?(:provides_two_way_communication?) }\n  end\n\n  def pubsub_group_name\n    nil\n  end\n\nprivate\n\n  def increment_modification_number\n    self.modification_number ||= 0\n    self.modification_number += 1\n  end\n\n  def update_selected_control_strategies\n    rc2cs_mapping = rate_contract_to_selected_control_strategy_mapping || {}\n    control_event_rate_contracts(true).each do |cerc|\n      cs = rc2cs_mapping[cerc.rate_contract_id.to_s]\n      cerc.update_attribute(:selected_control_strategy_id, cs) unless cs.nil?\n    end\n  end\n\n  def there_has_to_be_at_least_one_device\n    errors.add(:base, \"There must be at least one device.\") unless devices(true).any?\n  end\n\n  def create_control_and_restore_message_triggers\n    historical_status_set = Set.new\n\n    rate_contracts_and_control_strategies.each do |rate_contract, control_strategy|\n      next if rate_contract.c_and_i?\n\n      messages = []\n\n      # Addressing is a hash of { MessageBuilderClass => [addressing_info] }\n      addressing = message_builders.inject({}) { |memo, builder| memo[builder] = builder.addressing_for_rate_contract(self, rate_contract); memo }\n\n      messages += control_strategy.control_messages(self.start_time, self.duration,\n                                                    addressing, message_builders,\n                                                    self, rate_contract)\n\n      unless recurring?\n        messages += control_strategy.restore_messages(self.start_time, self.duration,\n                                                      addressing, message_builders,\n                                                      self, rate_contract)\n      end\n\n      messages.group_by { |message| message.send_at }.each do |send_at, messages|\n        self.triggers << trigger_for_messages(send_at, messages)\n        historical_status_set << send_at\n      end\n    end\n\n    historical_status_set.to_a.map do |send_at|\n      self.triggers << HistoricalStatusWorker.trigger_at(self, send_at)\n    end\n  end\n\n  def trigger_for_messages(send_at, messages)\n    ControlEventWorker.trigger_at(self, send_at).tap do | trigger |\n      trigger.messages = messages\n    end\n  end\n\n  def create_sep_tier_restore_message_triggers\n    # do this here instead of on TOU rate contract instances in case there\n    # are multiple TOU contracts, we only want one of these to run\n    triggers << SepTierScheduleWorker.schedule_next_tiers_for_event(self)\n  end\n\n  def any_sep_tou?\n    rate_contracts_and_control_strategies.any? { |_, cs| cs.try(:tou?) } and devices.by_type(DeviceType::SEP_DEVICES).count > 0\n  end\n\n  def flush_device_cache\n    device_delegate.flush_cache\n    @rate_addresses = nil\n    @rate_address_ids = nil\n    @unique_transmitters = nil\n    @message_builders = nil\n  end\n\n  def rate_address_ids\n    @rate_address_ids ||= rate_addresses.map { |ra| ra.id }\n  end\n\n  def in_the_past\n    if template\n      return\n    end\n\n    unless start_time >= Time.zone.now - 5.minutes\n      errors.add(:start_time, \"cannot be more than 5 minutes in the past. \")\n    end\n  end\n\n  def send_messages(messages)\n    logger.info(\"In send message with  with- #{messages.size} messages. \")\n    return if messages.empty?\n\n    han_ids = nil\n    filtered_messages_by_transmitter(messages, devices).each do |transmitter, transmitter_messages|\n      if han_ids.nil? && ItronTransmitter === transmitter\n        # This line caused a large performance regression, so don't do it.\n        # Itron will need han_ids, but we'll have to find another way to get them\n        han_ids = devices.joins(:service_point).uniq.pluck(:han_id).compact\n      end\n\n      options = {:han_ids => han_ids}\n\n      if ptr? && XmppTransmitter === transmitter\n        options[:group] = pubsub_group_name\n      end\n\n      transmitter.message_transaction do\n        transmitter_messages.each do |message|\n          transmitter.send_message(message, options)\n        end\n      end\n    end\n  end\n  public :send_messages\n\n  # Return a map of transmitters to the messages they will send\n  # Only send a message to a transmitter if it has any devices attached to\n  # it that will respond to it\n  def filtered_messages_by_transmitter(messages, device_scope)\n    transmitters.inject({}) { |memo, transmitter|\n      transmitter_messages = messages.select { |message| message_should_be_sent_on?(message, transmitter) }\n      memo[transmitter] = transmitter_messages unless transmitter_messages.empty?\n      memo\n    }\n  end\n\n  def message_should_be_sent_on?(message, transmitter)\n    device_scope = self.devices.\n                        where(:transmitter_id => transmitter.id).\n                        joins(:device_type).where('device_types.message_builder' => message.class.name)\n    device_addressing = message.addressing\n    if device_addressing.any?\n      aq = DeviceExtensions::AddressingQuery.new(device_addressing, device_scope)\n      device_scope = aq.devices\n    end\n\n    # We should never send an F1 all-call message for a PTR event unless\n    # we're sending it via an XMPP transmitter. Doing this would result\n    # in putting ALL of the F1 devices under control, rather than just\n    # the devices that have opted in to the event.\n    # DeviceExtensions::AddressingQuery won't handle this scenario\n    # because it doesn't know anything about events or transmitters.\n    if ptr? && non_xmpp_f1_all_call?(message, transmitter)\n      false\n    else\n      device_scope.any?\n    end\n  end\n\n  def non_xmpp_f1_all_call?(message, transmitter)\n    message.class.f1? &&\n    message.all_call? &&\n    transmitter.type != 'XmppTransmitter'\n  end\n\n  def save_online_statuses\n    rate_contracts.each do |rc|\n      hos = HistoricalOnlineStatus.new\n      hos.source = rc\n      hos.number_online = end_points.for_rate_contract(rc.id).online.count\n      hos.online_load_potential = sum_load_potential(end_points.for_rate_contract(rc.id).online)\n      self.historical_online_statuses << hos\n      hos.save\n    end\n    DeviceType.all.each do |dt|\n      if (number_online = end_points.by_device_type(dt).online.count) > 0\n        hos = HistoricalOnlineStatus.new\n        hos.source = dt\n        hos.number_online = number_online\n        hos.online_load_potential = sum_load_potential(end_points.by_device_type(dt).online)\n        self.historical_online_statuses << hos\n        hos.save\n      end\n    end\n  end\n\n  def save_commissioned_statuses\n    rate_contracts.each do |rc|\n      hos = HistoricalCommissionedStatus.new\n      hos.source = rc\n      hos.number_online = end_points.for_rate_contract(rc.id).commissioned.count\n      hos.commissioned_load_potential = sum_load_potential(end_points.for_rate_contract(rc.id).commissioned)\n      self.historical_commissioned_statuses << hos\n      hos.save\n    end\n    DeviceType.all.each do |dt|\n      if (number_online = end_points.by_device_type(dt).commissioned.count) > 0\n        hos = HistoricalCommissionedStatus.new\n        hos.source = dt\n        hos.number_online = number_online\n        hos.commissioned_load_potential = sum_load_potential(end_points.by_device_type(dt).commissioned)\n        self.historical_commissioned_statuses << hos\n        hos.save\n      end\n    end\n  end\n\n  def sum_load_potential(end_points)\n    end_points.sum(:connected_load_in_kw)\n  end\n\n  def commissioned_by_object(obj)\n    all_comm_status = HistoricalCommissionedStatus.for_object(obj, self)\n    if all_comm_status.first\n      return all_comm_status.first.number_online\n    else\n      return \"No Data\"\n    end\n  end\n\n  def longest_cycle_time\n    longest = 0\n     rate_contracts.each do |rc|\n       longest = rc.cycle_time unless longest > rc.cycle_time\n     end\n     longest\n  end\n\n  def rate_contract_restrictions_are_respected\n    time = start_time\n    violated_contracts = rate_contracts.reject { |rc| rc.allow_control?(time) }\n    if violated_contracts.any?\n      errors.add :base, \"Cannot execute control without overriding rate contract restrictions\"\n    end\n  end\n\n  def check_c_and_i_respond_tos\n    cfg = ::Configuration.instance\n    premises = self.c_and_i_premises\n    if cfg.c_and_i_response_email.blank? && premises.any? { |p| p.contacts.any? { |c| c.notification_types.any? { |nt| nt.name == \"Email\" } } }\n      errors.add :base, \"Must configure the C&I response email in system configuration\"\n    end\n    if cfg.has_configured_system_sms? && has_sms_contacts_within?(premises)\n      errors.add :base, \"Must configure the C&I response SMS in system configuration\"\n    end\n  end\n\n  def has_sms_contacts_within?(premises)\n    premises.any? { |p| p.contacts.any? { |c| c.notification_types.any? { |nt| nt.name == \"SMS\" } } }\n  end\n\n  def check_for_nodes\n    errors.add(:nodes, \"can't be blank\") if self.nodes.blank?\n  end\n\n  def check_for_c_and_i_premises\n    errors.add(:c_and_i_premises, \"can't be blank\") if self.c_and_i_premises.blank?\n  end\n\n  def only_c_and_i_contracts_on_communication_events\n    if self.communication_only? && self.rate_contracts.any? { |rc| rc.is_a?(DirectControlRateContract) }\n      errors.add :base, \"Cannot include direct control rate contracts on communication-only events\"\n    end\n  end\n\n  def setup_c_and_i_data\n    build_control_event_end_points unless template?\n\n    unless self.c_and_i_premises.present?\n      self.c_and_i_premises = fetch_c_and_i_premises\n    end\n\n    if self.c_and_i_premises.present?\n      # force validation because of possible rails bug that doesn't call validation on has_one association\n      self.build_escalation_path(:control_event => self).valid?\n    else\n      true\n    end\n  end\n\n  def far_enough_in_future\n    max = nil\n    rate_contracts_and_control_strategies.each do |rate_contract, control_strategy|\n      next if rate_contract.pre_event_alert_minutes.zero?\n      next unless control_strategy.should_create_pre_event_alert_messages?\n\n      difference = self.start_time - rate_contract.pre_event_alert_minutes.minutes\n      if difference < Time.zone.now\n        max = rate_contract.pre_event_alert_minutes.minutes\n      end\n    end\n    errors.add(:start_time, \"must be at least #{max.from_now.to_s(:time_simple)} to allow for pre-event alert\") if max\n  end\n\n  def array_contents_are_not_equal(a1, a2)\n    (a1.size != a2.size || a1.sort - a2.sort != [])\n  end\n\n  def end_time_within_bounds?\n    return if end_time.blank?\n\n    max = 0\n    rate_contracts_and_control_strategies.each do |rc, cs|\n      if dur = rc.duration(cs)\n        max = dur unless max > dur\n      end\n    end\n\n    if duration < max\n      errors.add(:end_time, \"must allow for entire control sequence to be run. \")\n    end\n\n    #currently repeats is set up to be zero based\n    rate_contracts_and_control_strategies.each do |rc, cs|\n      if rc.repeats(start_time, end_time, cs) > 14\n        errors.add(:base, \"Event exceeds maximum duration for control strategy #{cs.name} on rate contract #{rc.name}.\")\n        break\n      end\n    end\n    return errors.size == 0\n  end\n\n  def post_event_callbacks\n    []\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[1174,36],[1174,36]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":90,"autoscroll":true,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/intellisource/common/app/models/base_control_event.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"ecc7f37c522ccf00576a419551721cd1a10d1feb","deserializer":"TextBuffer"},{"text":"require \"sms-fu/lib/sms_fu\"\nrequire 'factory_girl'\n\nFactoryGirl.define do\n  sequence(:serial_number) { | n | (1_000_000 + n).to_s }\n  sequence(:node_name) { |n| \"Node #{n}\" }\n  sequence(:position) { |n| n }\n\n  factory :firmware_type do\n    name \"CM\"\n    description \"Communications Module\"\n  end\n\n  factory :firmware_history do\n    updated true\n    version_number \"0x60\"\n    firmware_type { |fwh| FirmwareType.first || fwh.association(:firmware_type) }\n  end\n\n  factory :sub_region do\n    sequence(:name) {|n| \"Sub-Region ##{n}\"}\n    region {|r| Region.first || r.association(:region)}\n  end\n\n  factory :region do\n    sequence(:name) { |n| \"Region ##{n}\" }\n    companies { |c| [Company.first || c.association(:company)] }\n    shape_coords([\n                   { :lat => 32.9723, :lng => -96.6152 },\n                   { :lat => 32.8016, :lng => -95.9615 },\n                   { :lat => 32.0924, :lng => -96.6647 }\n                 ])\n  end\n\n  factory :sub_region_with_new_region, parent: :sub_region do\n    association(:region)\n  end\n\n  factory :addressing_history do\n    fail_count {[*0..10].sample}\n    success_count {[*11..100].sample}\n    sequence(:for_date) { |n| Date.new(Date.current.year, Date.current.month, 1) + n }\n  end\n\n  factory :id_verification do\n    account_or_prospect_id { Account.first }\n    account_or_prospect_type \"Account\"\n    name \"ssn_last_four\"\n    value \"6789\"\n    sequence(:ord) { |n| n }\n  end\n\n  factory :industry do\n    sequence(:name) { |n| \"Industry ##{n}\" }\n    sequence(:sic) { |n| n }\n  end\n\n  factory :industry_csp do\n    association(:industry)\n    association(:curtailment_service_provider)\n  end\n\n  factory :node_csp do\n    association(:node)\n    association(:curtailment_service_provider)\n  end\n\n  factory :energy_supplier do\n    sequence(:name) { |n| \"Municipality ##{n}\" }\n  end\n\n  factory :company do\n    sequence(:name) { |n| \"Company ##{n}\" }\n  end\n\n  factory :warehouse do\n    sequence(:name) { |n| \"Warehouse ##{n}\" }\n    company { |c| Company.first || c.association(:company) }\n  end\n\n  factory :capacity do\n    region { |c| Region.first || c.association(:region) }\n    company { |c| Company.first || c.association(:company) }\n    scheduled_timerange { |a| ScheduledTimerange.first || a.association(:scheduled_timerange) }\n    day { Time.zone.today }\n    max_capacity 30\n  end\n\n  factory :capacity_payment do\n    association(:node)\n    dollars_per_mw_day 10.00\n    year Time.zone.now.year\n  end\n\n  factory :ticket_problem_type do\n    sequence(:name) {|n| \"Problem Type ##{n}\"}\n    association(:assignment_group)\n  end\n\n  factory :assignment_group do\n    sequence(:name) {|n| \"Assignment Group ##{n}\"}\n  end\n\n  factory :assignment_group_email do\n    sequence(:name) {|n| \"A Person ##{n}\"}\n    sequence(:email) {|n| \"a_person_#{n}@example.com\"}\n    association(:assignment_group)\n  end\n\n  factory :cause_code do\n    sequence(:name) {|n| \"Cause Code ##{n}\"}\n  end\n\n  factory :resolution_code do\n    sequence(:name) {|n| \"Resolution Code ##{n}\"}\n  end\n\n  factory :ticket do\n    association(:premise)\n    association(:contact_source)\n    association(:ticket_problem_type)\n    association(:cause_code)\n    association(:resolution_code)\n    association(:assignment_group)\n    description \"Things happened and it was bad\"\n    comments \"Do you think the things were really that bad?\"\n    status \"In-Progress\"\n    priority \"Low\"\n    contact_datetime { Time.zone.now }\n    after(:build) do |ticket|\n      ticket.account_or_prospect ||= ticket.premise.try(:account)\n    end\n  end\n\n  factory :quality_assurance_batch do\n    sequence(:batch_number) { |n| n.to_s }\n    sequence(:id)\n    created_by { |a| a.association(:user) }\n  end\n\n  factory :quality_assurance_installation do\n    association(:quality_assurance_batch)\n    field_service_request { FactoryGirl.create(:field_service_request, :field_service_request_type => \"Install\" ) }\n  end\n\n  factory :field_service_request, aliases: [:assigned_field_service_request] do\n    association(:premise, :address_line_two => \"Apt 2\")\n    scheduled_date { Time.zone.today }\n    scheduled_timerange { |a| ScheduledTimerange.first || a.association(:scheduled_timerange) }\n    assigned_users { |f| [f.association(:installer_user, :hourly_rate => 42.95)] }\n    created_by { |f| f.association(:user) }\n    landlord_auth_status \"Received\"\n    field_service_request_type \"Install\"\n    status { FieldServiceRequest::INSTALLER_ASSIGNED }\n    reference_number { \"XYZ4321\" }\n    after(:build) do |f|\n      if f.cancelled?\n        f.cancellation_reason = CancellationReason.first || FactoryGirl.build(:cancellation_reason)\n      end\n      if f.turn_down? && f.turn_down_reason.blank?\n        f.turn_down_reason = TurnDownReason.first || FactoryGirl.build(:turn_down_reason)\n      end\n      if f.account.blank? && f.premise.present?\n        f.account = f.premise.account\n      end\n    end\n  end\n\n  factory :soap_transaction do\n    association(:field_service_request)\n    inventory_type { |a| DeviceType.first || a.association(:device_type) }\n    sequence(:transaction_number) { |i| \"0000000#{i}\" }\n    device_count 1\n  end\n\n  factory :bare_visit_detail, :class => \"VisitDetail\" do\n    association(:field_service_request)\n    visit_date { Time.zone.today }\n    visit_status \"In Progress\"\n    comments \"A wonderful comment about the progress of the Visit Detail\"\n    driving_time_start { Time.zone.now.midnight + 1.hours }\n    driving_time_stop { Time.zone.now.midnight + 2.hours }\n    working_time_start { Time.zone.now.midnight + 3.hours }\n    working_time_stop { Time.zone.now.midnight + 4.hours }\n    technician { field_service_request.assigned_users.first }\n  end\n\n  factory :visit_detail, :parent => :bare_visit_detail do\n    after(:build) do |v|\n      v.technician = v.field_service_request.assigned_users.first if v.technician.blank?\n      if v.requires_device_details?\n        v.device_details << FactoryGirl.build(:device_detail, :visit_detail => v)\n      end\n    end\n  end\n\n  factory :device_detail do\n    association(:visit_detail, factory: :bare_visit_detail)\n    installation_datetime { Time.zone.now }\n    device_detail_type \"Installation\"\n    association(:device_location)\n    comments \"Comment about our Device Detail\"\n    inventory { FactoryGirl.create(:device).inventory }\n    end_point_1 true\n    rate_contract_id { |device_detail|\n      if Setting['megawatt_variability'].enabled?\n        RateContract.first.id || device_detail.association(:rate_contract)\n      else\n        nil\n      end\n    }\n  end\n\n  factory :sp_device_detail, :parent => :device_detail do\n    inventory { FactoryGirl.create(:service_point).inventory }\n    end_point_1 nil\n    end_point_2 nil\n    end_point_3 nil\n    end_point_4 nil\n  end\n\n  factory :third_party_device_type do\n    sequence(:name) { |i| \"Device Type #{i}\" }\n  end\n\n  factory :comment do\n    association(:field_service_request)\n    association(:outgoing_call_resolution)\n    comment \"A comment for a comment!\"\n    after(:build) { |comment| comment.created_by = comment.field_service_request.assigned_users.first }\n  end\n\n  factory :outgoing_call, :parent => :comment do\n  end\n\n  factory :ticket_comment do\n    association(:ticket)\n    comment \"Here's a comment!\"\n    created_by { |a| a.association(:user) }\n  end\n\n  factory :common_comment do\n    sequence(:name) { |i| \"Comment # #{i}\" }\n  end\n\n  factory :material_cost do\n    sequence(:name) { |i| \"Material # #{i}\" }\n    cost 5.75\n  end\n\n  factory :material_cost_detail do\n    association(:visit_detail)\n    association(:material_cost)\n    quantity 5\n    after(:build) {|i| i.cost_per_material = i.material_cost.cost }\n  end\n\n  factory :scheduled_timerange do\n    time_type { ScheduledTimerange::VALID_TIME_TYPES.shuffle[0] }\n    start_time { Time.zone.now }\n    stop_time { Time.zone.now + 1.hour }\n  end\n\n  factory :broadband_provider do\n    sequence(:name) { |i| \"Broadband Provider # #{i}\" }\n  end\n\n  factory :equipment_type do\n    sequence(:name) { |i| \"Equipment # #{i}\" }\n    rating_uom \"Tons\"\n    ttm_type \"hvac\"\n  end\n\n  factory :equipment_location do\n    sequence(:name) { |i| \"Location # #{i}\" }\n  end\n\n  factory :equipment_make do\n    sequence(:name) { |i| \"Company #{i}\" }\n  end\n\n  factory :device_location do\n    sequence(:name) { |i| \"Location # #{i}\" }\n  end\n\n  factory :turn_down_reason do\n    sequence(:name) { |i| \"Turn Down Reason # #{i}\" }\n  end\n\n  factory :cancellation_reason do\n    sequence(:name) { |i| \"Cancellation Reason # #{i}\" }\n  end\n\n  factory :outgoing_call_resolution do\n    sequence(:name) { |i| \"Call Resolution ##{i}\" }\n  end\n\n  factory :promo_code do\n    sequence(:name) { |i| \"PROMOCODE#{i}\" }\n    description \"A Promo Code\"\n    rep_codes { |obj| [obj.association(:rep_code)] }\n    incentive_types { |obj| [obj.association(:incentive_type)] }\n  end\n\n  factory :rep_code do\n    sequence(:name) { |i| \"REPCODE#{i}\" }\n    description \"A Rep Code\"\n  end\n\n  factory :incentive_type do\n    sequence(:name) { |i| \"INCENTIVETYPE#{i}\" }\n    description \"An Incentive Type\"\n  end\n\n  factory :contact_log_call_reason do\n    sequence(:name) { |n| \"Reason #{n}\"}\n  end\n\n  factory :contact_source do\n    sequence(:name) { |n| \"Contact Source ##{n}\"}\n  end\n\n  factory :utility_meter do\n    association(:premise)\n    association(:meter_type)\n    sequence(:meter_number) { |i| \"12345678#{i}\" }\n    sequence(:meter_sequence) { |i| i }\n  end\n\n  factory :itron_utility_meter, parent: :utility_meter do\n    association(:premise)\n    meter_type { |um| MeterType.itron || um.association(:itron_meter_type) }\n  end\n\n  factory :elster_utility_meter, parent: :utility_meter do\n    association(:premise)\n    meter_type { |um| MeterType.elster || um.association(:elster_meter_type) }\n  end\n\n  factory :meter_type do\n    sequence(:name) { |i| \"Meter Type #{i}\" }\n  end\n\n  factory :device_detail_requirement do\n    # Nothing is required\n  end\n\n  factory :field_service_request_configuration do\n    athena_version_number FieldServiceRequestConfiguration::REQUIRED_ATHENA_VERSION\n  end\n\n  factory :prospect_import_configuration do\n    import_delimiter '~'\n  end\n\n  factory :accounts_and_prospects_configuration do\n  end\n\n  factory :equipment do\n    equipment_type { |e| EquipmentType.first || e.association(:equipment_type) }\n    association(:premise)\n    equipment_location { |e| EquipmentLocation.first || e.association(:equipment_location) }\n    device_type { |e| DeviceType.first || e.association(:device_type) }\n  end\n\n  factory :purchase_order do\n    po_date { Time.zone.today }\n    sequence(:po_number) { |i| i }\n    association(:warehouse)\n  end\n\n  factory :purchase_order_line_item do\n    association(:purchase_order)\n    quantity_requested 1\n    estimated_shipment_date { 5.days.from_now }\n    inventory_equipment_type { |it| it.association(:inventory_equipment_type)}\n\n    trait :fulfilled do\n      inventories {|li| FactoryGirl.build_list :inventory, li.quantity_requested, inventory_equipment_type: li.inventory_equipment_type }\n    end\n\n    trait :pending do\n    end\n\n    trait :partial_receipt do\n      quantity_requested 2\n      inventories {|li| FactoryGirl.build_list :inventory, li.quantity_requested/2, inventory_equipment_type: li.inventory_equipment_type }\n    end\n  end\n\n  factory :inventory do\n    state 'in_inventory'\n    association :inventory_equipment_type\n    inventory_type {|it| it.inventory.class.name }\n\n    after(:build) do |it|\n      next if it.inventory.present?\n\n      it.inventory = FactoryGirl.build :device, device_type: it.inventory_equipment_type.inventory_equipment_type, inventory: it\n    end\n  end\n\n  factory :inventory_equipment_type do\n    name 'Superstat Zigbee'\n    inventory_equipment_type { |iet| DeviceType.find_by_name(\"Zigbee SuperStat\") || FactoryGirl.create(:device_type, :name => \"Zigbee SuperStat\") }\n  end\n\n  factory :return_merchandise_authorization do\n    sequence(:rma_number) { |i| i }\n    rma_date { Time.zone.today }\n  end\n\n  factory :return_merchandise_authorization_line_item do\n    association(:return_merchandise_authorization)\n    return_status \"open\"\n    inventory { FactoryGirl.create(:device).inventory }\n  end\n\n  factory :billing_cycle_date do\n    start_date Time.zone.today-1.month\n    bill_date Time.zone.today\n  end\n\n  factory :clean_billing_cycle, :class => \"BillingCycle\" do\n    sequence(:cycle_id)\n  end\n\n  factory :billing_cycle do\n    sequence(:cycle_id) { |n| n }\n    after(:build) do | billing_cycle |\n      1.upto(12) do | month |\n        year = Time.zone.now.year\n        year += 1 if Time.zone.now.month == 12\n        raw_date = \"#{year}-#{\"%02d\" % month }-#{\"%02d\" % ((billing_cycle.cycle_id % 27) + 1)}\"\n        bill_date = Time.zone.parse(raw_date)\n        start_date = bill_date - 1.month\n        billing_cycle.billing_cycle_dates <<\n          FactoryGirl.build(:billing_cycle_date,\n                            :start_date => start_date,\n                            :bill_date => Time.zone.parse(raw_date))\n      end\n    end\n  end\n\n  factory :billing_cycle_with_historical_dates, :class => \"BillingCycle\" do\n    sequence(:cycle_id)\n    after :build do |billing_cycle|\n      today = Time.zone.today\n      first_bill_date = Time.zone.parse(\"#{today.year}-#{today.month}-#{billing_cycle.cycle_id}\").to_date\n      first_bill_date -= 1.month if first_bill_date > today\n      13.times do |i|\n        bill_date = first_bill_date - i.months\n        start_date = bill_date - 1.month\n        billing_cycle.billing_cycle_dates << FactoryGirl.build(:billing_cycle_date, :bill_date => bill_date, :start_date => start_date)\n      end\n    end\n  end\n\n  factory :user do\n    transient do\n      password \"P@ssw0rd\"\n      password_confirmation \"P@ssw0rd\"\n    end\n\n    sequence(:login) { |n| \"quire#{n}\" }\n    sequence(:email) { |n| \"quire#{n}@example.com\" }\n    first_name 'Sally'\n    last_name 'Quire'\n    telephone '800-555-1212'\n    mobile '723-412-5123'\n    mobile_carrier_name 'at&t'\n    association(:address)\n    roles { |r| [Role.find_by_name('system_administrator') || r.association(:role)] }\n    company { |c| Company.first || c.association(:company) }\n\n    after(:create) do |u, evaluator|\n      u.password_expired_at = u.api? ? nil : 3.months.from_now\n      u.password = evaluator.password\n      u.password_confirmation = evaluator.password_confirmation\n      u.save\n    end\n  end\n\n  factory :quentin_user , :parent => :user do\n    transient do\n      password \"monkey\"\n      password_confirmation \"monkey\"\n    end\n\n    login \"quentin\"\n    email \"quentin@example.com\"\n    first_name 'Quentin'\n    last_name 'Sparks'\n    telephone '800-555-1212'\n\n    roles { |r| [Role.find_by_name('installer') || r.association(:role)] }\n    association :company\n\n    remember_created_at 1.day.from_now\n    remember_token '77de68daecd823babbb58edb1c8e14d7106e83bb'\n\n    after(:create) do |u, evaluator|\n      u.password_expired_at = 1.year.from_now\n      u.password = evaluator.password\n      u.password_confirmation = evaluator.password_confirmation\n      u.save\n    end\n  end\n\n  [:system_administrator,\n   :program_administrator,\n   :program_analyst,\n   :field_office_staff,\n   :customer_service,\n   :control_operator,\n   :sales_engineer,\n   :marketing,\n   :energy_engineer,\n   :accounting,\n   :soap_api,\n   :enrollment_approver,\n   :third_party_company_operator,\n   :dispute_resolver,\n   :api,\n   :automated_uploader,\n   :csp\n  ].each do |role|\n    factory :\"#{role}_user\", aliases: [role], parent: :user do\n      sequence(:login) { |n| \"#{role}#{n}\" }\n      association(:curtailment_service_provider) if role == :csp\n      association(:company) if role == :third_party_company_operator\n      roles { |r| [Role.find_by_name(role) || FactoryGirl.create(:role, :name => role.to_s)] }\n    end\n  end\n\n  # These guys need a region.\n  [:installer,\n   :third_party_company_installer\n  ].each do |role|\n    factory :\"#{role}_user\", aliases: [role], parent: :user do\n      roles { |r| [Role.find_by_name(role) || FactoryGirl.create(:role, :name => role.to_s)] }\n      region { |u| u.association(:region, companies: [u.company]) }\n    end\n  end\n\n  factory :opt_out do\n    opt_out_date Date.today\n    association :device\n    association :account\n  end\n\n  factory :role do\n    name 'system_administrator'\n  end\n\n  factory :portal_user do\n    sequence(:login) { | n | \"test#{n}\" }\n    first_name \"Some\"\n    last_name \"User\"\n    password 'P@ssw0rd'\n    password_confirmation { |a| a.password }\n    email { |a| \"#{a.login}@example.com\" }\n\n    email_alerts_opt_in false\n    electric_rate 7\n    password_change_required false\n    staff false\n    residential true\n    total_monthly_electric_bill_amount 15000\n    total_monthly_kwh_usage 1250\n    climate_zone 1\n    total_monthly_gas_bill_amount 8000\n    time_zone \"Central Time (US & Canada)\"\n    installation_mode false\n    gas_average_monthly_billing_day 1\n    total_monthly_mcf_usage 727\n    gas_rate 9\n    bill_date 15\n    updated_at Time.now\n    created_at 2.weeks.ago\n\n    association :location\n  end\n\n  factory :portal_user_premise do\n    association(:portal_user)\n    association(:premise)\n  end\n\n  factory :thermostat_profile do\n    name \"Energy Star Cool\"\n    mode \"cool\"\n    temporary false\n    shared_profile false\n    updated_at Time.now\n    created_at 2.weeks.ago\n    association :portal_user\n    association :thermostat_setting\n  end\n\n  factory :thermostat_profile_setting do\n    morning_set_point { rand(45) + 45 }\n    morning_start_time \"Sat Jan 01 05:00:00 UTC 2000\"\n    day_set_point { rand(45) + 45 }\n    day_start_time \"Sat Jan 01 08:00:00 UTC 2000\"\n    evening_set_point { rand(45) + 45 }\n    evening_start_time \"Sat Jan 01 16:00:00 UTC 2000\"\n    night_set_point { rand(45) + 45 }\n    night_start_time \"Sat Jan 01 21:00:00 UTC 2000\"\n    period_of_week \"weekday\"\n    updated_at Time.now\n    created_at 2.weeks.ago\n\n    association :thermostat_profile\n  end\n\n  factory :device do\n    serial_number { FactoryGirl.generate(:serial_number) }\n    device_type { | a | DeviceType.find_by_name('SuperStat') || a.association(:device_type) }\n    rate_address { | a | (RateAddress.where(:extended => true, :deactivated => [false,nil]).first || a.association(:rate_address)) }\n    service_point { | a |\n      if a.rate_address && a.rate_address.rate_contracts.any?(&:tou?)\n        a.association(:service_point, :tou_capable)\n      else\n        a.association(:service_point)\n      end\n    }\n    transmitter { | a | (Transmitter.real.first ||\n                           a.association( :transmitter)) }\n    commissioned_at { 1.day.ago }\n\n    after(:build) do |dev|\n      # can't guarantee the order that associations are evaluated so check for MV90 before validations run\n      if dev.device_type.try(:name) == DeviceType::MV90_METER\n        dev.rate_address = dev.transmitter = nil\n      end\n    end\n    after(:create) { |dev| dev.reload }\n\n    trait :decommissionable do\n      service_point { |a| a.association(:digi_sep_service_point) }\n    end\n\n    trait :tou_capable do\n      service_point { |a| a.association(:service_point, :tou_capable) }\n    end\n  end\n\n  factory :device_with_account, :parent => :device do\n    after(:create) do |dev|\n      dev.end_points.first.update_attributes(:premise_id => FactoryGirl.create(:premise).id)\n    end\n  end\n\n  factory :device_with_attached_equipment, :parent => :device do\n    after(:create) do |device|\n      premise = FactoryGirl.create(:premise)\n      device.end_points.first.update_attributes(:premise_id   => premise.id,\n                                                :equipment_id => FactoryGirl.create(:equipment).id)\n      device.inventory.update_attributes(:location_id => premise.id,\n                                         :location_type => \"Premise\")\n    end\n  end\n\n  factory :ssn_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name('SilverSpring ESI Switch') || a.association(:ssn_device_type) }\n  end\n\n  factory :ihd_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name('Power Portal In-Home Display') || a.association(:ihd_device_type) }\n  end\n\n  factory :smartenergy_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name('Zigbee Superstat') || a.association(:sep_device_type) }\n  end\n\n  factory :intellitemp_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::INTELLITEMP) || a.association(:intellitemp_device_type) }\n  end\n\n  factory :it800_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::IT800) || a.association(:it800_device_type) }\n    service_point { | a | ServicePoint.by_type(ServicePointType::XMPP).first || a.association(:xmpp_service_point) }\n  end\n\n  factory :dcu3_cellular_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::DCU3_CELL) || a.association(:dcu3_cellular_device_type) }\n    service_point { | a | ServicePoint.by_type(ServicePointType::CELL).first || a.association(:xmpp_service_point) }\n  end\n\n  factory :pro1_855ia_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::PRO1_855IA) || a.association(:pro1_855ia_device_type) }\n    service_point { | a | ServicePoint.by_type(ServicePointType::XMPP).first || a.association(:xmpp_service_point) }\n  end\n\n  factory :pro1_855ib_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::PRO1_855IB) || a.association(:pro1_855ib_device_type) }\n    service_point { | a | ServicePoint.by_type(ServicePointType::XMPP).first || a.association(:xmpp_service_point) }\n  end\n\n  factory :pro1_701i_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::PRO1_701I) || a.association(:pro1_701i_device_type) }\n    service_point { | a | ServicePoint.by_type(ServicePointType::XMPP).first || a.association(:xmpp_service_point) }\n  end\n\n  factory :thermometer_device, :parent => :device do\n    device_type { |a| DeviceType.where(:name => \"Zigbee Thermometer\").first || a.association(:zigbee_thermometer_device_type) }\n    rate_address nil\n  end\n\n  factory :dcu_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name('DCU') || a.association(:dcu_device_type) }\n    rate_address do |a|\n      RateAddress.where(\n        \"end_point_1_contract_id IS NOT NULL AND end_point_2_contract_id IS NOT NULL AND extended = ?\", false\n      ).first || a.association(:dcu_rate_address)\n    end\n  end\n\n  factory :silverspring_switch_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name('SilverSpring ESI Switch') || a.association(:silverspring_switch_device_type) }\n    rate_address do |a|\n      RateAddress.where(\n        \"end_point_1_contract_id IS NOT NULL AND end_point_2_contract_id IS NOT NULL AND extended = ?\", true\n      ).first || a.association(:silverspring_rate_address)\n    end\n  end\n\n  factory :cannon_dcu_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::CANNON_DCU) || a.association(:cannon_dcu_device_type) }\n    rate_address { nil }\n  end\n\n  # ILCR\n  factory :intellipeak_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name('IntelliPEAK') || a.association(:intellipeak_device_type) }\n    rate_address do |a|\n      RateAddress.where(\"end_point_1_contract_id IS NOT NULL AND end_point_2_contract_id IS NOT NULL AND extended = ?\",true).first ||\n      a.association(:intellipeak_rate_address)\n    end\n  end\n\n  factory :intellipeak_tou_device, :parent => :intellipeak_device do\n    rate_address { |a| a.association(:intellipeak_tou_rate_address) }\n  end\n\n  factory :intellipeak_directlink_device, :parent => :intellipeak_device do\n    device_type { |a| DeviceType.find_by_name(DeviceType::DCU3) || a.association(:intellipeak_directlink_device_type) }\n  end\n\n  factory :super_stat_basic_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::SUPER_STAT) || a.association(:super_stat_basic_device_type) }\n  end\n\n  factory :pro_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::SUPER_STAT_PRO) || a.association(:pro_device_type) }\n  end\n\n  factory :zigbee_super_stat_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::ZIGBEE_SUPER_STAT) || a.association(:zigbee_super_stat_device_type) }\n  end\n\n  factory :zigbee_dcu_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::ZIGBEE_DCU) || a.association(:zigbee_dcu_device_type) }\n  end\n\n  factory :rtc_dcu_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::RTC_DCU) || a.association(:rtc_dcu_device_type) }\n    transmitter { |a| RtcTransmitter.first || a.association(:rtc_transmitter) }\n    service_point { |a| a.association(:rtc_dcu_service_point) }\n    rate_address do |a|\n      RateAddress.where(\"end_point_1_contract_id IS NOT NULL AND end_point_2_contract_id IS NOT NULL AND extended = ?\", false).first ||\n      a.association(:rtc_dcu_rate_address)\n    end\n  end\n\n  factory :comfort_choice_device, :parent => :device do\n    device_type { | a | DeviceType.find_by_name(DeviceType::COMFORT_CHOICE) || a.association(:comfort_choice_device_type) }\n    service_point { |a| a.association(:digi_sep_service_point) }\n  end\n\n  factory :c_and_i_device, :class => \"Device\" do\n    serial_number { FactoryGirl.generate(:serial_number) }\n    device_type { | a | DeviceType.find_by_name(DeviceType::MV90_METER) || a.association(:device_type, :name => DeviceType::MV90_METER) }\n    association(:service_point)\n    load_potential 500\n\n    after(:create) do |device|\n      device.become_enrolled!\n    end\n  end\n\n  factory :c_and_i_device_with_commitments, :parent => :c_and_i_device do\n    after(:create) do |device|\n    device.indirect_control_rate_contracts << FactoryGirl.create(:indirect_control_rate_contract)\n      device.rate_contract_committables.first.load_commitments = FactoryGirl.generate_localized_commitments(:load_commitment, true)\n    end\n  end\n\n  factory :c_and_i_premise_with_pjm_economic_contract, :parent => :c_and_i_premise do\n    after(:create) do |premise|\n      premise.indirect_control_rate_contracts << FactoryGirl.create(:pjm_economic_rate_contract)\n    end\n  end\n\n  factory :ert_meter, :parent => :device do |d|\n    device_type { | a | DeviceType.find_by_name(DeviceType::ERT_METER) || a.association(:ert_meter_device_type) }\n    transmitter { | a | DigiTransmitter.first || a.association( :digi_transmitter ) }\n    rate_address nil\n  end\n\n  factory :mv90_meter, :parent => :device do |d|\n    device_type { | a | DeviceType.find_by_name(DeviceType::MV90_METER) || a.association(:mv90_meter_device_type) }\n    rate_address nil\n    service_point nil\n    commissioned_at nil\n  end\n\n  factory :obvius_meter, :parent => :device do |d|\n    device_type { | a | DeviceType.find_by_name(DeviceType::OBVIUS_METER) || a.association(:obvius_meter_device_type) }\n    rate_address nil\n    service_point nil\n    commissioned_at nil\n    interval_in_minutes 15\n  end\n\n  factory :itron_meter, :parent => :device do |d|\n    device_type { | a | DeviceType.find_by_name(DeviceType::ITRON_METER) || a.association(:itron_meter_device_type) }\n    transmitter { | a | DigiTransmitter.first || a.association( :digi_transmitter ) }\n    association(:service_point)\n    rate_address nil\n  end\n\n  factory :ami_meter, :parent => :device do\n    device_type { |a| DeviceType.find_by_name(DeviceType::AMI_METER) || a.association(:ami_meter_device_type) }\n    transmitter nil\n    service_point nil\n    rate_address nil\n    commissioned_at nil\n  end\n\n  factory :virtual_device, :parent => :device do\n    device_type { |a| DeviceType.find_by_name(DeviceType::VIRTUAL_DEVICE) || a.association(:virtual_device_type) }\n    transmitter { |a| VirtualTransmitter.first || a.association(:virtual_transmitter) }\n    rate_address { |a| RateAddress.ptr.first || a.association(:ptr_rate_address) }\n    service_point nil\n    commissioned_at nil\n  end\n\n  factory :rate_address do\n    # I hate this sequence. Some tests hard code address numbers, and then this sequence steps on them, and fails validation.\n    sequence(:address, 80) do |i|\n      first_key = maybe_key = i % 127\n      while RateAddress.where(:id => maybe_key).exists?\n        maybe_key = (maybe_key + 1) % 127\n        raise \"Whoops, no open spot for a new rate_address\" if maybe_key == first_key\n      end\n\n      maybe_key\n    end\n\n    end_point_1_contract {|a| a.association(:direct_control_rate_contract)}\n    name { |ra| \"This cool level #{ra.address}\" }\n    extended true\n  end\n\n  factory :ptr_rate_address, :class => \"RateAddress\", :parent => :rate_address do\n    end_point_1_contract {|a| a.association(:ptr_rate_contract)}\n    name { |ra| \"PTR Rate Address #{ra.address}\" }\n    extended false\n  end\n\n  factory :non_extended_rate_address, :parent => :rate_address do\n    extended false\n  end\n\n  factory :dcu_rate_address, :parent => :non_extended_rate_address do\n    end_point_1_contract {|a| a.association(:direct_control_rate_contract)}\n    end_point_2_contract {|a| a.association(:direct_control_rate_contract)}\n  end\n\n  factory :silverspring_rate_address, :parent => :rate_address do\n    end_point_1_contract {|a| a.association(:direct_control_rate_contract)}\n    end_point_2_contract {|a| a.association(:direct_control_rate_contract)}\n  end\n\n  factory :intellipeak_rate_address, :parent => :rate_address do\n    end_point_1_contract {|a| a.association(:direct_control_rate_contract)}\n    end_point_2_contract {|a| a.association(:direct_control_rate_contract)}\n  end\n\n  factory :intellipeak_tou_rate_address, :parent => :rate_address do\n    end_point_1_contract {|a| a.association(:tou_rate_contract)}\n    end_point_2_contract {|a| a.end_point_1_contract }\n  end\n\n  factory :tou_rate_address, :parent => :rate_address do\n    end_point_1_contract { |rc| rc.association(:tou_rate_contract) }\n  end\n\n  factory :rtc_dcu_rate_address, :parent => :non_extended_rate_address do\n    end_point_1_contract {|a| a.association(:direct_control_rate_contract)}\n    end_point_2_contract {|a| a.association(:direct_control_rate_contract)}\n  end\n\n  factory :tou_device, :parent => :pro_device do\n    rate_address { |ra| ra.association(:tou_rate_address) }\n  end\n\n  factory :outdoor_temperature do\n    association :location\n    current_temperature 75\n  end\n\n  factory :telemetry do\n    indoor_temperature 68\n    heat_runtime_in_minutes_delta 120\n    cool_runtime_in_minutes 480\n    collected_at { Time.now }\n    active_control_status \"auto\"\n    filter_time_remaining_m 94014\n    heat_set_point 70\n    working_set_point 69\n    heat_runtime_in_minutes 0\n    display_temperature 69\n    cool_runtime_in_minutes_delta 120\n    filter_time_remaining_delta_m 0\n    cool_set_point 72\n    real_control_status \"cool\"\n    association :end_point\n  end\n\n  factory :thermometer_telemetry do\n    temperature_in_f { (50 + rand * 50).round(1) }\n    collected_at Time.zone.now\n    association :end_point\n  end\n\n  factory :monthly_meter_telemetry do\n    association :end_point\n    association :billing_cycle_date\n    energy_delivered_in_wh 350_000\n  end\n\n  factory :meter_telemetry do\n    total_energy_delivered { rand(100) }\n    power_delivered        { rand(250) }\n    voltage_delivered      { rand(5) + 115 }\n    current_delivered      { rand(250) }\n    power_factor_delivered { rand(10) + 90 }\n    energy_delta_delivered { rand(5) }\n    collected_at           { Time.zone.now }\n    sequence(:tier_name_id) { |n| (TierName.find_by_table_offset(n%5) || FactoryGirl.create(:tier_name, :table_offset => n%5 )).id }\n    association :end_point\n  end\n\n  factory :meter_telemetry_pricing do\n    association :meter_telemetry\n  end\n\n  factory :ert_meter_telemetry do\n    total_energy           { rand(100) }\n    energy_delta           { rand(5) }\n    collected_at           { Time.zone.now }\n\n    association :end_point\n  end\n\n  factory :control_telemetry do\n    relay_count  0\n    relay_time   0\n    collected_at Time.zone.now\n    association :end_point\n  end\n\n  factory :m_and_v_relay_state_telemetry do\n    collected_at Time.zone.now\n    association  :end_point\n    sequence(:relay_state) {|n| [true, false][n%2] }\n  end\n\n  factory :end_point do\n    connected_load_in_kw 1.0\n    association :device\n    association :premise\n    association :system_size\n    after(:build) do |end_point|\n      end_point.position = end_point.device.end_points.collect(&:position).max.to_i + 1\n    end\n  end\n\n  factory :thermostat_setting do\n    hold_applied_at nil\n    heat_set_point 60\n    cool_set_point 80\n    hold_type nil\n    cooling_energy_source \"electric heat pump\"\n    heating_energy_source \"gas\"\n    age_of_hvac_system 13\n\n    association :device\n\n    # NOTE: This is here to prevent the device creation from\n    # associating to another thermostat setting because device has a\n    # before_create callback that creates a thermostat setting\n    after(:create) { |ts|\n      ts.device.thermostat_setting = ts.reload\n    }\n  end\n\n  factory :hold do\n    set_point 65\n    start_time Time.zone.now\n    stop_time nil\n    hold_type \"temporary\"\n    mode \"cool\"\n    association :thermostat_setting\n  end\n\n  factory :tier_setting do\n    association :tier_name\n    association :thermostat_setting\n    set_point { rand(45) + 45 }\n    enabled { true }\n  end\n\n  factory :tier_setting_history do\n    association :tier_name\n    association :thermostat_setting\n    cool_set_point { rand(45) + 45 }\n    heat_set_point { rand(45) + 45 }\n    enabled true\n    price BigDecimal.new(\"0.00001\")\n  end\n\n  factory :system_size do\n    zone 1\n    tonnage 1\n    min_square_footage 1000\n    max_square_footage 2000\n  end\n\n  factory :vacation_setting do\n    set_point 60\n    mode 'heat'\n    start_at { Time.zone.now }\n    stop_at { 15.minutes.from_now }\n    status 'pending'\n    association :thermostat_setting\n  end\n\n  factory :location do\n    zipcode { I18n.locale == :\"en-ZA\" ? \"2020\" : \"80305\" }\n    city 'Broomfield'\n    state 'CO'\n  end\n\n  factory :local_forecast do\n    current_temperature 70\n    high 78\n    low 66\n    day_of_week \"Today\"\n    condition \"Sunny\"\n    icon \"sunny\"\n    association :location\n  end\n\n  factory :activity do\n    action 'Some Action'\n    association :subject, :factory => :device\n  end\n\n  factory :alert do\n    message 'Hello'\n    read false\n    association :portal_user\n  end\n\n  factory :account do\n    first_name 'Bob'\n    last_name 'Smith'\n    association(:address)\n    email \"bsmith@example.com\"\n    landlord_authorized true\n    association(:participant_type)\n    sequence(:account_number) { |i| \"A%09d\" %[i] }\n    client_customer_id \"9988776655\"\n    enrollment_source { EnrollmentSource.where(name: EnrollmentSource::WEB).first_or_create }\n\n    curtailment_service_provider do |a|\n      if ExtraRequirementSystem.enabled?(:aggregator)\n        CurtailmentServiceProvider.last || a.association(:curtailment_service_provider)\n      else\n        nil\n      end\n    end\n\n    after(:build) do |acct|\n      if acct.account_or_prospect_rate_contracts.blank?\n        acct.account_or_prospect_rate_contracts = [ FactoryGirl.build(:account_or_prospect_rate_contract, :account_or_prospect => acct) ]\n      end\n      if acct.id_verifications.blank?\n        acct.id_verifications << FactoryGirl.build(:id_verification, :account_or_prospect => acct)\n        acct.id_verifications << FactoryGirl.build(:id_verification, :account_or_prospect => acct, :name => \"account_number\", :value => \"123456\")\n        acct.id_verifications << FactoryGirl.build(:id_verification, :account_or_prospect => acct, :name => \"authorized_user\", :value => \"Jean le Duke\")\n      end\n    end\n  end\n\n  factory :prospect do\n    first_name 'Bob'\n    last_name 'Smith'\n    association(:address)\n    email \"bsmith@example.com\"\n    landlord_authorized true\n    association(:participant_type)\n    client_customer_id \"9988776655\"\n    enrollment_source { EnrollmentSource.where(name: EnrollmentSource::WEB).first_or_create }\n\n    curtailment_service_provider do |a|\n      if ExtraRequirementSystem.enabled?(:aggregator)\n        CurtailmentServiceProvider.last || a.association(:curtailment_service_provider)\n      else\n        nil\n      end\n    end\n\n    after(:build) do |prospect|\n      if prospect.account_or_prospect_rate_contracts.blank?\n        prospect.account_or_prospect_rate_contracts = [ FactoryGirl.build(:account_or_prospect_rate_contract, :account_or_prospect => prospect) ]\n      end\n    end\n  end\n\n  factory :c_and_i_prospect, :parent => :prospect do\n    first_name nil\n    last_name nil\n    company_name \"Some Company, LLC\"\n    c_and_i true\n  end\n\n  factory :prospect_to_premise do |ptp|\n    association(:prospect)\n    association(:premise)\n  end\n\n\n  factory :ineligible_zip_code do\n    sequence(:zip_code) { |i| \"%05d\" % i }\n  end\n\n  factory :marketing_source do\n    sequence(:name) { |i| \"Marketing Source ##{i}\" }\n  end\n\n  factory :enrollment_source do\n    sequence(:name) { |i| \"Enrollment Source ##{i}\" }\n  end\n\n  factory :participant_type do\n    sequence(:name) { |i| \"Type ##{i}\"}\n  end\n\n  factory :residential_participant_type, :parent => :participant_type do\n    name \"Residential\"\n    c_and_i false\n  end\n\n  factory :commercial_participant_type, :parent => :participant_type do\n    name \"Commercial\"\n    c_and_i true\n  end\n\n  factory :contact_log do\n    association(:contact_log_call_reason)\n    association(:contact_source)\n    comments \"Here's a comment!\"\n    account_or_prospect { |a| a.association(:prospect) }\n  end\n\n  factory :account_or_prospect_rate_contract do\n    account_or_prospect { |obj| obj.association(:prospect) }\n    rate_contract { |obj| obj.association(:direct_control_rate_contract) }\n    promo_code { |obj| PromoCode.first || obj.association(:promo_code) }\n    after(:build) do |obj|\n      obj.rep_code = obj.promo_code.rep_codes.first if obj.rep_code.nil?\n      obj.incentive_type = obj.promo_code.incentive_types.first if obj.incentive_type.nil?\n    end\n  end\n\n  factory :c_and_i_account, :parent => :account do\n    sequence(:company_name) { |i| \"Gap #{i}\"}\n    participant_type { |a| ParticipantType.find_by_name(\"Commercial\") || FactoryGirl.create(:participant_type, :name => \"Commercial\", :c_and_i => true) }\n    c_and_i true\n  end\n\n  factory :address do\n    line_one \"123 Main St\"\n    line_two \"Suite 20\"\n    city \"Boulder\"\n    state \"CO\"\n    postal_code \"80305\"\n    # address_zip { I18n.locale == :\"en-ZA\" ? \"2020\" : \"80305\" }\n  end\n\n  factory :premise do\n    association(:address)\n    account {|a| Account.first || a.association(:account) }\n    latitude { 39.9 + 0.2*rand }\n    longitude { -105.3 + 0.3*rand }\n    sequence(:premise_id) { | n | \"P%09d\" %[n] }\n    enrolled true\n    association(:sub_region)\n\n    transient do\n      equipment_count 1\n    end\n\n    after(:build) do |premise, evaluator|\n      premise.equipment =\n        FactoryGirl.build_list(:equipment, evaluator.equipment_count, :premise => premise) unless\n          evaluator.__override_names__.include? :equipment\n    end\n  end\n\n  factory :c_and_i_premise, :parent => :premise, :class => \"CAndIPremise\" do\n    sequence(:display_name) { |i| \"Location ##{i+1}\" }\n    sequence(:premise_id) { |i| \"#{1000+i}\"}\n    account { |a| a.association(:c_and_i_account) }\n    status { CAndIPremise.default_status.to_s }\n    association(:node)\n  end\n\n  factory :prospective_premise, :parent => :c_and_i_premise do\n    after(:build) do |premise|\n      unless premise.prospect?\n        premise.become_pending_approval! if ExtraRequirementSystem.enabled?(:aggregator)\n        premise.become_prospect!\n      end\n    end\n  end\n\n  factory :load_provider_premise, :parent => :prospective_premise do\n    after(:create) do |premise|\n      contract = FactoryGirl.create(:indirect_control_rate_contract)\n      device = FactoryGirl.create(:c_and_i_device, :indirect_control_rate_contracts => [contract])\n      premise.end_points = (device.end_points)\n      premise.devices(true)\n      premise.contacts << FactoryGirl.create(:contact, :contactable => premise)\n      premise.utility_meters << FactoryGirl.build(:utility_meter, :device => device, :meter_number => device.serial_number, :premise => premise)\n      unless ExtraRequirementSystem.enabled?(:aggregator)\n        FactoryGirl.create(:dr_measure, :c_and_i_premise => premise, :indirect_control_rate_contract => contract)\n        premise.dr_measures(true)\n      end\n      premise.become_load_provider!\n    end\n  end\n\n  factory :simple_load_provider_premise, :parent => :prospective_premise do\n    after(:create) do |premise|\n      # Skip all the other setup and just force to load provider status\n      premise.update_column(:status, 'load_provider')\n    end\n  end\n\n  factory :load_provider_payment_adjustment do\n    amount { BigDecimal.new(\"100.00\") }\n    year { Time.zone.now.year }\n    month { Time.zone.now.month }\n  end\n\n  factory :premise_energy_usage do\n    association(:premise)\n    year { Time.zone.today.year }\n    january 100\n    february 100\n    march 100\n    april 100\n    may 100\n    june 100\n    july 100\n    august 100\n    september 100\n    october 100\n    november 100\n    december 100\n  end\n\n  factory :service_point do\n    sequence(:han_id) { | n | (0x100000 + n).to_s(16) }\n    han_role { ::Configuration.default_han_role || \"coordinator\" }\n    service_point_type { | a | ServicePointType.first || a.association(:service_point_type) }\n    commissioned_at { Time.zone.now }\n    last_seen_at { Time.zone.now }\n\n    trait :tou_capable do\n      service_point_type { |a| ServicePointType.find_by(name: \"DigiSEP\") || a.association(:digi_sep_service_point_type) }\n    end\n  end\n\n  factory :digi_service_point, :parent => :service_point do\n    service_point_type { |a| ServicePointType.find_by(name: \"Digi\") || a.association(:service_point_type) }\n  end\n\n  factory :service_point_status_history do\n    sequence(:action_time) { |n| Time.zone.now - n.hours }\n    sequence(:action_type) { |n| n % 2 == 0 ? 'connect' : 'disconnect'}\n    association :service_point, factory: :service_point\n  end\n\n  factory :digi_sep_service_point, :parent => :service_point do\n    service_point_type { |a| ServicePointType.find_by(name: \"DigiSEP\") || a.association(:digi_sep_service_point_type) }\n  end\n\n  factory :xmpp_service_point, :parent => :service_point do\n    service_point_type { |a| ServicePointType.find_by(name: \"XMPP\") || a.association(:xmpp_service_point_type) }\n  end\n\n  factory :rtc_dcu_service_point, :parent => :service_point do\n    service_point_type { |a| ServicePointType.find_by(name: \"RTC\") || a.association(:rtc_dcu_service_point_type) }\n  end\n\n  factory :paging_service_point, :class => \"ServicePoint\" do\n    han_id nil\n    service_point_type { |a| ServicePointType.where(:name => \"Paging\").first || a.association(:paging_service_point_type) }\n    last_seen_at { Time.zone.now }\n  end\n\n  factory :elster_service_point, :class => \"ServicePoint\" do\n    han_id \"123-456-789\"\n    service_point_type { |a| ServicePointType.where(:name => \"Elster\").first || a.association(:elster_service_point_type) }\n    last_seen_at { Time.zone.now }\n  end\n\n  factory :itron_service_point, :class => \"ServicePoint\" do\n    han_id nil\n    service_point_type { |a| ServicePointType.where(:name => \"Itron\").first || a.association(:itron_service_point_type) }\n    last_seen_at { Time.zone.now }\n  end\n\n  factory :m_and_v_paging_service_point, :parent => :paging_service_point, :class => \"ServicePoint\" do\n    m_and_v true\n  end\n\n  factory :paging_service_point_type, :class => \"ServicePointType\" do\n    name \"Paging\"\n  end\n\n  factory :itron_service_point_type, :class => \"ServicePointType\" do\n    name \"Itron\"\n  end\n\n  factory :elster_service_point_type, :class => \"ServicePointType\" do\n    name \"Elster\"\n  end\n\n  factory :rtc_dcu_service_point_type, :class => \"ServicePointType\" do\n    name \"RTC\"\n  end\n\n  factory :service_point_type do\n    name 'Digi'\n  end\n\n  factory :digi_sep_service_point_type, :parent => :service_point_type do\n    name 'DigiSEP'\n  end\n\n  factory :xmpp_service_point_type, :parent => :service_point_type do\n    name 'XMPP'\n  end\n\n  factory :device_type do\n    name 'SuperStat'\n    extended true\n    number_of_end_points 1\n    default_connected_load_in_kw 1.0\n    message_builder 'ThreeZeroFiveMessage'\n  end\n\n  factory :message do\n  end\n\n  factory :sep_device_type, :parent => :device_type do\n    name 'Zigbee Superstat'\n    extended true\n    number_of_end_points 1\n  end\n\n  factory :ihd_device_type, :parent => :device_type do\n    name 'Power Portal In-Home Display'\n    extended true\n    number_of_end_points 1\n    message_builder 'SmartEnergyMessage'\n  end\n\n  factory :intellitemp_device_type, :parent => :device_type do\n    name 'IntelliTemp'\n    message_builder 'F1Message'\n    extended true\n    number_of_end_points 1\n  end\n\n  factory :it800_device_type, :parent => :device_type do\n    name DeviceType::IT800\n    message_builder 'F1Message'\n    extended true\n    number_of_end_points 1\n  end\n\n  factory :dcu3_cellular_device_type, :parent => :device_type do\n    name DeviceType::DCU3_CELL\n    message_builder 'F1Message'\n    extended true\n    number_of_end_points 4\n  end\n\n  factory :pro1_855ia_device_type, :parent => :device_type do\n    name DeviceType::PRO1_855IA\n    message_builder 'F1Message'\n    extended true\n    number_of_end_points 1\n  end\n\n  factory :pro1_855ib_device_type, :parent => :device_type do\n    name DeviceType::PRO1_855IB\n    message_builder 'F1Message'\n    extended true\n    number_of_end_points 1\n  end\n\n  factory :pro1_701i_device_type, :parent => :device_type do\n    name DeviceType::PRO1_701I\n    message_builder 'F1Message'\n    extended true\n    number_of_end_points 1\n  end\n\n  factory :dcu_device_type, :parent => :device_type do\n    name 'DCU'\n    extended false\n    number_of_end_points 4\n  end\n\n  factory :silverspring_switch_device_type, :parent => :device_type do\n    name 'SilverSpring ESI Switch'\n    extended true\n    number_of_end_points 4\n  end\n\n  factory :cannon_dcu_device_type, :parent => :device_type do\n    name DeviceType::CANNON_DCU\n    extended false\n    number_of_end_points 4\n  end\n\n  factory :intellipeak_device_type, :parent => :device_type do\n    name 'IntelliPEAK'\n    extended true\n    number_of_end_points 4\n  end\n\n  factory :intellipeak_directlink_device_type, :parent => :device_type do\n    name 'IntelliPEAK DirectLink'\n    extended true\n    number_of_end_points 2\n  end\n\n  factory :super_stat_basic_device_type, :parent => :device_type do\n    name DeviceType::SUPER_STAT\n  end\n\n  factory :pro_device_type, :parent => :device_type do\n    name DeviceType::SUPER_STAT_PRO\n  end\n\n  factory :zigbee_super_stat_device_type, :parent => :device_type do\n    name DeviceType::ZIGBEE_SUPER_STAT\n  end\n\n  factory :zigbee_dcu_device_type, :parent => :device_type do\n    name DeviceType::ZIGBEE_DCU\n  end\n\n  factory :rtc_dcu_device_type, :parent => :device_type do\n    name DeviceType::RTC_DCU\n    extended false\n    message_builder 'Comverge205Message'\n  end\n\n  factory :comfort_choice_device_type, :parent => :device_type do\n    name DeviceType::COMFORT_CHOICE\n    message_builder 'CarrierMessage'\n    extended true\n    number_of_end_points 1\n  end\n\n  factory :zigbee_thermometer_device_type, :parent => :device_type do\n    name 'Zigbee Thermometer'\n    extended false\n    number_of_end_points 1\n  end\n\n  factory :m_and_v_meter_device_type, :parent => :device_type do\n    name DeviceType::RT_METER\n    extended false\n    number_of_end_points 1\n  end\n\n  factory :ert_meter_device_type, :parent => :device_type do\n    name 'ERT Meter'\n    extended false\n    number_of_end_points 1\n  end\n\n  factory :ssn_device_type, :parent => :device_type do\n    name DeviceType::SSN_SWITCH\n    extended true\n    number_of_end_points 4\n  end\n\n  factory :mv90_meter_device_type, :parent => :device_type do\n    name DeviceType::MV90_METER\n    extended false\n    number_of_end_points 1\n  end\n\n  factory :obvius_meter_device_type, :parent => :device_type do\n    name DeviceType::OBVIUS_METER\n    extended false\n    number_of_end_points 1\n  end\n\n  factory :itron_meter_device_type, :parent => :device_type do\n    name 'Itron Meter'\n    extended false\n    number_of_end_points 1\n  end\n\n  factory :ami_meter_device_type, :parent => :device_type do\n    name DeviceType::AMI_METER\n    extended false\n    number_of_end_points 1\n  end\n\n  factory :virtual_device_type, :parent => :device_type do\n    name DeviceType::VIRTUAL_DEVICE\n    extended false\n    number_of_end_points 1\n  end\n\n  factory :transmitter, :class => \"LogfileTransmitter\" do\n    sequence(:name) { |i| \"My Logfile TX #{i}\"}\n    url 'http://0.0.0.0'\n    data_path '/db/CUS0001_240_Electric_Company'\n    utility 12\n    after(:build) do |tx|\n      tx.listener_url = \"http://#{FactoryGirl.my_ip + FactoryGirl.my_port}/itron_messages/listen\" if tx.type == 'ItronTransmitter'\n    end\n  end\n\n  factory :digi_transmitter, :class => \"DigiTransmitter\", :parent => :transmitter do\n    sequence(:name) { |i| \"My Digi TX #{i}\"}\n    url 'http://0.0.0.0/ws/sci'\n    username 'me'\n    password 'somepass'\n    admin_username 'admin'\n    admin_password 'adm1n'\n  end\n\n  factory :elster_transmitter, :class => \"ElsterTransmitter\", :parent => :transmitter do\n    sequence(:name) { |i| \"My Elster #{i}\"}\n    url 'http://0.0.0.0/MAS'\n    username 'me'\n    password 'somepass'\n  end\n\n  factory :snpp_transmitter, :class => \"SnppTransmitter\", :parent => :transmitter do\n    name 'My SNPP TX'\n    assignment_page_number '5551234'\n    operation_page_number '5551234'\n  end\n\n  factory :rtc_transmitter, :class => \"RtcTransmitter\", :parent => :transmitter do\n    name 'My RTC'\n  end\n\n  factory :xmpp_transmitter, :class => \"XmppTransmitter\", :parent => :transmitter do\n    sequence(:name) { |n| \"My XMPP TX #{n}\" }\n  end\n\n  factory :logfile_transmitter, :class => \"LogfileTransmitter\", :parent => :transmitter do\n    name 'My Logfile TX'\n  end\n\n  factory :virtual_transmitter, :class => \"VirtualTransmitter\" do\n    name 'My Virtual'\n  end\n\n  factory :node do |n|\n    n.name { FactoryGirl.generate(:node_name) }\n    n.devices { |devs| [ devs.association(:device) ] }\n  end\n\n  factory :c_and_i_location do\n    association(:node)\n    after(:create) do |location|\n      location.node.devices << FactoryGirl.create(:c_and_i_device)\n      location.become_load_provider!\n    end\n  end\n\n  factory :area_addressing do\n    topology { |a| FactoryGirl.create_constraint_topology_with_4_levels }\n    area_1 { |a| a.topology.try(:node_by_name, 'Grid') }\n    area_2 { |a| a.topology.try(:node_by_name, 'Feeder') }\n    area_3 { |a| a.topology.try(:node_by_name, 'Circuit') }\n  end\n\n  factory :base_commitment do\n    hour 9\n    load 50\n    month \"January\"\n    day_type \"Weekday\"\n    # Explicitly set this to nil or false to allow bucket expansion\n    suppress_bucket_expansion true\n  end\n\n  factory :commitment_goal do\n    hour 5\n    load 8\n    month \"January\"\n    day_type \"Weekday\"\n    # Explicitly set this to nil or false to allow bucket expansion\n    suppress_bucket_expansion true\n  end\n\n  factory :load_commitment do\n    load 100\n    sequence(:hour) { |n| ((n - 1) % 24) + 1 }\n    sequence(:month) do |n|\n      Date::MONTHNAMES[((n - 1) % 12) + 1]\n    end\n    day_type \"Weekday\"\n    # Explicitly set this to nil or false to allow bucket expansion\n    suppress_bucket_expansion true\n  end\n\n  factory :load_commitment_daily_bid do\n    price 110.50\n    bid_date { Time.zone.today+1.day }\n    bid_reason \"Because\"\n    rate_contract_committable { |a| RateContractCommittable.first || a.association(:rate_contract_committable) }\n  end\n\n  factory :load_commitment_hourly_bid do\n    hour 7\n    load 80\n    load_commitment_daily_bid { |a| LoadCommitmentDailyBid.first || a.association(:load_commitment_daily_bid) }\n    association(:load_commitment)\n  end\n\n  factory :message_control_strategy, :class => \"ControlStrategies::DisplayMessage\" do\n    sequence(:name) { |n| \"Strategy#{n}\" }\n    sequence(:message_text) { |n| \"This is the text for message strategy #{n}\" }\n  end\n\n  factory :control_strategy, :class => \"ControlStrategies::AbruptInAbruptOut\" do\n    sequence(:name) { |n| \"Strategy#{n}\" }\n    cycle_time_in_seconds 1800\n    trough_reduction 100\n    fast_restore false\n    trough_scalable true\n    trough_duration_in_seconds 30.minutes\n    plateau_duration_in_seconds 0\n  end\n\n  factory :ease_in_ease_out_control_strategy, :class => \"ControlStrategies::EaseInEaseOut\" do\n    sequence(:name) { |n| \"Strategy#{n}\" }\n    cycle_time_in_seconds 1800\n    trough_reduction 50\n    fast_restore false\n    trough_scalable true\n    trough_duration_in_seconds 30.minutes\n    plateau_duration_in_seconds 0\n  end\n\n  factory :ease_in_abrupt_out_control_strategy, :class => \"ControlStrategies::EaseInAbruptOut\" do\n    sequence(:name) { |n| \"Strategy#{n}\" }\n    cycle_time_in_seconds 1800\n    trough_reduction 50\n    fast_restore true\n    trough_scalable true\n    trough_duration_in_seconds 30.minutes\n    plateau_duration_in_seconds 0\n  end\n\n  factory :tou_control_strategy, :class => \"ControlStrategies::Tou\"do\n    sequence(:name) { |n| \"TOU Strategy#{n}\" }\n    tier_name { |cs| TierName.first || cs.association(:tier_name) }\n  end\n\n  factory :direct_control_rate_contract do\n    sequence(:name) { |n| \"Default#{n}\" }\n    contract_type \"direct\"\n    after(:build) do |r|\n      r.rate_contract_control_strategies = [ FactoryGirl.build(:rate_contract_control_strategy,\n                                                               :direct_control_rate_contract => r) ]\n    end\n  end\n\n  factory :rate_contract_control_strategy do\n    control_strategy { |a| ControlStrategies::AbruptInAbruptOut.first || a.association(:control_strategy) }\n    association :direct_control_rate_contract\n    default true\n  end\n\n  factory :scheduled_tier do\n    sequence(:tier_name) { |n| TierName.find_by_table_offset(n%3) }\n    sequence(:is_weekday_tier) { |n| (n%2).odd? }\n    start_time_in_minutes { rand(96) * 15 } # use multiples of 15 minutes\n  end\n\n  factory :tou_schedule do\n    weekday_number_of_periods 4\n    weekend_number_of_periods 2\n    sequence(:season) { |n| [\"summer\", \"winter\"][(n - 1) % 2] }\n    sequence( :start_date ) { | n | [ Time.parse(\"March 1\"), Time.parse(\"October 1\") ][ (n - 1) % 2 ] }\n    after(:build) do |tou_sched|\n      last_start_time = 0\n      tou_sched.weekday_number_of_periods.times do\n        period = 6.hours / 15.minutes\n        random_number = Kernel.rand(period)\n        start_time = last_start_time + random_number * 15\n        tou_sched.scheduled_tiers <<\n          FactoryGirl.build(:scheduled_tier, :start_time_in_minutes => start_time, :is_weekday_tier => true)\n        last_start_time += (6.hours / 1.minute)\n      end\n      last_start_time = 0\n      tou_sched.weekend_number_of_periods.times do\n        period = 12.hours / 15.minutes\n        random_number = Kernel.rand(period)\n        start_time = last_start_time + random_number * 15\n        tou_sched.scheduled_tiers <<\n          FactoryGirl.build(:scheduled_tier, :start_time_in_minutes => start_time, :is_weekday_tier => false)\n        last_start_time += (12.hours / 1.minute)\n      end\n    end\n  end\n\n  factory :tou_rate_contract do\n    sequence(:name) { |n| \"TOU#{n}\" }\n    after(:build) do |tou_rc|\n      tous = ControlStrategy.all.select {|cs| cs.tou?}\n      cs = tous.any? ? tous : [FactoryGirl.build(:tou_control_strategy, :tier_name => TierName.first || FactoryGirl.build(:tier_name))]\n      cs.each do |control_strategy|\n        tou_rc.rate_contract_control_strategies << FactoryGirl.build(:rate_contract_control_strategy,\n                                                                 :direct_control_rate_contract => tou_rc,\n                                                                 :control_strategy => control_strategy)\n      end\n\n      2.times {\n        tou_rc.tou_schedules << FactoryGirl.build(:tou_schedule)\n      }\n\n      TierName.all.each do |tn|\n        tou_rc.price_tiers.build(:tier_name => tn, :price => 1.00)\n      end\n    end\n  end\n\n  factory :rate_contract_restriction do\n    sunday true\n    monday true\n    tuesday true\n    wednesday true\n    thursday true\n    friday true\n    saturday true\n    start_time Time.parse('00:00:00')\n    end_time Time.parse('00:00:00')\n    rate_contract { |rc| rc.association(:direct_control_rate_contract)}\n    season { |a| Season.first || a.association(:season) }\n  end\n\n  factory :price_tier do\n    sequence(:tier_name) { |n| TierName.find_by_table_offset(n%5) }\n    association :tou_rate_contract\n    price { rand(100) / 1000 }\n  end\n\n  factory :tier_name do\n    sequence(:name) { |n| [ 'low', 'medium', 'high' ][n] || \"Tier #{n}\" }\n    sequence(:table_offset) { |n| n-1 }\n  end\n\n  factory :contact do\n    first_name \"John\"\n    last_name \"Doe\"\n    email \"john.doe@example.com\"\n    telephone \"3035551212\"\n    mobile \"3035551313\"\n    mobile_carrier \"at&t\"\n    url \"http://www.johndoe.com/\"\n    contactable { |n| n.association(:c_and_i_premise) }\n  end\n\n  factory :account_contact, :parent => :contact do\n    contactable { |n| n.association(:c_and_i_account) }\n  end\n\n  factory :notification_type do\n    name \"SMS\"\n  end\n\n  factory :contact_notification_type do\n    association(:contact)\n    notification_type { |nt| NotificationType.find_by_name(\"SMS\") || nt.association(:notification_type) }\n    sequence(:sequence) { 0 }\n  end\n\n  factory :commitment_configuration do\n  end\n\n  factory :commitment_bucket do\n    association(:commitment_configuration)\n    sequence(:name) { |n| \"Bucket #{n}\" }\n    sequence(:sequence) { |n| n }\n  end\n\n  factory :commitment_buckets_season do\n    association(:season)\n    association(:commitment_bucket)\n    start_hour 8\n  end\n\n  factory :accounting_configuration do\n  end\n\n\n  factory :configuration do\n    map_center_latitude 44.0\n    map_center_longitude -123.0\n    map_zoom_level 8\n    app_domain 'localhost:3000'\n    system_email 'admin@example.com'\n    c_and_i_response_email 'admin@example.com'\n    c_and_i_response_sms '5558159791'\n    c_and_i_response_sms_carrier SMSFu.carriers.keys.first.to_s\n    time_zone 'Central Time (US & Canada)'\n    association :location\n  end\n\n  factory :strategy_document_configuration do\n    utility_name \"Some Utility Company\"\n    utility_abbreviation \"SUC\"\n    utility_logo_file_name \"logo.jpg\"\n    utility_logo_content_type \"image/jpeg\"\n    demand_response_label \"Demand Response\"\n  end\n\n  factory :consumer_engagement_portal_configuration do\n  end\n\n  factory :clean_control_event, :class => \"ControlEvent\" do\n    rate_contracts do |rc|\n      if ExtraRequirementSystem.enabled?(:aggregator)\n        [IndirectControlRateContract.first || rc.association(:indirect_control_rate_contract)]\n      else\n        [DirectControlRateContract.first || rc.association(:direct_control_rate_contract)]\n      end\n    end\n\n    start_time do |c|\n      #Start at noon on the next non-weekend day (for allow_control? validations)\n      start_time = Time.zone.now.end_of_day + 12.hours\n      while [0, 6].include?(start_time.wday)\n        start_time += 1.day\n      end\n      start_time\n    end\n    end_time { |c| 60.minutes.since(c.start_time) }\n    template false\n  end\n\n  factory :control_event, :parent => :clean_control_event do\n    after(:build) do |event|\n      ControlEventBuilder.new(event).build\n    end\n  end\n\n  factory(:dispatched_control_event, :parent => :control_event) do\n    after(:create) do |dispatched|\n      standby = nil\n      Timecop.travel(dispatched.start_time - 2.hours) do\n        standby = FactoryGirl.build(:standby_control_event,\n          :start_time => dispatched.start_time - 1.hour,\n          :end_time => dispatched.end_time + 1.hour,\n          :nodes => dispatched.nodes,\n          :rate_contracts => dispatched.rate_contracts,\n          :override_restrictions => dispatched.override_restrictions\n        )\n        standby.save(:validate => false)\n      end\n      dispatched.update_attribute(:standby_control_event_id, standby.id)\n    end\n  end\n\n  factory :recurring_control_event, :parent => :control_event, :class => \"RecurringControlEvent\"\n\n  factory :control_event_rate_contract do\n    association(:control_event)\n    association(:rate_contract)\n  end\n\n  factory :control_event_with_f1_device, :parent => :control_event do\n    after(:build) do |event|\n      if !node = Node.find_by_name(\"Circuit2\")\n        FactoryGirl.create_constrained_topology\n        node = Node.find_by_name(\"Circuit2\")\n      end\n      event.nodes << node unless event.nodes.include?(node)\n      if node.devices.empty?\n        dev = FactoryGirl.create(:intellitemp_device)\n        node.devices << dev\n        if dev.rate_address\n          dev.rate_address.update_attribute(:end_point_1_contract, event.rate_contracts.first)\n        else\n          dev.rate_address = FactoryGirl.build(:rate_address, :end_point_1_contract => event.rate_contracts.first)\n        end\n        dev.save!\n      end\n    end\n  end\n\n  factory :self_test_control_event_with_f1_device, :class => \"SelfTestControlEvent\", :parent => :control_event_with_f1_device do\n  end\n\n  factory :control_event_with_smartenergy_device, :parent => :control_event do\n    after(:build) do |event|\n      if !node = Node.find_by_name(\"Circuit2\")\n        FactoryGirl.create_constrained_topology\n        node = Node.find_by_name(\"Circuit2\")\n      end\n      event.nodes << node unless event.nodes.include?(node)\n      if node.devices.empty?\n        dev = FactoryGirl.create(:smartenergy_device)\n        node.devices << dev\n        if dev.rate_address\n          dev.rate_address.update_attribute(:end_point_1_contract, event.rate_contracts.first)\n        else\n          dev.rate_address = FactoryGirl.build(:rate_address, :end_point_1_contract => event.rate_contracts.first)\n        end\n        dev.save!\n      end\n    end\n  end\n\n  factory :self_test_control_event, :class => \"SelfTestControlEvent\", :parent => :control_event do\n  end\n\n  factory :clean_self_test_control_event, :class => \"SelfTestControlEvent\", :parent => :clean_control_event do\n  end\n\n  factory :communication_only_control_event, :class => \"CommunicationOnlyControlEvent\", :parent => :control_event do\n  end\n\n  factory :clean_communication_only_control_event, :class => \"CommunicationOnlyControlEvent\", :parent => :clean_control_event do\n  end\n\n  factory :standby_control_event, :class => \"StandbyControlEvent\", :parent => :control_event do\n  end\n\n  factory :clean_standby_control_event, :class => \"StandbyControlEvent\", :parent => :clean_control_event do\n  end\n\n  factory :emergency_control_event, :class => \"EmergencyControlEvent\", :parent => :control_event do\n    rate_contracts { |rc| [IndirectControlRateContract.first || rc.association(:indirect_control_rate_contract)] }\n    end_time { nil }\n  end\n\n  factory :real_time_control_event do\n    start_time { Time.zone.now }\n    end_time { Time.zone.now + 2.hours }\n\n    rate_contracts { [FactoryGirl.create(:pjm_economic_rate_contract)]}\n\n    after(:build) do |event|\n      if event.c_and_i_premises.blank?\n        p = FactoryGirl.create(:c_and_i_premise, :aggregate_commitments => true, :indirect_control_rate_contracts =>  event.rate_contracts)\n        FactoryGirl.create(:mv90_meter).end_point.update_attribute(:premise, p)\n        p.devices(true)\n        event.c_and_i_premises << p\n      end\n\n      FactoryGirl.create(:pjm_acceptance,\n        :control_event => event,\n        :start_time => event.start_time,\n        :end_time => event.end_time\n      )\n    end\n  end\n\n  factory :ptr_control_event, :class => \"PtrControlEvent\", :parent => :control_event do\n  end\n\n\n  factory :pjm_acceptance, :class => \"Pjm::Acceptance\" do\n    start_time { Time.zone.now }\n    end_time { Time.zone.now + 2.hours }\n    sequence :pjm_event_id\n    sequence :elrs_registration_id\n    load_drop_in_kw 1000\n  end\n\n\n  factory :control_event_end_point do\n    association(:control_event)\n    association(:end_point)\n    start_time { Time.zone.now }\n    end_time { Time.zone.now + 2.hours }\n    sequence(:rank)\n  end\n\n  factory :trigger do\n    trigger_datetime { Time.zone.now }\n  end\n\n  factory :trigger_option do\n    sequence(:name) { |i| \"Trigger Option #{i+1}\" }\n    kind \"select\"\n    after(:build) do |option|\n      if option.kind == \"select\" and option.valid_trigger_options.empty?\n        option.valid_trigger_options << FactoryGirl.build(:valid_trigger_option)\n      end\n    end\n  end\n\n  factory :valid_trigger_option do\n    sequence(:value) { |i| \"Valid Trigger Option #{i+1}\" }\n  end\n\n  factory :season do\n    name 'Spring'\n    month_of_year 3\n    day_of_month 21\n  end\n\n  factory :indirect_control_rate_contract do\n    sequence(:name) { |i| \"Rate Contract #{i+1}\" }\n    scheduled_rate 1000.00\n    unscheduled_rate 1200.00\n    baseline_algorithm \"PjmThreeDay\"\n  end\n\n  factory :pjm_economic_rate_contract do\n    sequence(:name) { |i| \"Pjm Economic Rate Contract #{i+1}\" }\n  end\n\n  factory :pjm_capacity_rate_contract do\n    sequence(:name) { |i| \"Pjm Capacity Rate Contract #{i+1}\" }\n  end\n\n  factory :ptr_rate_contract, :parent => :direct_control_rate_contract, :class => \"PtrRateContract\" do\n    ptr_dollars_per_kwh 1.01\n    baseline_algorithm \"PEC\"\n  end\n\n  factory :product_availability do\n    association(:indirect_control_rate_contract)\n    start_hour 10\n    end_hour 16\n    scaling_factor 1.0\n  end\n\n  factory :c_and_i_program do\n    sequence(:name) { |i| \"Program #{i+1}\" }\n    maintenance_rate 100\n  end\n\n  factory :escalation_path do\n    control_event { |ce| FactoryGirl.create_control_event_with_premises_with_contacts }\n  end\n\n  factory :rate_contract_committable do\n    indirect_control_rate_contract { |a| IndirectControlRateContract.first || a.association(:indirect_control_rate_contract)}\n    committable { |a| Device.first || a.association(:device)}\n  end\n\n  factory :firmware do\n    version_number \"1\"\n    device_type { |a| DeviceType.first || a.association(:device_type) }\n    description \"Version 1\"\n    association(:firmware_type)\n    firmware_file_name \"firmware.file\"\n    firmware_content_type \"application/exe\"\n    firmware_file_size 100\n  end\n\n  factory :message_log do\n    transmitter { | t | Transmitter.first || t.association(:transmitter) }\n    sent_time { Time.zone.now }\n  end\n\n  factory :rtm_message do\n    rtm_listener { | rl | RtmListener.first || rl.association(:rtm_listener) }\n  end\n\n  factory :rtm_listener do\n    protocol 'POCSAG'\n    name 'Default Listener'\n    url '127.0.0.1'\n    port '1234'\n    enabled true\n    transmitters { | t | [ SnppTransmitter.first || t.association(:snpp_transmitter) ] }\n  end\n\n  factory :three_zero_five_message do\n    payload { ThreeZeroFiveMessage.led_on(:hours => 1, :utility => 1, :rate => 1) }\n  end\n\n  factory :f1_message do\n    payload { F1Message.led_off({}) }\n  end\n\n  factory :e5_message do\n    payload { E5Message.read_tier_schedule }\n  end\n\n  factory :carrier_message do\n    # FIXME set to blank - not sure what it should be, but probably something\n    payload ''\n  end\n\n  factory :password_history do\n    user { |u| u.association(:user) }\n    encrypted_password { |ph| ph.user.encrypted_password }\n    password_salt { |ps| ps.user.password_salt }\n    created_at Time.zone.now\n  end\n\n  factory :strategy_document do\n    prepared_by \"He-Man\"\n    prepared_by_title \"Master of the Universe\"\n    prepared_by_phone \"(800) 555-1212\"\n    customer_name \"Skeletor\"\n    customer_title \"Evil Guy\"\n    qa_check_by \"She-Ra\"\n    document_date { Time.zone.today }\n    verification_event_hours 2\n    verification_event_degrees 105\n    verification_event_start { Time.zone.today }\n    verification_event_stop  { Time.zone.today + 15.days }\n    association :account\n  end\n\n  factory :command_center_contact do\n    strategy_document_configuration { |sdc| StrategyDocumentConfiguration.first || sdc.association(:strategy_document_configuration) }\n    name \"Command Center\"\n    role \"During an Event\"\n    primary_telephone \"866-278-3125\"\n    secondary_telephone \"866-925-0408\"\n  end\n\n  factory :dr_measure_type do\n    sequence(:name) { |i| \"DR Measure Type ##{i+1}\"}\n  end\n\n  factory :dr_measure do\n    sequence(:measure) { |i| \"Measure ##{i+1}\" }\n    dr_measure_type { |dmt| DrMeasureType.first || dmt.association(:dr_measure_type) }\n    association(:c_and_i_premise)\n    association(:indirect_control_rate_contract)\n  end\n\n  factory :control_record do\n    start_time { Time.zone.now - 1.hour }\n    end_time { Time.zone.now }\n    control_event { |a| ControlEvent.last || a.association(:control_event) }\n    end_point { |a| EndPoint.last || a.association(:end_point) }\n    rate_contract { |a| RateContract.last || a.association(:rate_contract) }\n  end\n\n  factory :standby_control_record, :parent => :control_record do\n    control_event { |a| StandbyControlEvent.last || a.association(:standby_control_event, :start_time => a.start_time, :end_time => a.end_time) }\n  end\n\n  factory :digi_x4_service_point_type, :parent => :service_point_type do\n    name \"DigiX4\"\n  end\n\n  factory :m_and_v_service_point, :class => \"ServicePoint\"do\n    han_id \"43B7F4\"\n    service_point_type { | a | ServicePointType.where( :name => 'DigiX4' ).first || a.association(:digi_x4_service_point_type)}\n    display_name \"DigiX4\"\n    m_and_v true\n    last_seen_at Time.zone.now\n  end\n\n  factory :c_and_i_meter_service_point, :parent => :m_and_v_service_point do\n    han_id { \"\".tap { |a| 6.times { a += \"%x\" % rand(16) } } }\n    m_and_v false\n  end\n\n  factory :m_and_v_end_point, :class => \"EndPoint\"do |x|\n    x.position { FactoryGirl.generate( :position ) } # Random integer ### RAILS3 TODO: Endpoint position isn't a sequence\n    x.premise { |a| Premise.first || a.association(:premise) }\n    x.system_size { |a| SystemSize.first || a.association(:system_size) }\n  end\n\n  factory :zigbee_thermometer_end_point, :parent => :m_and_v_end_point do\n    # device { |a| Device.find_by_serial_number(\"1111111\") || a.association(:m_and_v_thermometer) }\n  end\n\n  factory :m_and_v_meter_end_point, :parent => :m_and_v_end_point do\n    # device { |a| Device.find_by_serial_number(\"3333333\") || a.association(:m_and_v_meter) }\n  end\n\n  factory :m_and_v_dcu_end_point, :parent => :m_and_v_end_point do\n    # device { |a| Device.find_by_serial_number(\"2222222\") || a.association(:m_and_v_dcu) }\n  end\n\n  factory :m_and_v_device, :class => \"Device\"do\n    device_type { |a| DeviceType.where(name: DeviceType::RT_METER).first || a.association(:m_and_v_meter_device_type) }\n    service_point { |a| ServicePoint.where(han_id: \"43B7F4\", m_and_v: true).first || a.association(:m_and_v_service_point)}\n    transmitter { |a| Transmitter.where(name: \"My Digi M&V\").first || a.association(:m_and_v_transmitter) }\n    serial_number { FactoryGirl.generate(:serial_number) }\n  end\n\n  factory :m_and_v_thermometer, :parent => :m_and_v_device do\n    device_type { |a| DeviceType.where(name: \"Zigbee Thermometer\").first || a.association(:zigbee_thermometer_device_type) }\n    serial_number { FactoryGirl.generate(:serial_number) }\n    rate_address nil\n    # x.after(:create) { |d| add_end_points([:zigbee_thermometer_end_point], d) }\n  end\n\n  factory :m_and_v_dcu, :parent => :m_and_v_device do\n    device_type { |a| DeviceType.where(:name => \"DCU\").first || a.association(:dcu_device_type) }\n    rate_address { |a| RateAddress.find_by_name('M&V Rate Address') || a.association(:m_and_v_rate_address) }\n    service_point { |a| a.association(:m_and_v_paging_service_point) }\n    transmitter { |a| Transmitter.where(:name => \"My SNPP TX\").first || a.association(:snpp_transmitter) }\n    serial_number { FactoryGirl.generate(:serial_number) }\n  end\n\n  factory :m_and_v_meter, :parent => :m_and_v_device do\n    device_type { |a| DeviceType.where(:name => DeviceType::RT_METER).first || a.association(:m_and_v_meter_device_type) }\n    serial_number { FactoryGirl.generate(:serial_number) }\n    rate_address nil\n    after(:build) { |x| x.metered_end_points << FactoryGirl.create(:m_and_v_dcu).end_point_at_position(2) if x.metered_end_points.empty? }\n    # after(:create) { |d| add_end_points([:m_and_v_meter_end_point], d) }\n  end\n\n  factory :rt_meter, :parent => :device do\n    device_type { |a| DeviceType.where(:name => DeviceType::RT_METER).first || a.association(:m_and_v_meter_device_type) }\n    serial_number { FactoryGirl.generate(:serial_number) }\n    load_potential 500\n    association :service_point, :factory => :c_and_i_meter_service_point\n    rate_address nil\n  end\n\n  factory :rt_meter_with_commitments, :parent => :rt_meter do\n    indirect_control_rate_contracts {|a| [a.association(:indirect_control_rate_contract)]}\n    after(:create) do |device|\n      device.rate_contract_committables.first.load_commitments = FactoryGirl.generate_standard_commitments(:load_commitment, true)\n    end\n  end\n\n  factory :m_and_v_transmitter, :class => \"DigiTransmitter\"do\n    name \"My Digi M&V\"\n    url \"https://comverge.idigi.com\"\n    username \"denveradmin\"\n    password \"password\"\n    utility 12 # Some random integer\n    last_status \"seen\"\n  end\n\n  factory :m_and_v_rate_address, :parent => :rate_address, :class => \"RateAddress\"do\n    name \"M&V Rate Address\"\n    association :end_point_2_contract, :factory => :m_and_v_end_point_contract\n    extended false\n  end\n\n  factory :m_and_v_end_point_contract, :parent => :direct_control_rate_contract do\n    name \"M&V End Point Contract\"\n    contract_type \"direct\"\n    load_potential 123.4\n  end\n\n  factory :lmp_datum do\n  end\n\n  factory :curtailment_service_provider do\n    sequence(:name) { |n| \"CSP ##{n}\" }\n    sequence(:duns_number) { |n| \"%09d\" % n }\n    bank_name \"Wells Fargo of South Africa\"\n    bank_account_name \"My CSP Account\"\n    bank_account_type \"Checking\"\n    bank_branch_name \"Johannesburg Branch\"\n    bank_branch_code \"123-456\"\n    bank_account_number \"123-456-7890\"\n    vat_number \"4534232432\"\n    vendor_id \"23432342\"\n  end\n\n  factory :growth_of_program_snapshot do\n    date Time.zone.now.to_date\n    association(:industry)\n    association(:node)\n    association(:energy_supplier)\n    rate_contract { |a| a.association(:indirect_control_rate_contract) }\n    report_type \"certified_mw\"\n    tally 200\n  end\n\n  factory :load_provider_payment_summary_snapshot do\n    association :premise\n    month 7\n    year 2012\n    tax_amount 1400.to_d\n    payable_amount 10000.to_d\n  end\n\n  factory :csp_payment_summary_snapshot do\n    association(:curtailment_service_provider)\n    month 7\n    year 2011\n    payable_amount 100000.to_d\n    tax_amount 14000.to_d\n\n    after(:build) do |summary|\n      if summary.csp_contracting_snapshot.blank?\n        summary.csp_contracting_snapshot = FactoryGirl.build(:csp_contracting_snapshot, :csp_payment_summary_snapshot => summary)\n      end\n      if summary.csp_maintenance_snapshot.blank?\n        summary.csp_maintenance_snapshot = FactoryGirl.build(:csp_maintenance_snapshot, :csp_payment_summary_snapshot => summary)\n      end\n    end\n  end\n\n  factory :csp_maintenance_snapshot do\n    association(:csp_payment_summary_snapshot)\n\n    maintenance_payment BigDecimal.new(\"2\")\n\n  end\n\n  factory :csp_contracting_snapshot do\n    association(:csp_payment_summary_snapshot)\n\n    payment BigDecimal.new(\"100000\")\n\n    after(:build) do |snapshot|\n      if snapshot.csp_contracting_snapshot_entries.blank?\n        entry = FactoryGirl.build(:csp_contracting_snapshot_entry, :csp_contracting_snapshot => snapshot)\n        snapshot.csp_contracting_snapshot_entries << entry\n      end\n    end\n  end\n\n  factory :csp_contracting_snapshot_entry do\n    association(:account)\n    association(:premise)\n    device { |a| a.association(:mv90_meter) }\n    rate_contract_committable { |a| RateContractCommittable.first || a.association(:rate_contract_committable) }\n    association(:csp_contracting_snapshot)\n\n    lowest_certified_mw_factor 0.5\n    lowest_certified_mw 20.00\n    contract_months_factor 0.9\n    contract_months 12\n    monthly_performance_factor 0.5\n    unadjusted_performance 0.89\n    product_availability_factor 0.89\n    contract_signup_amount 30000.0\n    payment 120150.0\n  end\n\n  factory :settlement_dispute do\n    disputed_report { |a| a.association(:csp_payment_summary_snapshot) }\n    user { |a| User.first || a.association(:user) }\n    reason \"factoried reason\"\n  end\n\n  factory :settlement_dispute_comment do\n    association(:settlement_dispute)\n    user { |a| User.first || a.association(:user) }\n    comment \"factoried comment\"\n  end\n\n  factory :pjm_registration, :class => \"Pjm::Registration\" do\n    sequence(:elrs_registration_id) { |n| n }\n    sequence(:emkt_location_id) { |n| n }\n    energy_loss_factor 1.04\n    economic_customer_split_percentage 78\n    capacity_customer_split_percentage 77\n    customer_payment_basis \"icap\"\n    pjm_registrations_premises { [Pjm::PremiseRegistration.new(:premise => FactoryGirl.create(:c_and_i_premise))] }\n    after(:create) do |reg|\n      reg.pjm_registrations_premise.update_attribute(:elrs_location_id, 13810)\n    end\n  end\n\n  factory :pjm_economic_offer, :class => Pjm::Economic::Offer do\n    association :registration, :factory => :pjm_registration\n    market_type \"day_ahead\"\n    minimum_run_time_in_mins 60\n    lead_time_in_mins 60\n    cost_to_curtail 100\n    maximum_in_w 1000\n    date (Time.zone.today + 2.days)\n    standing false\n  end\n\n  factory :pjm_economic_standing_offer, :class => Pjm::Economic::Offer,\n    :parent => :pjm_economic_offer do\n    standing true\n  end\n\n  factory :pjm_economic_offer_available_power_per_hour, :class => Pjm::Economic::Offer::AvailablePowerPerHour do\n    sequence(:hour_ending) { |n| n }\n    guaranteed_load_drop_in_mw 1\n  end\n\n  factory :pjm_economic_offer_strike_price, :class => Pjm::Economic::Offer::StrikePrice do\n    price_per_mw 100\n    sequence(:guaranteed_load_drop_in_mw) { |n| 1 * n }\n  end\n\n  factory :pjm_economic_offer_submission, :class => Pjm::Economic::OfferSubmission do\n    association :offer\n    status 'success'\n    after :build do |s|\n      s.offer_date = s.offer.try(:date) if s.offer_date.blank?\n    end\n  end\n\n  sequence :pjm_event_id do |n|\n    n.to_s\n  end\n\n  factory :tip_generator do\n    text \"text\"\n    description \"description\"\n    link_target nil\n    minute_repeat_interval 5\n  end\n\n  factory :tip do\n    priority 0\n    text \"text\"\n    description \"description\"\n    worker_name nil\n    association :tip_generator\n  end\n\n  factory :tip_reminder do\n    priority 0\n    text \"reminder text\"\n    description \"reminder description\"\n    reminder_for { |t| t.association(:tip) }\n    association :tip_generator\n  end\n\n  factory :tip_event do\n    event_type \"before_control_event\"\n    association :portal_user\n    tip_options { { event_id: 1, device_ids: [2], rate_contract_ids: [3] } }\n  end\n\n  factory :pjm_deviation, :class => Pjm::Deviation do\n    deviation_date \"2013-05-20\"\n    east \"9.99\"\n    west \"9.99\"\n    rto \"9.99\"\n  end\n\n  factory :data_import_record do\n    data_import_id { |data| data.association(:data_import) }\n    success true\n    line_number { rand(50) }\n  end\n\n  FACTORY_IMPORT_TYPES = [\"AddendumProspectImport\", \"ArcLogisticsImport\", \"BisAccountImport\",\n                          \"BisImport\", \"BisInventoryImport\", \"DeviceDetailImport\",\n                          \"FieldServiceRequestImport\", \"InventoryImport\",\n                          \"RateContractImport\", \"UniverseProspectImport\", \"VisitDetailImport\"]\n\n  factory :data_import do\n    sequence(:filename) { |n| \"#{Time.zone.now.strftime('%Y%m%d%H%M%S')}--COMVERGE_IMPORT-#{Kernel.rand(3500).to_i}-#{Kernel.rand(3500).to_i}.csv\" }\n    sequence(:failure_reason_code) do |n|\n      case n % 10\n        when 0..5\n          nil\n        when 6\n          \"No such file or directory - /var/www/apps/smartgrid/releases/20121018225929/apollo/import_files/unprocessed/arc_logistics/#{filename}\"\n        when 7\n          \"Illegal quoting in line 3.\"\n        when 8\n          \"undefined method `downcase' for nil:NilClass\"\n        when 9\n          \"Missing or stray quote in line 1\"\n        else\n          nil\n      end\n    end\n    sequence(:type) do |n|\n      FACTORY_IMPORT_TYPES[n % FACTORY_IMPORT_TYPES.length]\n    end\n    sequence(:state) do |n|\n      case n % 5\n      when 0..1 then 'successful'\n      when 2    then 'unprocessed'\n      when 3    then 'unsuccessful'\n      when 4    then 'pending'\n      end\n    end\n    sequence(:expected_total) { |n| 4000 + n }\n    purchase_order_line_item_id { |data_import| data_import.association(:purchase_order_line_item) }\n    parent_id nil\n\n    after(:create) do |data_import|\n      if data_import.state != \"pending\"\n        FactoryGirl.create(:data_import_record, :data_import_id => data_import.id)\n      end\n      data_import.reload\n    end\n  end\n\n  factory :manage_data_import, :parent => :data_import do\n    sequence(:filename) { |n| \"#{Time.zone.now.strftime('%Y%m%d%H%M%S')}--COMVERGE_IMPORT-#{Kernel.rand(3500).to_i}-#{Kernel.rand(3500).to_i}.txt\" }\n    after(:create) do |data_import|\n      if data_import.state != \"pending\"\n        FactoryGirl.create(:data_import_record, :data_import_id => data_import.id)\n      end\n      FileUtils.mkdir_p(File.dirname(data_import.unsuccessful_filename))\n      FileUtils.touch([data_import.unsuccessful_filename])\n      data_import.reload\n    end\n  end\n\n  factory :portal_survey_survey, :class => PortalSurvey::Survey do\n    sequence(:key) {|n| \"portal_survey#{n}\" }\n    sequence(:name) {|n| \"Portal Survey #{n}\" }\n    sequence(:priority) {|n| 100-n}\n    can_postpone true\n    can_dismiss true\n  end\n\n  factory :portal_survey_category, :class => PortalSurvey::Category do\n    sequence(:title) {|n| \"Category #{n}\" }\n    sequence(:key) {|n| \"category_#{n}\" }\n    sequence(:sort_order)\n    association :survey, :factory => :portal_survey_survey\n  end\n\n  factory :portal_survey_question, :class => PortalSurvey::Question do\n    sequence(:text) {|n| \"Question #{n}\" }\n    sequence(:key) {|n| \"question_#{n}\" }\n    sequence(:sort_order)\n    association :category, :factory => :portal_survey_category\n    image 'some_image.png'\n    control_type 'radio'\n    answer_type 'id'\n  end\n\n  factory :portal_survey_answer, :class => PortalSurvey::Answer do\n    sequence(:text) {|n| \"Answer #{n}\" }\n    sequence(:key) {|n| \"answer_#{n}\" }\n    sequence(:sort_order)\n    association :question, :factory => :portal_survey_question\n  end\n\n  factory :portal_survey_premise_answer, :class => PortalSurvey::PremiseAnswer do\n    association :premise\n    association :question, :factory => :portal_survey_question\n  end\n\n  factory :portal_survey_premise_survey, :class => PortalSurvey::PremiseSurvey do\n    association :premise\n    association :survey, :factory => :portal_survey_survey\n  end\n\n  factory :popup do\n    element \".some_css_element\"\n    title \"Popup Title\"\n    content \"Popup content\"\n    placement \"top\"\n  end\n\n  factory :photo do\n    image { File.open(\"../common/test/fixtures/fsr_photos/photo.png\") }\n    image_timestamp { Time.zone.now }\n  end\n\n  factory :signature_photo, :parent => :photo do\n    image { File.open(\"../common/test/fixtures/fsr_photos/signature.png\") }\n    customer_signature true\n  end\n\n  factory :related_premise_category do\n    sequence(:name) { |i| \"Category #{i+1}\" }\n  end\n\n  factory :megawatt_variability_setting do\n  end\n\n  # This method adds end points to a device after it's been created.\n  def add_end_points(factory_array, dev)\n    factory_array.to_a.each do |f|\n      dev.end_points << FactoryGirl.build(f.to_sym)\n    end\n  end\nend\n######## Custom Factories ###########\n\n# RAILS3\n# We really shouldn't re-open FactoryGirl-- we should use a custom test helper module instead,\n# or just move this stuff into spec/support/*\nmodule FactoryGirl\n\n  def self.create_at(time, factory, *args)\n    result = nil\n    Timecop.travel(time.to_time) do\n      result = FactoryGirl.create(factory, *args)\n    end\n    result\n  end\n\n  def self.db_based_sequence(model_name, column, default = 1)\n    klass = model_name.to_s.classify.constantize\n    klass.select(column).order(\"#{column} desc\").first.send(column.to_sym).succ rescue default\n  end\n\n  def self.create_confidently(name,attributes)\n    self.build_confidently(name,attributes).tap { |m| m.save! }\n  end\n\n  def self.build_confidently(name,attributes)\n    attrs_on_model = FactoryGirl.factories.find(name).build_class.attribute_names\n    FactoryGirl.build(name, attributes.reject {|k,v| !attrs_on_model.include? k.to_s })\n  end\n\n  def self.update_confidently(model,attributes)\n    attrs_on_model = model.class.attribute_names\n    model.update_attributes(attributes.reject {|k,v| !attrs_on_model.include? k.to_s })\n  end\n\n  def self.create_portal_user_with_telemetries(options={})\n    # Setup portal user, premise and device\n    portal_user = FactoryGirl.create(:portal_user, options)\n    premise = FactoryGirl.create(:premise)\n    system_size = FactoryGirl.create(:system_size)\n\n    # SuperStat Pros are single set point devices\n    pro_device = FactoryGirl.create(:pro_device)\n    pro_device_end_point = pro_device.end_points.first\n    pro_device_end_point.update_attributes(:premise => premise, :system_size => system_size)\n\n    # Carrier Stats are multiple set point devices\n    comfort_choice_device = FactoryGirl.create(:comfort_choice_device)\n    comfort_choice_end_point = comfort_choice_device.end_points.first\n    comfort_choice_end_point.update_attributes(:premise => premise, :system_size => system_size)\n\n    from_period = Time.zone.now.midnight\n    to_period = from_period + 12.hours\n\n    # Setup outdoor temperatures\n    created_at = from_period\n    while (created_at < to_period)\n      temp = FactoryGirl.create(:outdoor_temperature, :location => portal_user.location, :current_temperature => random_temperature)\n      temp.update_attribute(:created_at, created_at)\n      created_at += 30.minutes\n    end\n\n    # Setup telemetries for pro_device end point\n    collected_at = from_period\n    while (collected_at < to_period)\n      temps = [random_temperature, random_temperature]\n      heat = temps.min\n      cool = temps.max\n      FactoryGirl.create(:telemetry,\n        :collected_at => collected_at,\n        :indoor_temperature => random_temperature,\n        :working_set_point => temps[rand(2)],\n        :display_temperature => random_temperature,\n        :end_point => pro_device_end_point,\n        :account => pro_device_end_point.account\n      )\n      collected_at += 30.minutes\n    end\n\n    # Setup telemetries for comfort choice end point\n    collected_at = from_period\n    while (collected_at < to_period)\n      temps = [random_temperature, random_temperature]\n      heat = temps.min\n      cool = temps.max\n      FactoryGirl.create(:telemetry,\n        :collected_at => collected_at,\n        :indoor_temperature => random_temperature,\n        :heat_set_point => heat,\n        :cool_set_point => cool,\n        :display_temperature => random_temperature,\n        :end_point => comfort_choice_end_point,\n        :account => pro_device_end_point.account\n      )\n      collected_at += 30.minutes\n    end\n\n    portal_user.premises << premise\n    portal_user\n  end\n\n  def self.random_temperature\n    possible_temperatures = (70..80).to_a\n    possible_temperatures[rand(possible_temperatures.length)]\n  end\n\n  def self.generate_load_commitments_for_all_buckets(options = {})\n    committable = options[:committable]\n    rc = options[:indirect_control_rate_contract]\n    rcc = committable.rate_contract_committables.detect { |r| r.indirect_control_rate_contract_id == rc.id }\n    bucket_range = LoadCommitment.bucket_range.to_a\n    bucket_range.reject! { |b| !options[:bucket_names].include?(b.name) } if options[:bucket_names].present?\n\n    if options[:bulk_sql_insert].present?\n      generate_load_commitments_for_all_buckets_with_sql(rcc, options[:load])\n      # Since we're going through SQL here, we won't be automatically updating the load potential through callbacks\n      if committable.respond_to?(:load_potential=)\n        committable.update_attribute(:load_potential, options[:load])\n      end\n    else\n      LoadCommitment.commitment_grouping.each do |month_or_season|\n        LoadCommitment::DAYTYPES.each do |day_type|\n          bucket_range.each do |time_or_bucket|\n            hour = time_or_bucket.first_hour(month_or_season).hour\n            load_commitment = rcc.load_commitments.select { |lc| lc.month == month_or_season.month_name && lc.day_type == day_type && lc.hour == hour }.first\n            if load_commitment\n              load_commitment.update_attribute(:load, options[:load]) if options[:override_existing]\n            else\n              LoadCommitment.create!({\n                :month => month_or_season.month_name,\n                :day_type => day_type,\n                :hour => hour,\n                :rate_contract_committable => rcc,\n                :load => options[:load]\n              })\n            end\n          end\n        end\n      end\n    end\n  end\n\n  def self.generate_load_commitments_for_all_buckets_with_sql(rcc, load)\n    LoadCommitment.where(\"rate_contract_committable_id = ?\", rcc.id).delete_all\n\n    rows_sql = Month.months.map do |month|\n      LoadCommitment::DAYTYPES.map do |day_type|\n        (1..24).to_a.map do |hour|\n          \"(NULL,'#{month.name}','#{day_type}',#{hour},#{load},'#{Time.zone.now.to_s(:db)}','#{Time.zone.now.to_s(:db)}',#{rcc.id},'LoadCommitment')\"\n        end\n      end\n    end.flatten\n\n    ActiveRecord::Base.connection.insert <<-SQL\n      INSERT INTO `base_commitments` (`id`, `month`, `day_type`, `hour`, `load`, `created_at`, `updated_at`, `rate_contract_committable_id`, `type`)\n      VALUES\n      #{rows_sql.join(\", \")}\n    SQL\n  end\n\n  def self.create_spending_forecaster_portal_user(options = {})\n    config = {\n      :login => \"forecaster\",\n      :serial_number => \"4004304\",\n      :total_month_electric_bill_amt => 15000,\n      :total_month_gas_bill_amt => 8000,\n      :total_month_kwh_usage => 1250,\n      :total_month_mcf_usage => 727,\n      :zipcode => 76132,\n      :age_of_hvac_system => 8,\n      :heating_energy_source => \"electric_heat_strips\",\n      :min_square_footage => 2101,\n      :max_square_footage => 2400,\n      :tonnage => 4.0\n    }.merge(options)\n\n    portal_user = PortalUser.find_by_login(config[:login]) || FactoryGirl.build_confidently(:portal_user, config)\n    portal_user.update_attribute(:location, FactoryGirl.build_confidently(:location, config))\n    FactoryGirl.update_confidently(portal_user, config)\n\n    [:pro_device,:pro_device].each_with_index do |device_type,i|\n      config.merge!({ :serial_number => (config[:serial_number].to_i + i).to_s })\n      device = Device.find_by_serial_number(config[:serial_number]) || FactoryGirl.create_confidently(device_type, config)\n      device.end_point.update_attribute(:system_size, FactoryGirl.build_confidently(:system_size, config))\n      FactoryGirl.update_confidently(device.thermostat_setting, config)\n\n      premise = FactoryGirl.create(:premise, :account_id => nil,:portal_users => [portal_user])\n      premise.update_attribute(:end_points, device.end_points)\n    end\n\n    portal_user\n  end\n\n  def self.create_completed_fsr( options={} )\n    field_service_request_options = {:assigned_users => [self.create(:installer_user)]}\n    field_service_request_options[:assigned_users] = options.delete(:assigned_users) || [self.create(:installer_user)]\n    field_service_request_options[:field_service_request_type] = (options.delete(:field_service_request_type) || 'install').titleize\n\n    # Blank creates a SuperStat (StatInspectionView on iPhone)\n    # :dcu_device creates a DCU (DcuInspectionView on iPhone)\n    # :service_point creates a Digi Service Point (GatewayInspectionView on iPhone)\n    device_type = options.delete(:device_type)\n\n    if device_type == :service_point\n      # For ServicePoint FSRs, we need a premise with devices attached\n      field_service_request_options[:premise] = FactoryGirl.create_premise_with_devices\n    end\n\n    ActiveRecord::Base.transaction do\n      fsr = self.create(:field_service_request, field_service_request_options.merge(options))\n      visit = self.create(:visit_detail, :field_service_request => fsr)\n\n      if device_type\n        inventory = self.create(device_type).inventory\n        visit.device_details.delete_all\n        if inventory.service_point?\n          visit.device_details << self.build(:sp_device_detail, :visit_detail => visit, :inventory => inventory)\n        else\n          visit.device_details << self.build(:device_detail, :visit_detail => visit, :inventory => inventory)\n        end\n\n        visit.save!\n      end\n      visit.visit_status = \"Completed\"\n      visit.save!\n\n      fsr.visit_details(true)\n      fsr.status = \"Completed\"\n      fsr.save!\n      fsr\n    end\n  end\n\n  def self.create_inspection_fsr( options = {} )\n    ActiveRecord::Base.transaction do\n      assigned_users = options.delete(:assigned_users) || [self.create(:installer_user)]\n      inspected_fsr = self.create_completed_fsr(options)\n      fsr = FactoryGirl.create(:field_service_request,\n                               :assigned_users => assigned_users,\n                               :field_service_request_type => 'Inspection',\n                               :premise => inspected_fsr.premise,\n                               :landlord_auth_status => inspected_fsr.landlord_auth_status,\n                               :status => \"Installer Assigned\",\n                               :inspected_fsr => inspected_fsr\n      )\n    end\n  end\n\n  def self.remove_fsr_data\n    [FieldServiceRequest, Device, DeviceDetail, DeviceLocation, Equipment, EquipmentLocation, EquipmentType, EquipmentMake, Inventory, Region, ServicePoint].map(&:delete_all)\n    User.where(\"email like 'quire%' and login like 'quire%'\").delete_all\n  end\n\n  # returns an array with 4 schedules representing each part of the day (see Schedule::PARTS_OF_DAY)\n  def self.create_day( start_time = Time.now.beginning_of_day, start_temp = 70, day_of_week = \"monday\", periods_per_day = 4 )\n    parts_of_day = (periods_per_day == 2) ? Schedule::TWO_PERIOD_PARTS_OF_DAY : Schedule::PARTS_OF_DAY\n    parts_of_day.map do | part_of_day |\n      Schedule.new( start_time += 3.hour, start_temp += 10, day_of_week, part_of_day )\n    end\n  end\n\n  def self.create_7_day_schedule_with_random_temp_values(periods_per_day = 4)\n    temp = nil\n    Schedule::PERIODS_OF_WEEK_7.map do | day |\n      temp = random_temp(temp)\n      FactoryGirl.create_day( Time.now.beginning_of_day, temp, day, periods_per_day )\n    end\n  end\n\n  def self.create_all_days_schedule_with_random_temp_values(periods_per_day = 4)\n    temp = nil\n    Schedule::PERIODS_OF_WEEK_1.map do | day |\n      temp = random_temp(temp)\n      FactoryGirl.create_day( Time.now.beginning_of_day, temp, day, periods_per_day )\n    end\n  end\n\n  def self.create_5_2_schedule_with_random_temp_values(periods_per_day = 4)\n    temp = nil\n    Schedule::PERIODS_OF_WEEK_5_2.map do | day |\n      temp = random_temp(temp)\n      FactoryGirl.create_day( Time.now.beginning_of_day, temp, day, periods_per_day )\n    end\n  end\n\n  def self.create_5_1_1_schedule_with_random_temp_values(periods_per_day = 4)\n    temp = nil\n    Schedule::PERIODS_OF_WEEK_5_1_1.map do | day |\n      temp = random_temp(temp)\n      FactoryGirl.create_day( Time.now.beginning_of_day, temp, day, periods_per_day )\n    end\n  end\n\n  def self.create_7_day_schedule_with_identical_weekdays_but_different_weekends(periods_per_day = 4)\n    days = Schedule::PERIODS_OF_WEEK_7\n    weekdays, weekend = days.in_groups_of( 5, false )\n\n    weekday_schedule = weekdays.map do | day |\n      FactoryGirl.create_day( Time.now.beginning_of_day, 70, day, periods_per_day )\n    end\n\n    temp = nil\n    weekend_schedule = weekend.map do | day |\n      temp = random_temp(temp)\n      FactoryGirl.create_day( Time.now.beginning_of_day, temp, day, periods_per_day )\n    end\n\n    weekday_schedule + weekend_schedule\n  end\n\n  def self.create_7_day_schedule_with_identical_weekdays_and_weekends(periods_per_day = 4)\n    Schedule::PERIODS_OF_WEEK_7.map do | day |\n      FactoryGirl.create_day( Time.now.beginning_of_day, 50, day, periods_per_day )\n    end\n  end\n\n  def self.create_constraint_topology_with_1_level\n    constraint = PhysicalTopology.create(:is_constraint => true)\n    new_node = constraint.create_and_add_to(nil, {:name => \"Base\"})\n    constraint\n  end\n\n  def self.create_constraint_topology_with_2_levels\n    constraint = PhysicalTopology.create(:is_constraint => true)\n    new_node = constraint.create_and_add_to(nil, {:name => \"Base\"})\n    new_node = constraint.create_and_add_to(new_node, {:name => \"Second\"})\n    constraint\n  end\n\n  def self.create_constraint_topology_with_4_levels(options = {})\n    options.reverse_merge!({:level_1 => \"Grid\", :level_2 => \"Substation\", :level_3 => \"Feeder\", :level_4 => \"Circuit\"})\n    constraint = PhysicalTopology.create(:is_constraint => true)\n    new_node = constraint.create_and_add_to(nil, {:name => options[:level_1]})\n    new_node = constraint.create_and_add_to(new_node, {:name => options[:level_2]})\n    new_node = constraint.create_and_add_to(new_node, {:name => options[:level_3]})\n    new_node = constraint.create_and_add_to(new_node, {:name => options[:level_4]})\n    constraint\n  end\n\n  def self.create_constrained_topology(constraint=create_constraint_topology_with_4_levels, root_node_name='Grid')\n    topology = PhysicalTopology.create(:topology_constraint => constraint)\n\n    grid_constraint = constraint.node_by_name(\"Grid\")\n    grid_node = topology.create_and_add_to(nil, {:constraint_node => grid_constraint, :name => root_node_name})\n    grid_node.area_address = 1 if grid_constraint.addressable?\n\n    substation_constraint = constraint.node_by_name(\"Substation\")\n    substation_node = topology.create_and_add_to(grid_node, {:constraint_node => substation_constraint, :name => \"Substation\"})\n    substation_node.area_address = 2 if substation_constraint.addressable?\n\n    feeder_constraint = constraint.node_by_name(\"Feeder\")\n    feeder_node = topology.create_and_add_to(substation_node, {:constraint_node => feeder_constraint, :name => \"Feeder\"})\n    feeder_node.area_address = 3 if feeder_constraint.addressable?\n\n    circuit_constraint = constraint.node_by_name(\"Circuit\")\n    circuit_node = topology.create_and_add_to(feeder_node, {:constraint_node => circuit_constraint, :name => \"Circuit\"})\n    circuit_node.area_address = 4 if circuit_constraint.addressable?\n\n    circuit_node2 = topology.create_and_add_to(feeder_node, {:constraint_node => circuit_constraint, :name => \"Circuit2\"})\n    circuit_node2.area_address = 5 if circuit_constraint.addressable?\n\n    AreaAddressing.create(:topology => constraint,\n                          :area_1 => constraint.node_by_name(\"Grid\"),\n                          :area_2 => constraint.node_by_name(\"Feeder\"),\n                          :area_3 => constraint.node_by_name(\"Circuit\"))\n    topology\n  end\n\n  def self.create_single_level_lmp_datum_constrained_topology(constraint=create_constraint_topology_with_1_level)\n    topology = PhysicalTopology.create(:topology_constraint => constraint)\n    constraint_node = constraint.node_by_name(\"Base\")\n    constraint_node.update_attributes :lmp_market_level => true\n    LmpDatum::NODE_MAP.values.each do |name|\n        topology.create_and_add_to(nil, {:constraint_node => constraint_node, :name => name})\n    end\n    topology\n  end\n\n\n  def self.create_single_level_constrained_topology(constraint=create_constraint_topology_with_1_level)\n    topology = PhysicalTopology.create(:topology_constraint => constraint)\n    new_node = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 1\"})\n    new_node = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 2\"})\n    new_node = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 3\"})\n    new_node = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 4\"})\n    new_node = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 5\"})\n    new_node = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 6\"})\n    new_node = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 7\"})\n    new_node = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 8\"})\n    new_node = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 9\"})\n    new_node = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 10\"})\n    topology\n  end\n\n  def self.create_two_level_constrained_topology(constraint=create_constraint_topology_with_2_levels)\n    topology = PhysicalTopology.create(:topology_constraint => constraint)\n    new_node1 = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 1\"})\n    new_node2 = topology.create_and_add_to(nil, {:constraint_node => constraint.node_by_name(\"Base\"), :name => \"Node 2\"})\n    new_node = topology.create_and_add_to(new_node1, {:constraint_node => constraint.node_by_name(\"Second\"), :name => \"Node 3\"})\n    new_node = topology.create_and_add_to(new_node1, {:constraint_node => constraint.node_by_name(\"Second\"), :name => \"Node 4\"})\n    new_node = topology.create_and_add_to(new_node1, {:constraint_node => constraint.node_by_name(\"Second\"), :name => \"Node 5\"})\n    new_node = topology.create_and_add_to(new_node1, {:constraint_node => constraint.node_by_name(\"Second\"), :name => \"Node 6\"})\n    new_node = topology.create_and_add_to(new_node2, {:constraint_node => constraint.node_by_name(\"Second\"), :name => \"Node 7\"})\n    new_node = topology.create_and_add_to(new_node2, {:constraint_node => constraint.node_by_name(\"Second\"), :name => \"Node 8\"})\n    new_node = topology.create_and_add_to(new_node2, {:constraint_node => constraint.node_by_name(\"Second\"), :name => \"Node 9\"})\n    new_node = topology.create_and_add_to(new_node2, {:constraint_node => constraint.node_by_name(\"Second\"), :name => \"Node 10\"})\n    topology\n  end\n\n  def self.create_topology_with_6_devices(rate_contract_type = :direct_control_rate_contract)\n    addressing_scheme = FactoryGirl.create(:area_addressing)\n    topology = FactoryGirl.create_constrained_topology(addressing_scheme.topology)\n    grid = topology.nodes.first\n    grid.update_attributes!({:area_address => 1})\n    substation = grid.children.first\n    feeder = substation.children.first\n    feeder.update_attributes!({:area_address => 2})\n    circuit1 = feeder.children.first\n    circuit1.update_attributes!({:area_address => 3})\n    circuit2 = topology.create_and_add_to(feeder, :name => \"Circuit 2\")\n    circuit2.update_attributes!({:area_address => 4})\n\n    rc1 = FactoryGirl.create(rate_contract_type)\n    rc2 = FactoryGirl.create(rate_contract_type)\n\n    ra_10 = find_and_update_or_create_rate_address_by_address(\n      :address => 10, :name => \"Thermostat Control\",\n      :end_point_1_contract => rc1)\n    ra_20 = find_and_update_or_create_rate_address_by_address(\n      :address => 20, :name => \"A/C Control\",\n      :end_point_1_contract => rc2)\n    unless rate_contract_type == :tou_rate_contract\n      ra_30 = find_and_update_or_create_rate_address_by_address(\n        :address => 30, :name => \"A/C Control non-extended\",\n        :extended => false,\n        :end_point_1_contract => rc1,\n        :end_point_2_contract => rc2)\n    end\n    dev_type = DeviceType.find_by_name(\"SuperStat\") || FactoryGirl.create(:device_type)\n\n    sp = FactoryGirl.create(:digi_service_point)\n    dev1 = FactoryGirl.create(:pro_device, :service_point => sp, :device_type => dev_type, :serial_number => '1', :rate_address => ra_10, :commissioned_at => Time.zone.now)\n    dev1.end_points[0].connected_load_in_kw = 1.0\n    dev1.save\n\n    sp = FactoryGirl.create(:digi_service_point)\n    dev2 = FactoryGirl.create(:pro_device, :service_point => sp, :device_type => dev_type, :serial_number => '2', :rate_address => ra_10, :commissioned_at => Time.zone.now)\n    dev2.end_points[0].connected_load_in_kw = 1.0\n    dev2.save\n\n    sp = FactoryGirl.create(:digi_service_point)\n    dev3 = FactoryGirl.create(:pro_device, :service_point => sp, :device_type => dev_type, :serial_number => '3', :rate_address => ra_20, :commissioned_at => Time.zone.now)\n    dev3.end_points[0].connected_load_in_kw = 1.1\n    dev3.save\n\n    sp = FactoryGirl.create(:digi_service_point)\n    dev4 = FactoryGirl.create(:pro_device, :service_point => sp, :device_type => dev_type, :serial_number => '4', :rate_address => ra_20, :commissioned_at => Time.zone.now)\n    dev4.end_points[0].connected_load_in_kw = 1.1\n    dev4.save\n\n    sp = FactoryGirl.create(:digi_service_point)\n    dev5 = FactoryGirl.create(:pro_device, :service_point => sp, :device_type => dev_type, :serial_number => '5', :rate_address => ra_20, :commissioned_at => Time.zone.now)\n    dev5.end_points[0].connected_load_in_kw = 1.1\n    dev5.save\n\n    sp = FactoryGirl.create(:digi_service_point)\n    dev6 = FactoryGirl.create(:pro_device, :service_point => sp, :device_type => dev_type, :serial_number => '6', :rate_address => ra_20, :commissioned_at => Time.zone.now)\n    dev6.end_points[0].connected_load_in_kw = 1.1\n    dev6.save\n\n    circuit1.add_devices([dev1, dev2, dev3])\n    circuit2.add_devices([dev4, dev5, dev6])\n\n    [ dev1, dev2, dev3, dev4, dev5, dev6 ]\n  end\n\n  def self.create_topology_with_2_devices\n    addressing_scheme = FactoryGirl.create(:area_addressing)\n    topology = FactoryGirl.create_constrained_topology(addressing_scheme.topology)\n    grid = topology.nodes.first\n    grid.update_attributes!({:area_address => 1})\n    substation = grid.children.first\n    feeder = substation.children.first\n    feeder.update_attributes!({:area_address => 2})\n    aa = 3\n    feeder.children.each do |circuit|\n      circuit.update_attributes!({:area_address => aa})\n      aa += 1\n    end\n    circuit1, circuit2 = feeder.children[0..2]\n\n    rc1 = FactoryGirl.create(:direct_control_rate_contract, :name => '100%')\n    rc2 = FactoryGirl.create(:direct_control_rate_contract, :name => '50%')\n\n    ra_10 = find_and_update_or_create_rate_address_by_address(\n      :address => 10, :name => \"A/C Control\",\n      :end_point_1_contract => rc1)\n    ra_20 = find_and_update_or_create_rate_address_by_address(\n      :address => 20, :name => \"Hot Water\",\n      :end_point_1_contract => rc2, :end_point_2_contract => rc1)\n\n    dev_type = DeviceType.find_by_name(\"SuperStat\") || FactoryGirl.create(:device_type)\n\n    dev1 = FactoryGirl.create(:device, :device_type => dev_type,\n                          :serial_number => '1', :rate_address => ra_10,\n                          :commissioned_at => Time.zone.now,\n                          :transmitter => FactoryGirl.create(:transmitter, :utility => 1))\n\n    dev2 = FactoryGirl.create(:device, :device_type => dev_type,\n                          :serial_number => '2', :rate_address => ra_20,\n                          :commissioned_at => Time.zone.now,\n                          :transmitter => FactoryGirl.create(:transmitter, :utility => 2))\n\n    circuit1.add_devices([dev1])\n    circuit2.add_devices([dev2])\n\n    # nodes and rate_contracts are handy for control event testing\n    {:topology => topology, :grid => grid, :feeder => feeder, :dev_type => dev_type,\n      :nodes => [circuit1, circuit2], :rate_contracts => [rc1, rc2], :substation => substation}\n  end\n\n  def self.create_rate_info\n    RateAddress.seed_data!\n    rc1 = FactoryGirl.create(:direct_control_rate_contract)\n    rc2 = FactoryGirl.create(:direct_control_rate_contract)\n\n    find_and_update_or_create_rate_address_by_address(\n        :address              => 15,\n        :name                 => \"Thermostat Control\",\n        :extended             => true,\n        :end_point_1_contract => rc1)\n    find_and_update_or_create_rate_address_by_address(\n        :address              => 25,\n        :name                 => \"A/C Control\",\n        :extended             => true,\n        :end_point_1_contract => rc1,\n        :end_point_2_contract => rc2)\n  end\n\n  def self.create_basic_topology\n    addressing_scheme = FactoryGirl.create(:area_addressing)\n    topology = FactoryGirl.create_constrained_topology(addressing_scheme.topology)\n    grid = topology.nodes.first\n    grid.update_attributes!({:area_address => 1})\n    substation = grid.children.first\n    feeder = substation.children.first\n    feeder.update_attributes!({:area_address => 2})\n    circuit = feeder.children.first\n    circuit.update_attributes!({:area_address => 3})\n    circuit\n  end\n\n  def self.create_topology_with_directlink_devices\n    InventoryEquipmentType.seed_data!\n    circuit = create_basic_topology\n    create_rate_info\n\n    th_ra = RateAddress.where(:name => 'Thermostat Control').first\n\n    dev1 = install_direct_link_device(:rate_address => th_ra)\n    dev2 = install_direct_link_device(\n        :rate_address => nil,\n        :device_type  => :it800_chassis,\n        :premise      => Premise.first\n    )\n\n    circuit.add_devices([dev1, dev2])\n    [ dev1, dev2 ]\n  end\n\n  def self.install_direct_link_device(options={})\n    connected_load = options[:connected_load_in_kw] || 2.0\n    device_type    = options[:device_type]          || :it800\n    premise        = options[:premise]              || FactoryGirl.create(:premise)\n    ra             = options[:rate_address]\n\n    iet_name = DeviceType[device_type].name\n    iet      = InventoryEquipmentType.where(:name => iet_name).first\n\n    device_attributes = {:device_type   => DeviceType[device_type],\n                         :rate_address  => ra,\n                         :xmpp_presence => 'online'\n    }\n\n    inv = Inventory.create(:inventory_equipment_type => iet,\n                           :inventory => FactoryGirl.create(:it800_device, device_attributes),\n                           :state     => 'in_inventory')\n    inv.install_at!(premise)\n    dev = inv.inventory\n    dev.end_points.first.update_attributes(:premise => premise, :connected_load_in_kw => connected_load)\n    dev\n  end\n\n  def self.create_all_seasons\n    Season.seed_data!\n  end\n\n  def self.create_all_tier_names\n    TierName.seed_data!\n  end\n\n  def self.load_provider_for(device, node)\n    p = FactoryGirl.create(:prospective_premise, :node => node)\n    p.devices.destroy\n    p.end_points = (device.end_points)\n    p.devices(true)\n    p.contacts << FactoryGirl.create(:contact, :contactable => p)\n    p.utility_meters << FactoryGirl.build(:utility_meter, :device => device, :meter_number => device.serial_number, :premise => p)\n    p.become_load_provider!\n    p\n  end\n\n\n  def self.create_m_and_v_premise(options = {})\n    premise_options = options.delete(:premise)\n\n    premise = if premise_options.is_a?(Premise)\n      premise_options\n    else\n      FactoryGirl.create( :premise, premise_options )\n    end\n\n    meter_options = options.delete(:meter)\n    m_and_v_meter = FactoryGirl.create( :m_and_v_meter, meter_options )\n\n    thermometer_options = options.delete(:thermometer)\n    thermometer = FactoryGirl.create( :m_and_v_thermometer, thermometer_options )\n\n    dcu = m_and_v_meter.metered_devices.first\n\n    dcu_options = options.delete(:dcu)\n    dcu.update_attributes(dcu_options)\n\n    premise.end_points += m_and_v_meter.end_points + thermometer.end_points + dcu.end_points\n\n    dcu.rate_contracts.map { | rc | rc.update_attribute( :recurring, true ) }\n\n    premise\n  end\n\n  def self.create_control_event_with_premises_with_contacts(attributes={})\n    (ce = build_control_event_with_premises_with_contacts(attributes)).save!\n    ce\n  end\n\n  def self.create_service_point_with_associations_for_account(account=FactoryGirl.create(:account))\n    service_point = FactoryGirl.create(:service_point)\n    device = FactoryGirl.create(:device, :service_point => service_point)\n    premise = FactoryGirl.create(:premise, :account => account)\n\n    end_point = device.end_points.first\n    end_point.update_attribute(:premise_id, premise.id)\n    device.service_point\n  end\n\n  # Builds a C&I Control Event\n  def self.build_control_event_with_premises_with_contacts(attributes={})\n    cfg = ::Configuration.instance\n    cfg.update_attributes!(:c_and_i_response_sms => '5558159791', :c_and_i_response_sms_carrier => SMSFu.carriers.keys.map(&:to_s).sort.first)\n    num_premises = attributes.delete(:number_of_premises) || 2\n    num_contacts = attributes.delete(:number_of_contacts) || 2\n    num_notifications = attributes.delete(:number_of_notification_types) || 2\n    first_notification_type = attributes.delete(:first_notification_type)\n    topology = self.create_constrained_topology\n    leaves = topology.nodes.collect(&:leaves).flatten\n    rate_contract = FactoryGirl.create(:indirect_control_rate_contract, :commitment_goals => generate_standard_commitments(:commitment_goal))\n    num_premises.times do |i|\n      node = leaves[i%leaves.length]\n      device = FactoryGirl.create(:c_and_i_device, :indirect_control_rate_contracts => [rate_contract], :nodes => [node])\n      premise = FactoryGirl.create(:prospective_premise, :node => node)\n      premise.end_points += device.end_points\n      premise.devices(true)\n      FactoryGirl.create(:dr_measure, :c_and_i_premise => premise, :indirect_control_rate_contract => rate_contract)\n      num_contacts.times do |j|\n        first_notification = first_notification_type || [\"SMS\", \"Email\", \"Phone\", \"Robocall\"][(i+j) % 4]\n        contact = FactoryGirl.create(:contact, :first_name => \"name#{i}#{j}\", :last_name => \"name#{i}#{j}\", :contactable => premise, :sequence => j)\n        FactoryGirl.create(:contact_notification_type,\n                        :contact => contact,\n                        :notification_type => NotificationType.find_by_name(first_notification) || FactoryGirl.create(:notification_type, :name => first_notification))\n        (num_notifications - 1).times do |k|\n          kth_notification = [\"SMS\", \"Email\", \"Phone\", \"Robocall\"][(i+j+k+1) % 4]\n          contact.add_notification_type(kth_notification)\n        end\n        premise.contacts << contact\n      end\n      premise.utility_meters << FactoryGirl.build(:utility_meter, :premise => premise)\n\n      premise.become_load_provider!\n      premise.reload\n    end\n    FactoryGirl.build(:control_event, attributes.merge( { :nodes => topology.nodes, :rate_contracts => [ rate_contract ] } ))\n  end\n\n  def self.create_control_event(options={})\n    options = {:rate_contract => :tou_rate_contract}.merge options\n    ce = nil\n    TierName.seed_data!\n    Timecop.freeze(options[:start_time] || \"2012/05/14 13:00:15\") do\n      ce = ControlEvent.new\n      ce.override_restrictions = true\n      ce.start_time = Time.zone.now\n      ce.end_time = ce.start_time + 30.minutes\n\n      devices = options[:devices] || create_topology_with_6_devices(options[:rate_contract])\n      devices << create(:rt_meter) if options[:include_rt_meter]\n      devices.each(&:seen!)\n\n      ce.nodes << devices.map{|d| d.nodes }.flatten\n\n      rate_contracts = devices.map{|n| n.rate_contracts }.flatten.uniq\n      ce.rate_contract_to_selected_control_strategy_mapping = {}\n\n      if is_tou = devices.first.has_tou?\n        controlled_tiers = rate_contracts.map { |rc|\n          rc.control_strategies.each{|cs| cs.tier_name = TierName.where(:controlled_by_event => true).last}\n          rc.save!\n          ce.rate_contracts << rc\n          ce.rate_contract_to_selected_control_strategy_mapping[rc.id.to_s] = rc.control_strategies.default.id.to_s\n          rc.control_strategies.map(&:tier_name)\n        }.flatten.uniq\n        normal_tiers = TierName.all - controlled_tiers\n      else\n        rate_contracts.each do |rc|\n          ce.rate_contracts << rc\n        end\n      end\n\n      ce.save!\n\n      ce.send(:save_online_statuses)\n      ce.send(:save_commissioned_statuses)\n      ce.log_control_records\n\n      if is_tou\n        devices[0..((options[:devices_with_telems] || 6) - 1)].each {|device|\n          time = ce.start_time\n          [normal_tiers, controlled_tiers].each do |tiers|\n            create(:telemetry, :end_point => device.end_point, :collected_at => time += 5.minutes, :tier_name_id => tiers.first.id, :heat_set_point => 69) unless options[:exclude_telems]\n          end\n        }\n      end\n    end\n    ce\n  end\n\n  def self.generate_standard_commitments(factory_name, variable_load = false)\n    Date::MONTHNAMES.inject([]) do |collection, month|\n      unless month.nil?  #This collection includes a nil option for selectors\n        (12..20).each_with_index do |hour,i|\n          load = variable_load ? 90 + (i * 10) : 100\n          collection << FactoryGirl.create(factory_name, :month => month, :hour => hour, :load => load)\n        end\n      end\n      collection\n    end\n  end\n\n  def self.generate_localized_commitments(factory_name, variable_load = false, hour = 12)\n    month = Date::MONTHNAMES[Time.zone.now.month]\n    day_type = BaseCommitment.get_day_type(Time.zone.now)\n    commitments = []\n    [hour-1, hour, hour+1].each_with_index do |commit_hour, i|\n      load = variable_load ? 90 + (i * 10) : 100\n      # need a value between 1 and 24\n      valid_hour = if commit_hour > 24\n        commit_hour%24\n      elsif commit_hour == 0\n        commit_hour = 24\n      else\n        commit_hour\n      end\n      commitments << FactoryGirl.create(factory_name,\n                                        :month => month, :hour => valid_hour,\n                                        :day_type => day_type, :load => load)\n    end\n    commitments\n  end\n\n  def self.generate_localized_commitments_for_date(factory_name, variable_load = false, date = Date.today)\n    month = Date::MONTHNAMES[date.month]\n    day_type = BaseCommitment.get_day_type(date)\n    commitments = []\n    (1..24).each_with_index do |commit_hour, i|\n      load = variable_load ? 90 + (i * 10) : 100\n      commitments << FactoryGirl.create(factory_name,\n                                        :month => month, :hour => commit_hour,\n                                        :day_type => day_type, :load => load)\n    end\n    commitments\n  end\n\n  def self.generate_localized_commitments_for_now(factory_name, variable_load = false)\n    # Hours are hour-ending, 1-24 (rather than 0-23)\n    hour = (Time.zone.now+1.hour).hour\n    hour = 24 if hour.zero?\n    generate_localized_commitments(factory_name, variable_load, hour)\n  end\n\n  def self.participating_device_for(rate_contract, date)\n    device = FactoryGirl.create(:c_and_i_device, :indirect_control_rate_contracts => [rate_contract])\n    rcc = RateContractCommittable.where(:committable_id => device.id, :committable_type => device.class.name, :indirect_control_rate_contract_id => rate_contract.id).first\n    rcc.load_commitments = FactoryGirl.generate_localized_commitments_for_date(:load_commitment, true, date)\n    device\n  end\n\n  def self.my_ip\n    UDPSocket.open {|s| s.connect('65.59.196.211', 1); s.addr.last }\n  end\n\n  def self.my_port\n    Rails.env == 'production' ? ':80' : ':3000'\n  end\n\n  # returns a random valid temperature\n  def self.random_temp(but_not = nil)\n    ((45..90).to_a - [but_not]).sample\n  end\n\n  # returns a premise with connected devices in order to pass install FSR validation\n  def self.create_premise_with_devices\n    FactoryGirl.create(:device_with_account).premises[0]\n  end\n\n  private\n  def self.extract_value(hash, key, default_value)\n    hash.has_key?(key) ? hash.delete(key) : default_value\n  end\n\n  def self.find_and_update_or_create_rate_address_by_address(params)\n    if obj = RateAddress.find_by_address(params[:address])\n      obj.update_attributes(params)\n    else\n      obj = FactoryGirl.create(:rate_address, params)\n    end\n\n    obj\n  end\n\n  def self.setup_tou_rate_contract_and_friends_for_thermostat_setting(thermostat_setting)\n    TierName.seed_data!\n\n    tou_rc = FactoryGirl.create(:tou_rate_contract, :tou_restriction_name => \"Thermostat\")\n\n    PriceTier.delete_all\n\n    TierName.all.each_with_index do |tn, i|\n      tou_rc.price_tiers.create!(:tier_name => tn, :price => i + 1)\n    end\n\n    [\n      [0, 'heat', true, 70],\n      [1, 'heat', true, 68],\n      [2, 'heat', false, 66],\n      [3, 'heat', true, 61],\n      [0, 'cool', true, 72],\n      [1, 'cool', true, 74],\n      [2, 'cool', false, 76],\n      [3, 'cool', true, 79]\n    ].each do |setting|\n      thermostat_setting.tier_settings.create!(\n        :tier_name_id => TierName.where(:table_offset => setting[0]).first.id,\n        :mode         => setting[1],\n        :enabled      => setting[2],\n        :set_point    => setting[3]\n      )\n    end\n\n    rate_address = FactoryGirl.create(:rate_address, :end_point_1_contract => tou_rc)\n\n    unless thermostat_setting.device\n      thermostat_setting.device = FactoryGirl.create(:intellitemp_device)\n      thermostat_setting.save!\n    end\n\n    device = thermostat_setting.device\n\n    device.update_attribute(:rate_address_id, rate_address.id)\n\n    create_holidays_for_tou(tou_rc)\n\n    tou_rc.control_strategies.first.update_attribute(:tier_name_id, TierName.where(:name => 'critical').first.id)\n  end\n\n  def self.create_holidays_for_tou(tou_rate_contract)\n    tou_rc = tou_rate_contract\n    %w[Comverge Red Blue Green].each_with_index do |name, i|\n      schedule = i < 2 ? tou_rc.tou_schedules.first : tou_rc.tou_schedules.last\n      start_date = schedule.start_date.in_time_zone(Time.zone).to_date\n      Holiday.create!(:the_date => start_date + i + 1, :name => \"#{name} Day\")\n    end\n  end\n\n  def self.single_mode_thermostat_program(options = {})\n    set_times = options[:set_times] || ['06:00', '10:00', '18:00', '22:00']\n    set_points = options[:set_points] || set_times.map{|t| options[:set_point] || 77 }\n\n    hash = {}\n    Schedule::PERIODS_OF_WEEK_7.each{|pow|\n      hash[pow] = {}\n      Schedule::PARTS_OF_DAY.each_with_index{|pod, i|\n        hash[pow][pod] = {'start_time' => set_times[i], 'set_point' => set_points[i] }\n      }\n    }\n    hash\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[811,11],[811,13]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":104},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/intellisource/common/test/factories/factories.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"8ab2b17aef83b0c8a3a5e8c4c55064e508da288f","deserializer":"TextBuffer"},{"text":"source 'https://rubygems.org'\n\ngem 'rails',                '=4.0.12'\ngem 'rails-observers',      '~> 0.1.2'\ngem 'actionpack-xml_parser', '~>1.0.1'\ngem 'dalli'\ngem 'rake',                 '~>0.9.2', :require => false # UPDATE\ngem 'daemons',              '~>1.1.9'\ngem 'mysql2'\ngem 'nokogiri',             '~>1.5'\ngem 'logging-rails',        '0.3.0', :require => 'logging/rails', :git => \"https://github.com/TwP/logging-rails.git\", :ref => '90d2210d7398dd60a40b8dce3f4a158be72744b3'\ngem 'logging',              '~> 1.8.2'\ngem 'will_paginate',        '~> 3.0.pre4'\ngem 'rmagick',              '~> 2.13.2', :require => false\ngem 'soap4r-ruby1.9',       '~>2.0.3'\ngem 'mqttx',                :git => 'https://github.com/tierconnect/ruby-mqtt/', :ref => '17f1a70457056d6e20353e31649ceafcbcd0ccd9', :require => false\ngem 'xml-simple',           '~>1.0.12', :require => 'xmlsimple'\ngem 'resque',               '~>1.20.0'\ngem 'uuid',                 '~>2.3.1', :require => false\ngem 'resque-status',        '~>0.3.2'\ngem 'prawnto',              '~>0.1.1'\ngem 'prawn',                '~>0.8.4'\ngem 'prawn-core',           '~>0.8.4',  :require => 'prawn/core'\ngem 'prawn-layout',         '~>0.8.4',  :require => 'prawn/layout'\ngem 'prawn-security',       '~>0.8.4',  :require => 'prawn/security'\ngem 'httpclient',           :git => 'https://github.com/nahi/httpclient', :ref => '5be11c'\ngem 'spreadsheet',          '~>0.9.6'\ngem 'linguistics',          '~>1.0.8',  :require => false\ngem 'redis',                '~>2.2.2'\ngem 'yajl-ruby',            '=1.1.0',   :require => 'yajl/json_gem'\ngem 'awesome_nested_set',   '~>3.0.1'\ngem 'state_machine',        '~>1.2.0'\ngem 'paperclip',            '~> 4.2.0'\ngem 'spatial_adapter', :require => 'spatial_adapter/mysql2', :git => 'https://github.com/descentintomael/spatial_adapter.git', :ref => 'cf7b1bdc4d0ce1f5642001196af92bd61853ebc7'\ngem 'chronic'\ngem 'ruby_protobuf',        '~>0.4.5'\ngem 'simple-rss',           '~>1.2.3'\ngem 'pony',                 :require => false # this gem is an undeclared dependency of sms_fu\ngem 'spawnling',          '2.1.5'\ngem \"ym4r_gm\",              :require => false\ngem \"dynamic_form\"\ngem \"archive-zip\",          :require => false\ngem \"devise\",               '~>3.2.4'\ngem \"devise-encryptable\",   '~>0.2.0'\ngem 'simple_token_authentication', :git => \"https://github.com/comverge/simple_token_authentication.git\"\ngem 'pbkdf2-ruby',          '~>0.2.1', :require => false\ngem \"eco\"\ngem \"paper_trail\",          '~>3.0.1'\ngem \"redis-activesupport\"\ngem 'xmpp4r',               '~>0.5', :require => 'xmpp4r/client'\ngem 'comverge-units', :git => \"git@github.comverge.com:software/unit.git\", :tag => 'v1.1'\ngem 'comverge-baseline', :path => \"../gems/comverge-baseline\", :require => false\ngem 'comverge-cassidian', :git => 'git@github.comverge.com:software/comverge-cassidian.git', :tag => 'v0.0.3', :require => false\ngem 'comverge-openadr', :git => 'git@github.comverge.com:software/comverge-openadr.git', :tag => 'v0.0.3', :require => false\ngem 'bitfields', :git => 'git@github.comverge.com:software/bitfields.git', :tag => 'v0.4.1', :require => false\ngem 'pjm', :git => 'git@github.comverge.com:software/pjm.git', :ref => 'ee31e8f9e8eecb897722da820a6c5223fd3d4ffb', :require => false\n\ngem \"servolux\"\ngem \"i18n-js\", :git => \"https://github.com/fnando/i18n-js.git\"\ngem 'random_data'\ngem 'savon', :git => 'git@github.comverge.com:software/savon.git', :branch => 'hotfix_for_order_and_no_converter'\n\ngem 'parallel_runner', :git => 'git@github.comverge.com:software/parallel_runner.git', :tag => 'v0.0.3.comverge'\n\ngem 'roadie',               '~> 3.0.1'\ngem 'roadie-rails'\n\ngem 'timerage'\n\ngem 'aa-auth', git: \"git@github.comverge.com:software/aa-auth.git\", tag: \"v4.2.0\"\n\ngem 'pushmeup',             '~> 0.3.0'\ngem 'lazy_high_charts'\ngem 'forecast_io'\n\ngem 'faker'\n\ngroup :nmatrix do\n  gem \"nmatrix\",            '~>0.1.0.rc5'\n  gem \"comverge-kmeans\", :git => \"git@github.comverge.com:software/comverge-kmeans.git\", :tag => \"v0.3\"\nend\n\ngem 'coffee-rails', \"~> 4.0.1\"\ngem 'sass-rails',   '~> 4.0.3'\n\ngroup :production do\n  gem 'execjs'\n  gem 'therubyracer', '~> 0.12.1', :require => 'v8'\n  gem 'uglifier'\nend\n\ngem \"net-sftp\",             \"~>2.0.5\", :require => false\n\n#  two-factor auth stuff\ngem 'rqrcode_png'\n\ngroup :development, :test do\n  gem 'spork',              '~>0.9.0', :require => false\n  gem 'awesome_print', :require => 'ap' # recurring_control.feature fails with version 0.3.x\n  gem 'thin'\n  gem 'thin-rails',         '~>1.0'\n  gem 'byebug'\n  gem \"factory_girl_rails\", '~>4.5.0'\n\n  gem 'eventmachine',       '~>0.12.10'\n\n  gem 'rspec',              '~>2.14.0', :require => false\n  gem 'rspec-rails',        '~>2.14.0', :require => false\n  gem \"rspec2-rails-views-matchers\", \"~> 0.2.2\", :require => false\n  gem 'rspec-given',        '~>2.4.0', :require => false\n\n  gem 'rainbow', '1.1.4'\n  gem 'jasmine-headless-webkit'\n  gem 'simplecov', :require => false\n  gem 'guard', '~>1.0'\n  gem 'guard-rspec'\n  gem 'guard-spork'\n  gem 'guard-shell'\n  gem 'guard-jasmine-headless-webkit'\n  gem 'rails-dev-boost'\n  gem 'rb-fsevent', '~> 0.9.1'\n  gem 'rack-rewrite'\nend\n\ngroup :development do\n  #gem 'chef',               '~>10.24.0',  :require => false\n  gem 'capistrano',         '~>2.14.0',   :require => false\n  gem 'capistrano-maintenance'\n  gem 'rvm-capistrano'\n  gem 'pivotal_git_scripts'\n  gem 'quiet_assets'\n  gem 'cucumber-peel'\n  gem 'meta_request'\n\n  gem 'better_errors'\n  gem 'binding_of_caller' # Supports better_errors\n  gem 'letter_opener'\nend\n\ngroup :test do\n  gem 'webmock',            :require => false\n  gem 'mocha'\n  gem 'rspec-rails-mocha',  '~> 0.3.1',  :require => false\n  gem 'rmodbus',            '~>0.2.2'\n  gem \"selenium-client\",    '~>1.2.16'\n  gem \"shoulda-matchers\"\n  gem \"selenium-webdriver\", '~>2.43.0'\n  gem 'capybara-screenshot'\n\n  # cucumber-related stuff\n  gem 'gherkin',            '~>2.12.1'\n  gem 'cucumber',           '~>1.2'\n  gem 'cucumber-rails',     '~>1.4.2', :require => false\n  gem 'database_cleaner',   '~>1.3.0'\n  gem 'capybara',           '~>1.1.2'\n  gem 'capybara-firebug',   '~>0.0.10', :require => false\n  gem 'launchy',            '~>2.2',   :require => false\n  gem 'equivalent-xml',     '~>0.2.9', :require => false\n  gem 'rspec-hal',          '~>1.4'\n\n  gem 'cucumber_html_table_steps', :git => \"git@github.comverge.com:software/cucumber_html_table_steps.git\", :tag => \"v0.0.1\", :require => false\n\n  gem 'timecop'\n  gem \"rspec-instafail\",    '~>0.2.4', :require => 'rspec/instafail'\n\n  gem \"mail\",               '~>2.2'\n  gem \"email_spec\",         '~>1.2.1'\n  gem \"ci_reporter\",        '=1.7.2'\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":128,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[{"patches":[{"oldRange":[[75,0],[75,0]],"newRange":[[75,0],[77,0]],"oldText":"","newText":"gem 'faker'\n\n","normalizeLineEndings":false,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"}],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/intellisource/apollo/Gemfile","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"1b0e9396c103f260e210ef4676c15b24fb4e3140","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":32,"softTabs":true,"displayBuffer":{"id":33,"softWrapped":false,"editorWidthInChars":null,"scrollTop":899,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/intellisource/apollo/spec/models/basic_status_payload_parser_spec.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":42,"softTabs":true,"displayBuffer":{"id":43,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/intellisource/common/app/models/control_event.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":86,"softTabs":true,"displayBuffer":{"id":87,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/intellisource/common/app/models/control_record.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":90,"softTabs":true,"displayBuffer":{"id":91,"softWrapped":false,"editorWidthInChars":null,"scrollTop":31590,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/intellisource/common/app/models/base_control_event.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":104,"softTabs":true,"displayBuffer":{"id":105,"softWrapped":false,"editorWidthInChars":null,"scrollTop":21343,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/intellisource/common/test/factories/factories.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":128,"softTabs":true,"displayBuffer":{"id":129,"softWrapped":false,"editorWidthInChars":null,"scrollTop":2,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/intellisource/apollo/Gemfile","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":54,"softTabs":true,"displayBuffer":{"id":55,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/intellisource/common/app/models/direct_control_rate_contract.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":50,"softTabs":true,"displayBuffer":{"id":51,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/intellisource/common/app/models/rate_contract.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemUri":"/Users/tra/src/intellisource/apollo/Gemfile","focused":false,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-ruby","language-sql","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":"","modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false},"projectViewState":"","resultsModelState":{"useRegex":false,"caseSensitive":false},"findHistory":["meter","active_control_status","trough_reduction","message_logs","nmatrix","NMATRIX","NO_","kmean","for cycle","ADI Control","80456","mv_90","mv","fak"],"replaceHistory":[],"pathsHistory":[]},"fuzzy-finder":{"/Users/tra/src/intellisource/apollo/spec/models/basic_status_payload_parser_spec.rb":1418761358372,"/Users/tra/src/intellisource/common/app/models/control_event.rb":1418763892167,"/Users/tra/src/intellisource/common/app/models/control_record.rb":1418765867111,"/Users/tra/src/intellisource/common/app/models/base_control_event.rb":1423084663726,"/Users/tra/src/intellisource/common/test/factories/factories.rb":1423084670189,"/Users/tra/src/intellisource/apollo/Gemfile":1423086561723,"/Users/tra/src/intellisource/common/app/models/direct_control_rate_contract.rb":1418763889494,"/Users/tra/src/intellisource/common/app/models/rate_contract.rb":1418762693036},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":507100276},"tree-view":{"directoryExpansionStates":{"apollo":{}},"selectedPath":"/Users/tra/src/intellisource/apollo/Gemfile","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}