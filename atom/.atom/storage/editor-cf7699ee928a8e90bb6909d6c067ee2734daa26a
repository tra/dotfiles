{"mode":"editor","version":1,"windowDimensions":{"x":258,"y":81,"width":1878,"height":1362,"maximized":false},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/tra/src/R","buffers":[{"text":".onAttach <- function(lib, pkg)\n{\n   vers <- library(help=gbm)$info[[1]]\n   vers <- vers[grep(\"Version:\",vers)]\n   vers <- rev(strsplit(vers,\" \")[[1]])[1]\n   packageStartupMessage(paste(\"Loaded gbm\",vers))\n}\n\ngbm <- function(formula = formula(data),\n                distribution = \"bernoulli\",\n                data = list(),\n                weights,\n                var.monotone = NULL,\n                n.trees = 100,\n                interaction.depth = 1,\n                n.minobsinnode = 10,\n                shrinkage = 0.001,\n                bag.fraction = 0.5,\n                train.fraction = 1.0,\n                cv.folds=0,\n                keep.data = TRUE,\n                verbose = 'CV',\n                class.stratify.cv=NULL,\n                n.cores=NULL){\n   theCall <- match.call()\n\n\n   lVerbose <- if (!is.logical(verbose)) { FALSE }\n               else { verbose }\n\n   mf <- match.call(expand.dots = FALSE)\n   m <- match(c(\"formula\", \"data\", \"weights\", \"offset\"), names(mf), 0)\n   mf <- mf[c(1, m)]\n   mf$drop.unused.levels <- TRUE\n   mf$na.action <- na.pass\n   mf[[1]] <- as.name(\"model.frame\")\n   m <- mf\n   mf <- eval(mf, parent.frame())\n   Terms <- attr(mf, \"terms\")\n\n   y <- model.response(mf)\n\n   if (missing(distribution)){ distribution <- guessDist(y) }\n   else if (is.character(distribution)){ distribution <- list(name=distribution) }\n\n   w <- model.weights(mf)\n   offset <- model.offset(mf)\n\n   var.names <- attributes(Terms)$term.labels\n   x <- model.frame(terms(reformulate(var.names)),\n                    data,\n                    na.action=na.pass)\n\n   # get the character name of the response variable\n   response.name <- as.character(formula[[2]])\n\n   lVerbose <- if (!is.logical(verbose)) { FALSE }\n               else { verbose }\n\n   class.stratify.cv <- getStratify(class.stratify.cv, distribution)\n\n   # groups (for pairwise distribution only)\n   group      <- NULL\n   num.groups <- 0\n\n   # determine number of training instances\n   if (distribution$name != \"pairwise\"){\n      nTrain <- floor(train.fraction * nrow(x))\n   }\n   else {\n      # distribution$name == \"pairwise\":\n      # Sampling is by group, so we need to calculate them here\n      distribution.group <- distribution[[\"group\"]]\n      if (is.null(distribution.group))\n      {\n         stop(\"For pairwise regression, the distribution parameter must be a list with a parameter 'group' for the a list of the column names indicating groups, for example list(name=\\\"pairwise\\\",group=c(\\\"date\\\",\\\"session\\\",\\\"category\\\",\\\"keywords\\\")).\")\n      }\n\n      # Check if group names are valid\n      i <- match(distribution.group, colnames(data))\n      if (any(is.na(i)))\n      {\n         stop(\"Group column does not occur in data: \", distribution.group[is.na(i)])\n      }\n\n      # Construct group index\n      group <- factor(do.call(paste, c(data[,distribution.group, drop=FALSE], sep=\":\")))\n\n      # Check that weights are constant across groups\n      if ((!missing(weights)) && (!is.null(weights)))\n      {\n         w.min <- tapply(w, INDEX=group, FUN=min)\n         w.max <- tapply(w, INDEX=group, FUN=max)\n\n         if (any(w.min != w.max))\n         {\n            stop(\"For distribution 'pairwise', all instances for the same group must have the same weight\")\n         }\n\n         # Normalize across groups\n         w <- w * length(w.min) / sum(w.min)\n      }\n\n      # Shuffle groups, to remove bias when splitting into train/test set and/or CV folds\n      perm.levels  <- levels(group)[sample(1:nlevels(group))]\n      group        <- factor(group, levels=perm.levels)\n\n      # The C function expects instances to be sorted by group and descending by target\n      ord.group    <- order(group, -y)\n      group        <- group[ord.group]\n      y            <- y[ord.group]\n      x            <- x[ord.group,,drop=FALSE]\n      w            <- w[ord.group]\n\n      # Split into train and validation set, at group boundary\n      num.groups.train <- max(1, round(train.fraction * nlevels(group)))\n\n      # include all groups up to the num.groups.train\n      nTrain           <- max(which(group==levels(group)[num.groups.train]))\n      Misc             <- group\n   } # close if(distribution$name==\"coxph\") ...\n\n   cv.error <- NULL\n   if(cv.folds>1) {\n     cv.results <- gbmCrossVal(cv.folds, nTrain, n.cores,\n                               class.stratify.cv, data,\n                               x, y, offset, distribution, w, var.monotone,\n                               n.trees, interaction.depth, n.minobsinnode,\n                               shrinkage, bag.fraction,\n                               var.names, response.name, group)\n     cv.error <- cv.results$error\n     p <- cv.results$predictions\n   } # Close if(cv.folds > 1\n\n   gbm.obj <- gbm.fit(x,y,\n                      offset = offset,\n                      distribution = distribution,\n                      w = w,\n                      var.monotone = var.monotone,\n                      n.trees = n.trees,\n                      interaction.depth = interaction.depth,\n                      n.minobsinnode = n.minobsinnode,\n                      shrinkage = shrinkage,\n                      bag.fraction = bag.fraction,\n                      nTrain = nTrain,\n                      keep.data = keep.data,\n                      verbose = lVerbose,\n                      var.names = var.names,\n                      response.name = response.name,\n                      group = group)\n\n   gbm.obj$train.fraction <- train.fraction\n   gbm.obj$Terms <- Terms\n   gbm.obj$cv.error <- cv.error\n   gbm.obj$cv.folds <- cv.folds\n   gbm.obj$call <- theCall\n   gbm.obj$m <- m\n   if (cv.folds > 1){ gbm.obj$cv.fitted <- p }\n\n   if (distribution$name == \"pairwise\")\n   {\n      # Data has been reordered according to queries.\n      # We need to permute the fitted values to correspond\n      # to the original order.\n      gbm.obj$ord.group <- ord.group\n      gbm.obj$fit <- gbm.obj$fit[order(ord.group)]\n   }\n\n   return(gbm.obj)\n}\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":4},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/R/gradientboostedmodels/gbm/R/gbm.R","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"a664531276c4383e5224e4e68c8b3d340fe9a102","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":4,"softTabs":true,"displayBuffer":{"id":5,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/R/gradientboostedmodels/gbm/R/gbm.R","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemUri":"/Users/tra/src/R/gradientboostedmodels/gbm/R/gbm.R","focused":false,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":"","modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false},"projectViewState":"","resultsModelState":{"useRegex":false,"caseSensitive":false},"findHistory":["require"],"replaceHistory":[],"pathsHistory":[]},"fuzzy-finder":{"/Users/tra/src/R/gradientboostedmodels/gbm/R/gbm.R":1424975053968},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":612035756},"tree-view":{"directoryExpansionStates":{"gradientboostedmodels":{"gbm":{"R":{},"src":{}}}},"selectedPath":"/Users/tra/src/R/gradientboostedmodels/gbm/R/gbm.R","hasFocus":false,"attached":true,"scrollLeft":35,"scrollTop":21,"width":200}}}