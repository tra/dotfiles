{"mode":"editor","version":1,"windowDimensions":{"x":478,"y":71,"width":1856,"height":1359},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/tra/github/cequel","buffers":[{"text":"# -*- encoding : utf-8 -*-\nrequire File.expand_path('../spec_helper', __FILE__)\n\ndescribe Cequel::Record::Map do\n  model :Post do\n    key :permalink, :text\n    column :title, :text\n    map :likes, :text, :int\n  end\n\n  let(:scope) { cequel[Post.table_name].where(:permalink => 'cequel') }\n  subject { scope.first }\n\n  let! :post do\n    Post.new do |post|\n      post.permalink = 'cequel'\n      # post.likes = {'alice' => 1, 'bob' => 2}\n    end.tap(&:save)\n  end\n\n  let! :unloaded_post do\n    Post['cequel']\n  end\n\n  context 'new record' do\n    it 'should save set as-is' do\n      subject[:likes].should == {'alice' => 1, 'bob' => 2}\n    end\n  end\n\n  context 'updating' do\n    it 'should overwrite value' do\n      post.likes.clear\n      post.likes.replace({'charlotte' => 3, 'dave' => 4})\n      post.save!\n      cequel[Post.table_name].where(:permalink => 'cequel').first[:likes].should == {'charlotte' => 3, 'dave' => 4}\n      # subject[:likes].should == {'charlotte' => 3, 'dave' => 4}\n    end\n\n    it 'should cast collection before overwriting' do\n      post.likes = [['charlotte', 3], ['dave', 4]]\n      post.save!\n      subject[:likes].should == {'charlotte' => 3, 'dave' => 4}\n    end\n  end\n\n  describe 'atomic modification' do\n    before { scope.map_update(:likes, 'charles' => 3) }\n\n    describe '#[]=' do\n      it 'should atomically update' do\n        post.likes['david'] = 4\n        post.save\n        subject[:likes].should ==\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4}\n        expect(post.likes).to eq({'alice' => 1, 'bob' => 2, 'david' => 4})\n      end\n\n      it 'should cast keys when updating' do\n        post.likes[:david] = 4\n        expect(post.likes).to eq({'alice' => 1, 'bob' => 2, 'david' => 4})\n      end\n\n      it 'should cast values when updating' do\n        post.likes['david'] = 4.0\n        expect(post.likes).to eq({'alice' => 1, 'bob' => 2, 'david' => 4})\n      end\n\n      it 'should write without reading' do\n        max_statements! 2\n        unloaded_post.likes['david'] = 4\n        unloaded_post.save\n        subject[:likes].should ==\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4}\n      end\n\n      it 'should set key value post-hoc' do\n        unloaded_post.likes['david'] = 4\n        expect(unloaded_post.likes).to eq(\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4})\n      end\n    end\n\n    describe '#clear' do\n      it 'should atomically clear' do\n        post.likes.clear\n        post.save\n        subject[:likes].should be_blank\n        expect(post.likes).to eq({})\n      end\n\n      it 'should clear without reading' do\n        max_statements! 2\n        unloaded_post.likes.clear\n        unloaded_post.save\n        subject[:likes].should be_blank\n      end\n\n      it 'should clear post-hoc' do\n        unloaded_post.likes.clear\n        unloaded_post.likes.should be_blank\n      end\n    end\n\n    describe '#delete' do\n      it 'should delete element atomically' do\n        post.likes.delete('bob')\n        post.save\n        subject[:likes].should == {'alice' => 1, 'charles' => 3}\n        expect(post.likes).to eq({'alice' => 1})\n      end\n\n      it 'should cast key before deleting' do\n        post.likes.delete(:bob)\n        expect(post.likes).to eq({'alice' => 1})\n      end\n\n      it 'should delete without reading' do\n        max_statements! 2\n        unloaded_post.likes.delete('bob')\n        unloaded_post.save\n        subject[:likes].should == {'alice' => 1, 'charles' => 3}\n      end\n\n      it 'should delete post-hoc' do\n        unloaded_post.likes.delete('bob')\n        expect(unloaded_post.likes).to eq({'alice' => 1, 'charles' => 3})\n      end\n    end\n\n    describe '#merge!' do\n      it 'should atomically update' do\n        post.likes.merge!('david' => 4, 'emily' => 5)\n        post.save\n        subject[:likes].should ==\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4, 'emily' => 5}\n        expect(post.likes).to eq(\n          {'alice' => 1, 'bob' => 2, 'david' => 4, 'emily' => 5})\n      end\n\n      it 'should cast keys before updating' do\n        post.likes.merge!(david: 4, emily: 5)\n        post.save\n        expect(post.likes).to eq(\n          {'alice' => 1, 'bob' => 2, 'david' => 4, 'emily' => 5})\n      end\n\n      it 'should cast values before updating' do\n        post.likes.merge!('david' => '4', 'emily' => 5.0)\n        post.save\n        subject[:likes].should ==\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4, 'emily' => 5}\n        expect(post.likes).to eq(\n          {'alice' => 1, 'bob' => 2, 'david' => 4, 'emily' => 5})\n      end\n\n      it 'should write without reading' do\n        max_statements! 2\n        unloaded_post.likes.merge!('david' => 4, 'emily' => 5)\n        unloaded_post.save\n        subject[:likes].should ==\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4, 'emily' => 5}\n      end\n\n      it 'should merge post-hoc' do\n        unloaded_post.likes.merge!('david' => 4, 'emily' => 5)\n        expect(unloaded_post.likes).to eq(\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4, 'emily' => 5})\n      end\n    end\n\n    describe '#replace' do\n      it 'should automatically overwrite' do\n        post.likes.replace('david' => 4, 'emily' => 5)\n        post.save\n        subject[:likes].should == {'david' => 4, 'emily' => 5}\n        expect(post.likes).to eq({'david' => 4, 'emily' => 5})\n      end\n\n      it 'should cast keys before overwriting' do\n        post.likes.replace(david: 4, emily: 5)\n        expect(post.likes).to eq({'david' => 4, 'emily' => 5})\n      end\n\n      it 'should cast values before overwriting' do\n        post.likes.replace('david' => '4', 'emily' => 5.0)\n        post.save\n        subject[:likes].should == {'david' => 4, 'emily' => 5}\n        expect(post.likes).to eq({'david' => 4, 'emily' => 5})\n      end\n\n      it 'should overwrite without reading' do\n        max_statements! 2\n        unloaded_post.likes.replace('david' => 4, 'emily' => 5)\n        unloaded_post.save\n        subject[:likes].should == {'david' => 4, 'emily' => 5}\n      end\n\n      it 'should replace post-hoc' do\n        unloaded_post.likes.replace('david' => 4, 'emily' => 5)\n        expect(unloaded_post.likes).to eq({'david' => 4, 'emily' => 5})\n      end\n    end\n\n    describe '#store' do\n      it 'should atomically update' do\n        post.likes.store('david', 4)\n        post.save\n        subject[:likes].should ==\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4}\n        expect(post.likes).to eq({'alice' => 1, 'bob' => 2, 'david' => 4})\n      end\n\n      it 'should write without reading' do\n        max_statements! 2\n        unloaded_post.likes.store('david', 4)\n        unloaded_post.save\n        subject[:likes].should ==\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4}\n      end\n\n      it 'should store post-hoc' do\n        unloaded_post.likes.store('david', 4)\n        expect(unloaded_post.likes).to eq(\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4})\n      end\n    end\n\n    describe '#update' do\n      it 'should atomically update' do\n        post.likes.update('david' => 4, 'emily' => 5)\n        post.save\n        subject[:likes].should ==\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4, 'emily' => 5}\n        expect(post.likes).to eq(\n          {'alice' => 1, 'bob' => 2, 'david' => 4, 'emily' => 5})\n      end\n\n      it 'should write without reading' do\n        max_statements! 2\n        unloaded_post.likes.update('david' => 4, 'emily' => 5)\n        unloaded_post.save\n        subject[:likes].should ==\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4, 'emily' => 5}\n      end\n\n      it 'should update post-hoc' do\n        unloaded_post.likes.update('david' => 4, 'emily' => 5)\n        expect(unloaded_post.likes).to eq(\n          {'alice' => 1, 'bob' => 2, 'charles' => 3, 'david' => 4, 'emily' => 5})\n      end\n    end\n\n    specify { expect { post.likes.default }.to raise_error(NoMethodError) }\n    specify { expect { post.likes.default = 1 }.to raise_error(NoMethodError) }\n    specify { expect { post.likes.default_proc }.to raise_error(NoMethodError) }\n    specify { expect { post.likes.default_proc = -> k, v { Time.now }}.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.delete_if { |k, v| v.even? }}.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.deep_merge!('alice' => 5) }.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.except!('alice') }.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.extract!('alice') }.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.transform_keys!(&:upcase) }.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.keep_if { |k, v| v.even? }}.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.reject! { |k, v| v.even? }}.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.reverse_merge!('alice' => 3) }.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.reverse_update('alice' => 3) }.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.select! { |k, v| v.even? }}.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.shift }.to raise_error(NoMethodError) }\n    specify { expect { post.likes.stringify_keys! }.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.symbolize_keys! }.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.to_options! }.\n      to raise_error(NoMethodError) }\n    specify { expect { post.likes.slice!('alice') }.\n      to raise_error(NoMethodError) }\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[32,0],[32,0]],"tailed":false,"reversed":true,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":56,"goalBufferRange":null},"deserializer":"Marker"},"2":{"id":2,"range":[[35,65],[35,72]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"},"3":{"id":3,"range":[[33,24],[33,25]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[{"patches":[{"oldRange":[[16,6],[16,6]],"newRange":[[16,6],[16,8]],"oldText":"","newText":"# ","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[240,33],[240,34]],"newRange":[[240,33],[240,33]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[230,33],[230,34]],"newRange":[[230,33],[230,33]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[215,33],[215,34]],"newRange":[[215,33],[215,33]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[206,33],[206,34]],"newRange":[[206,33],[206,33]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[148,33],[148,34]],"newRange":[[148,33],[148,33]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[132,33],[132,34]],"newRange":[[132,33],[132,33]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[51,33],[51,34]],"newRange":[[51,33],[51,33]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[33,16],[33,16]],"newRange":[[33,16],[34,0]],"oldText":"","newText":"\n","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[34,0],[34,0]],"newRange":[[34,0],[34,6]],"oldText":"","newText":"      ","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,6],[34,6]],"newRange":[[34,6],[34,59]],"oldText":"","newText":"cequel[Post.table_name].where(:permalink => 'cequel')","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,59],[34,59]],"newRange":[[34,59],[34,60]],"oldText":"","newText":".","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,60],[34,60]],"newRange":[[34,60],[34,61]],"oldText":"","newText":"f","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,61],[34,61]],"newRange":[[34,61],[34,62]],"oldText":"","newText":"i","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,62],[34,62]],"newRange":[[34,62],[34,63]],"oldText":"","newText":"r","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,63],[34,63]],"newRange":[[34,63],[34,64]],"oldText":"","newText":"s","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,64],[34,64]],"newRange":[[34,64],[34,65]],"oldText":"","newText":"t","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,65],[34,65]],"newRange":[[34,65],[34,66]],"oldText":"","newText":".","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,66],[34,66]],"newRange":[[34,66],[34,67]],"oldText":"","newText":"l","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,67],[34,67]],"newRange":[[34,67],[34,68]],"oldText":"","newText":"i","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,68],[34,68]],"newRange":[[34,68],[34,69]],"oldText":"","newText":"k","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,69],[34,69]],"newRange":[[34,69],[34,70]],"oldText":"","newText":"e","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,70],[34,70]],"newRange":[[34,70],[34,71]],"oldText":"","newText":"s","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,71],[34,71]],"newRange":[[34,71],[34,72]],"oldText":"","newText":".","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,72],[34,72]],"newRange":[[34,72],[34,73]],"oldText":"","newText":"s","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,73],[34,73]],"newRange":[[34,73],[34,74]],"oldText":"","newText":"h","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,74],[34,74]],"newRange":[[34,74],[34,75]],"oldText":"","newText":"o","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,75],[34,75]],"newRange":[[34,75],[34,76]],"oldText":"","newText":"u","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,76],[34,76]],"newRange":[[34,76],[34,77]],"oldText":"","newText":"l","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,77],[34,77]],"newRange":[[34,77],[34,78]],"oldText":"","newText":"d","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,78],[34,78]],"newRange":[[34,78],[34,79]],"oldText":"","newText":" ","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,79],[34,79]],"newRange":[[34,79],[34,80]],"oldText":"","newText":"=","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,80],[34,80]],"newRange":[[34,80],[34,81]],"oldText":"","newText":"=","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,81],[34,81]],"newRange":[[34,81],[34,82]],"oldText":"","newText":" ","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[35,32],[35,32]]},"newParams":{"range":[[35,32],[35,63]]},"deserializer":"MarkerPatch"},{"oldRange":[[35,32],[35,63]],"newRange":[[35,32],[35,32]],"oldText":"{'charlotte' => 3, 'dave' => 4}","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[35,32],[35,32]],"newRange":[[35,32],[35,63]],"oldText":"","newText":"{'charlotte' => 3, 'dave' => 4}","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,82],[34,82]],"newRange":[[34,82],[34,113]],"oldText":"","newText":"{'charlotte' => 3, 'dave' => 4}","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[35,6],[35,6]],"newRange":[[35,6],[35,8]],"oldText":"","newText":"# ","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,65],[34,65]],"newRange":[[34,65],[34,67]],"oldText":"","newText":"[]","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,66],[34,66]],"newRange":[[34,66],[34,67]],"oldText":"","newText":":","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,67],[34,67]],"newRange":[[34,67],[34,68]],"oldText":"","newText":"l","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,68],[34,68]],"newRange":[[34,68],[34,69]],"oldText":"","newText":"i","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,69],[34,69]],"newRange":[[34,69],[34,70]],"oldText":"","newText":"k","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,70],[34,70]],"newRange":[[34,70],[34,71]],"oldText":"","newText":"e","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[34,71],[34,71]],"newRange":[[34,71],[34,72]],"oldText":"","newText":"s","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[34,73],[34,73]]},"newParams":{"range":[[34,73],[34,74]]},"deserializer":"MarkerPatch"},{"oldRange":[[34,73],[34,74]],"newRange":[[34,73],[34,73]],"oldText":".","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[34,73],[34,73]]},"newParams":{"range":[[34,73],[34,74]]},"deserializer":"MarkerPatch"},{"oldRange":[[34,73],[34,74]],"newRange":[[34,73],[34,73]],"oldText":"l","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[34,73],[34,73]]},"newParams":{"range":[[34,73],[34,74]]},"deserializer":"MarkerPatch"},{"oldRange":[[34,73],[34,74]],"newRange":[[34,73],[34,73]],"oldText":"i","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[34,73],[34,73]]},"newParams":{"range":[[34,73],[34,74]]},"deserializer":"MarkerPatch"},{"oldRange":[[34,73],[34,74]],"newRange":[[34,73],[34,73]],"oldText":"k","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[34,73],[34,73]]},"newParams":{"range":[[34,73],[34,74]]},"deserializer":"MarkerPatch"},{"oldRange":[[34,73],[34,74]],"newRange":[[34,73],[34,73]],"oldText":"e","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[34,73],[34,73]]},"newParams":{"range":[[34,73],[34,74]]},"deserializer":"MarkerPatch"},{"oldRange":[[34,73],[34,74]],"newRange":[[34,73],[34,73]],"oldText":"s","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,16],[32,16]],"newRange":[[32,16],[32,17]],"oldText":"","newText":".","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,17],[32,17]],"newRange":[[32,17],[32,18]],"oldText":"","newText":"r","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,18],[32,18]],"newRange":[[32,18],[32,19]],"oldText":"","newText":"e","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,19],[32,19]],"newRange":[[32,19],[32,20]],"oldText":"","newText":"p","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,20],[32,20]],"newRange":[[32,20],[32,21]],"oldText":"","newText":"l","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,21],[32,21]],"newRange":[[32,21],[32,22]],"oldText":"","newText":"a","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,22],[32,22]],"newRange":[[32,22],[32,23]],"oldText":"","newText":"c","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,23],[32,23]],"newRange":[[32,23],[32,24]],"oldText":"","newText":"e","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[32,24],[32,24]]},"newParams":{"range":[[32,24],[32,25]]},"deserializer":"MarkerPatch"},{"oldRange":[[32,24],[32,25]],"newRange":[[32,24],[32,24]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[32,24],[32,24]]},"newParams":{"range":[[32,24],[32,25]]},"deserializer":"MarkerPatch"},{"oldRange":[[32,24],[32,25]],"newRange":[[32,24],[32,24]],"oldText":"=","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[32,24],[32,24]]},"newParams":{"range":[[32,24],[32,25]]},"deserializer":"MarkerPatch"},{"oldRange":[[32,24],[32,25]],"newRange":[[32,24],[32,24]],"oldText":" ","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,24],[32,24]],"newRange":[[32,24],[32,26]],"oldText":"","newText":"()","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[32,25],[32,25]]},"newParams":{"range":[[32,25],[32,26]]},"deserializer":"MarkerPatch"},{"oldRange":[[32,25],[32,26]],"newRange":[[32,25],[32,25]],"oldText":")","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,56],[32,56]],"newRange":[[32,56],[32,57]],"oldText":"","newText":")","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[31,34],[31,34]],"newRange":[[31,34],[32,0]],"oldText":"","newText":"\n","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[32,0],[32,0]],"newRange":[[32,0],[32,6]],"oldText":"","newText":"      ","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,6],[32,6]],"newRange":[[32,6],[32,7]],"oldText":"","newText":"p","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,7],[32,7]],"newRange":[[32,7],[32,8]],"oldText":"","newText":"o","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,8],[32,8]],"newRange":[[32,8],[32,9]],"oldText":"","newText":"s","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,9],[32,9]],"newRange":[[32,9],[32,10]],"oldText":"","newText":"t","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,10],[32,10]],"newRange":[[32,10],[32,11]],"oldText":"","newText":".","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,11],[32,11]],"newRange":[[32,11],[32,12]],"oldText":"","newText":"l","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,12],[32,12]],"newRange":[[32,12],[32,13]],"oldText":"","newText":"i","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,13],[32,13]],"newRange":[[32,13],[32,14]],"oldText":"","newText":"k","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,14],[32,14]],"newRange":[[32,14],[32,15]],"oldText":"","newText":"e","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,15],[32,15]],"newRange":[[32,15],[32,16]],"oldText":"","newText":"s","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,16],[32,16]],"newRange":[[32,16],[32,17]],"oldText":"","newText":".","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,17],[32,17]],"newRange":[[32,17],[32,18]],"oldText":"","newText":"c","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,18],[32,18]],"newRange":[[32,18],[32,19]],"oldText":"","newText":"l","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,19],[32,19]],"newRange":[[32,19],[32,20]],"oldText":"","newText":"e","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,20],[32,20]],"newRange":[[32,20],[32,21]],"oldText":"","newText":"a","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,21],[32,21]],"newRange":[[32,21],[32,22]],"oldText":"","newText":"r","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[32,0],[32,0]],"newRange":[[32,0],[32,1]],"oldText":"","newText":"#","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"reversed":false,"range":[[32,1],[32,1]]},"newParams":{"reversed":true,"range":[[32,0],[32,1]]},"deserializer":"MarkerPatch"},{"oldRange":[[32,0],[32,1]],"newRange":[[32,0],[32,0]],"oldText":"#","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"tailed":true},"newParams":{"tailed":false},"deserializer":"MarkerPatch"}],"deserializer":"Transaction"}],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/cequel/spec/examples/record/map_spec.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"7246a9d10c76f0d856772dac7eb4a4063b03182f","deserializer":"TextBuffer"},{"text":"# -*- encoding : utf-8 -*-\nmodule Cequel\n  module SpecSupport\n    module Macros\n      def model(class_name, options = {}, &block)\n        return if RSpec.configuration.filter_manager.exclude?(self)\n        setup_models = !self.metadata.key?(:models)\n        self.metadata[:models] ||= {}\n\n        metadata[:models][class_name] = [options, block]\n\n        if setup_models\n          before :all do\n            metadata = self.class.metadata\n            metadata[:models].each do |name, (options, block)|\n              clazz = Class.new do\n                include Cequel::Record\n                self.table_name = name.to_s.tableize + \"_\" + SecureRandom.hex(4)\n                class_eval(&block)\n              end\n              Object.module_eval { const_set(name, clazz) }\n            end\n            metadata[:models].each_key do |name|\n              if options.fetch(:synchronize_schema, true)\n                Object.const_get(name).synchronize_schema\n              end\n            end\n          end\n\n          before :each do\n            metadata = self.class.metadata\n            metadata[:models].each_key do |name|\n              name.to_s.constantize.find_each(&:destroy)\n            end\n          end\n\n          after :all do\n            self.class.metadata[:models].each_key do |name|\n              cequel.schema.drop_table(Object.const_get(name).table_name)\n              Object.module_eval { remove_const(name) }\n            end\n          end\n        end\n      end\n\n      def uuid(name)\n        let(name) { Cequel.uuid }\n      end\n    end\n\n    module Helpers\n\n      def self.cequel\n        @cequel ||= Cequel.connect(\n          host: host,\n          port: port,\n          keyspace: keyspace_name\n        ).tap do |cequel|\n          if ENV['CEQUEL_LOG_QUERIES']\n            cequel.logger = Logger.new(STDOUT)\n          else\n            cequel.logger = Logger.new(File.open('/dev/null', 'a'))\n          end\n        end\n      end\n\n      def self.host\n        '127.0.0.1'\n      end\n\n      def self.port\n        ENV['CEQUEL_TEST_PORT'] || '9042'\n      end\n\n      def self.legacy_host\n        ENV['CEQUEL_TEST_LEGACY_HOST'] || '127.0.0.1:9160'\n      end\n\n      def self.keyspace_name\n        ENV['CEQUEL_TEST_KEYSPACE'] || 'cequel_test'\n      end\n\n      def self.legacy_connection\n        require 'cassandra-cql'\n        @legacy_connection ||= CassandraCQL::Database.new(\n          legacy_host,\n          :keyspace => keyspace_name,\n          :cql_version => '2.0.0'\n        )\n      end\n\n      def min_uuid(time = Time.now)\n        Cql::TimeUuid::Generator.new(0, 0).from_time(time, 0)\n      end\n\n      def max_uuid(time = Time.now)\n        Cql::TimeUuid::Generator.new(0x3fff, 0xffffffffffff).\n          from_time(time, 999)\n      end\n\n      def cequel\n        Helpers.cequel\n      end\n\n      def legacy_connection\n        Helpers.legacy_connection\n      end\n\n      def max_statements!(number)\n        cequel.client.should_receive(:execute).at_most(number).times.and_call_original\n      end\n\n      def disallow_queries!\n        cequel.client.should_not_receive(:execute)\n      end\n\n      def expect_query_with_consistency(matcher, consistency)\n        expect(cequel.client).to receive(:execute).with(matcher, consistency)\n          .and_call_original\n        yield\n        RSpec::Mocks.proxy_for(cequel.client).reset\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[58,18],[58,36]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":109,"autoscroll":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/cequel/spec/support/helpers.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"ed2a385b51c38b0401e9efd21399580c89eb7592","deserializer":"TextBuffer"},{"text":"# -*- encoding : utf-8 -*-\nmodule Cequel\n  module Record\n    #\n    # This module provides functionality for loading and saving records to the\n    # Cassandra database.\n    #\n    # @see ClassMethods\n    #\n    # @since 0.1.0\n    #\n    module Persistence\n      extend ActiveSupport::Concern\n      extend Forwardable\n\n      #\n      # Class-level functionality for loading and saving records\n      #\n      module ClassMethods\n        extend Forwardable\n\n        #\n        # Initialize a new record instance, assign attributes, and immediately\n        # save it.\n        #\n        # @param attributes [Hash] attributes to assign to the new record\n        # @yieldparam record [Record] record to make modifications before\n        #   saving\n        # @return [Record] self\n        #\n        # @example Create a new record with attribute assignment\n        #   Post.create(\n        #     blog_subdomain: 'cassandra',\n        #     permalink: 'cequel',\n        #     title: 'Cequel: The Next Generation'\n        #   )\n        #\n        # @example Create a new record with a block\n        #   Post.create do |post|\n        #     post.blog = blog\n        #     post.permalink = 'cequel'\n        #     post.title = 'Cequel: The Next Generation'\n        #   end\n        #\n        def create(attributes = {}, &block)\n          new(attributes, &block).tap { |record| record.save }\n        end\n\n        # @private\n        def table\n          connection[table_name]\n        end\n\n        # @return [Cequel::Record] a new instance of this record class\n        # populated with the attributes from `row`\n        #\n        # @param row [Hash] attributes from the database with which\n        #   the new instance should be populated.\n        #\n        # @private\n        def hydrate(row)\n          new_empty.hydrate(row)\n        end\n\n        # @private\n        def_delegator 'Cequel::Record', :connection\n      end\n\n      #\n      # @return [Hash] the attributes of this record that make up the primary\n      #   key\n      #\n      # @example\n      #   post = Post.new\n      #   post.blog_subdomain = 'cassandra'\n      #   post.permalink = 'cequel'\n      #   post.title = 'Cequel: The Next Generation'\n      #   post.key_attributes\n      #     #=> {:blog_subdomain=>'cassandra', :permalink=>'cequel'}\n      #\n      # @since 1.0.0\n      #\n      def key_attributes\n        @attributes.slice(*self.class.key_column_names)\n      end\n\n      #\n      # @return [Array] the values of the primary key columns for this record\n      #\n      # @see #key_attributes\n      # @since 1.0.0\n      #\n      def key_values\n        key_attributes.values\n      end\n      alias_method :to_key, :key_values\n\n      #\n      # Check if an unloaded record exists in the database\n      #\n      # @return  `true` if the record has a corresponding row in the\n      #   database\n      #\n      # @since 1.0.0\n      #\n      def exists?\n        load!\n        true\n      rescue RecordNotFound\n        false\n      end\n      alias_method :exist?, :exists?\n\n      #\n      # Load an unloaded record's row from the database and hydrate the\n      # record's attributes\n      #\n      # @return [Record] self\n      #\n      # @since 1.0.0\n      #\n      def load\n        assert_keys_present!\n        record_collection.load! unless loaded?\n        self\n      end\n\n      #\n      # Attempt to load an unloaded record and raise an error if the record\n      # does not correspond to a row in the database\n      #\n      # @return [Record] self\n      # @raise [RecordNotFound] if row does not exist in the database\n      #\n      # @see #load\n      # @since 1.0.0\n      #\n      def load!\n        load.tap do\n          if transient?\n            fail RecordNotFound,\n                 \"Couldn't find #{self.class.name} with \" \\\n                 \"#{key_attributes.inspect}\"\n          end\n        end\n      end\n\n      #\n      # @overload loaded?\n      #   @return [Boolean] true if this record's attributes have been loaded\n      #     from the database\n      #\n      # @overload loaded?(column)\n      #   @param [Symbol] column name of column to check if loaded\n      #   @return [Boolean] true if the named column is loaded in memory\n      #\n      # @return [Boolean]\n      #\n      # @since 1.0.0\n      #\n      def loaded?(column = nil)\n        !!@loaded && (column.nil? || @attributes.key?(column.to_sym))\n      end\n\n      #\n      # Persist the record to the database. If this is a new record, it will\n      # be saved using an INSERT statement. If it is an existing record, it\n      # will be persisted using a series of `UPDATE` and `DELETE` statements\n      # which will persist all changes to the database, including atomic\n      # collection modifications.\n      #\n      # @param options [Options] options for save\n      # @option options [Boolean] :validate (true) whether to run validations\n      #   before saving\n      # @option options [Symbol] :consistency (:quorum) what consistency with\n      #   which to persist the changes\n      # @option options [Integer] :ttl time-to-live of the updated rows in\n      #   seconds\n      # @option options [Time] :timestamp the writetime to use for the column\n      #   updates\n      # @return [Boolean] true if record saved successfully, false if invalid\n      #\n      # @see Validations#save!\n      #\n      def save(options = {})\n        options.assert_valid_keys(:consistency, :ttl, :timestamp)\n        if new_record? then create(options)\n        else update(options)\n        end\n        @new_record = false\n        true\n      end\n\n      #\n      # Set attributes and save the record\n      #\n      # @param attributes [Hash] hash of attributes to update\n      # @return [Boolean] true if saved successfully\n      #\n      # @see #save\n      # @see Properties#attributes=\n      # @see Validations#update_attributes!\n      #\n      def update_attributes(attributes)\n        self.attributes = attributes\n        save\n      end\n\n      #\n      # Remove this record from the database\n      #\n      # @param options [Options] options for deletion\n      # @option options [Symbol] :consistency (:quorum) what consistency with\n      #   which to persist the deletion\n      # @option options [Time] :timestamp the writetime to use for the deletion\n      #\n      # @return [Record] self\n      #\n      def destroy(options = {})\n        options.assert_valid_keys(:consistency, :timestamp)\n        assert_keys_present!\n        metal_scope.delete(options)\n        transient!\n        self\n      end\n\n      #\n      # @return true if this is a new, unsaved record\n      #\n      # @since 1.0.0\n      #\n      def new_record?\n        !!@new_record\n      end\n\n      #\n      # @return true if this record is persisted in the database\n      #\n      # @see #transient?\n      #\n      def persisted?\n        !!@persisted\n      end\n\n      #\n      # @return true if this record is not persisted in the database\n      #\n      # @see persisted?\n      #\n      def transient?\n        !persisted?\n      end\n\n      # @private\n      def hydrate(row)\n        init_attributes(row)\n        hydrated!\n        self\n      end\n\n      protected\n\n      def persisted!\n        @persisted = true\n        self\n      end\n\n      def transient!\n        @persisted = false\n        self\n      end\n\n      def create(options = {})\n        assert_keys_present!\n        metal_scope\n          .insert(attributes.reject { |attr, value| value.nil? }, options)\n        loaded!\n        persisted!\n      end\n\n      def update(options = {})\n        assert_keys_present!\n        connection.batch do\n          updater.execute(options)\n          require 'byebug' ; byebug\n          deleter.execute(options.except(:ttl))\n          @updater, @deleter = nil\n        end\n      end\n\n      def updater\n        @updater ||= Metal::Updater.new(metal_scope)\n      end\n\n      def deleter\n        @deleter ||= Metal::Deleter.new(metal_scope)\n      end\n\n      private\n\n      def_delegators 'self.class', :connection, :table\n      private :connection, :table\n\n      def read_attribute(attribute)\n        super\n      rescue MissingAttributeError\n        load\n        super\n      end\n\n      def write_attribute(name, value)\n        column = self.class.reflect_on_column(name)\n        fail UnknownAttributeError, \"unknown attribute: #{name}\" unless column\n        value = column.cast(value) unless value.nil?\n\n        super.tap do\n          unless new_record?\n            if key_attributes.keys.include?(name)\n              fail ArgumentError,\n                   \"Can't update key #{name} on persisted record\"\n            end\n\n            if value.nil?\n              deleter.delete_columns(name)\n            else\n              updater.set(name => value)\n            end\n          end\n        end\n      end\n\n      def record_collection\n        @record_collection ||=\n          LazyRecordCollection.new(self.class.at(*key_values))\n          .tap { |set| set.__setobj__([self]) }\n      end\n\n      def hydrated!\n        loaded!\n        persisted!\n        self\n      end\n\n      def loaded!\n        @loaded = true\n        collection_proxies.each_value { |collection| collection.loaded! }\n        self\n      end\n\n      def metal_scope\n        table.where(key_attributes)\n      end\n\n      def attributes_for_create\n        @attributes.each_with_object({}) do |(column, value), attributes|\n          attributes[column] = value unless value.nil?\n        end\n      end\n\n      def attributes_for_update\n        @attributes_for_update ||= {}\n      end\n\n      def attributes_for_deletion\n        @attributes_for_deletion ||= []\n      end\n\n      def assert_keys_present!\n        missing_keys = key_attributes.select { |k, v| v.nil? }\n        if missing_keys.any?\n          fail MissingKeyError,\n               \"Missing required key values: #{missing_keys.keys.join(', ')}\"\n        end\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[284,35],[284,35]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":113,"autoscroll":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[{"patches":[{"oldRange":[[283,34],[283,34]],"newRange":[[283,34],[284,0]],"oldText":"","newText":"\n","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[284,0],[284,0]],"newRange":[[284,0],[284,10]],"oldText":"","newText":"          ","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[284,10],[284,10]],"newRange":[[284,10],[284,11]],"oldText":"","newText":"b","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"oldRange":[[284,11],[284,11]],"newRange":[[284,11],[284,12]],"oldText":"","newText":"b","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"},{"patches":[{"id":1,"oldParams":{"tailed":false},"newParams":{"tailed":true},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"range":[[284,12],[284,12]]},"newParams":{"range":[[284,10],[284,12]]},"deserializer":"MarkerPatch"},{"id":1,"oldParams":{"tailed":true,"range":[[284,10],[284,12]]},"newParams":{"tailed":false,"range":[[284,12],[284,12]]},"deserializer":"MarkerPatch"},{"oldRange":[[284,10],[284,12]],"newRange":[[284,10],[284,35]],"oldText":"bb","newText":"require 'byebug' ; byebug","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"}],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/cequel/lib/cequel/record/persistence.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"a126a1c9a2299271eb39e1abf80c2443677d025b","deserializer":"TextBuffer"},{"text":"# -*- encoding : utf-8 -*-\nmodule Cequel\n  module Metal\n    #\n    # DSL for the construction of a DELETE statement comprising multiple\n    # operations (e.g. deleting a column value, deleting an element from a\n    # list, etc.)\n    #\n    #\n    # @note This class should not be instantiated directly\n    # @see DataSet#delete\n    # @see\n    #   http://cassandra.apache.org/doc/cql3/CQL.html#deleteStmt\n    #   CQL documentation for DELETE\n    # @since 1.0.0\n    #\n    class Deleter < Writer\n      #\n      # Delete the entire row or rows matched by the data set\n      #\n      # @return [void]\n      #\n      def delete_row\n        @delete_row = true\n      end\n\n      #\n      # Delete specified columns\n      #\n      # @param columns [Symbol] column names to delete\n      # @return [void]\n      #\n      def delete_columns(*columns)\n        statements.concat(columns)\n      end\n\n      #\n      # Remove elements from a list by position\n      #\n      # @param column [Symbol] name of list column\n      # @param positions [Integer] positions in list from which to delete\n      #   elements\n      # @return [void]\n      #\n      def list_remove_at(column, *positions)\n        statements\n          .concat(positions.map { |position| \"#{column}[#{position}]\" })\n      end\n\n      #\n      # Remote elements from a map by key\n      #\n      # @param column [Symbol] name of map column\n      # @param keys [Object] keys to delete from map\n      # @return [void]\n      #\n      def map_remove(column, *keys)\n        statements.concat(keys.length.times.map { \"#{column}[?]\" })\n        bind_vars.concat(keys)\n      end\n\n      private\n\n      def write_to_statement(statement, options)\n        if @delete_row\n          statement.append(\"DELETE FROM #{table_name}\")\n        elsif statements.empty?\n          fail ArgumentError, \"No targets given for deletion!\"\n        else\n          statement.append(\"DELETE \")\n            .append(statements.join(','), *bind_vars)\n            .append(\" FROM #{table_name}\")\n        end\n        statement.append(generate_upsert_options(options))\n      end\n\n      def empty?\n        super && !@delete_row\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[57,8],[57,18]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":125,"goalBufferRange":null,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/cequel/lib/cequel/metal/deleter.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"363620eb7c197054b33dd57302ea1712868ed422","deserializer":"TextBuffer"},{"text":"# -*- encoding : utf-8 -*-\nrequire 'forwardable'\n\nmodule Cequel\n  module Metal\n    #\n    # Encapsulates a data set, specified as a table and optionally\n    # various query elements.\n    #\n    # @example Data set representing entire contents of a table\n    #   data_set = database[:posts]\n    #\n    # @example Data set limiting rows returned\n    #   data_set = database[:posts].limit(10)\n    #\n    # @example Data set targeting only one partition\n    #   data_set = database[:posts].where(blog_subdomain: 'cassandra')\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#selectStmt\n    #   CQL documentation for SELECT\n    #\n    class DataSet\n      include Enumerable\n      extend Forwardable\n\n      # @return [Keyspace] keyspace that this data set's table resides in\n      attr_reader :keyspace\n      # @return [Symbol] name of the table that this data set retrieves data\n      #   from\n      attr_reader :table_name\n      # @return [Array<Symbol>] columns that this data set restricts result\n      #   rows to; empty if none\n      attr_reader :select_columns\n      # @return [Array<Symbol>] columns that this data set will select the TTLs\n      #   of\n      attr_reader :ttl_columns\n      # @return [Array<Symbol>] columns that this data set will select the\n      #   writetimes of\n      attr_reader :writetime_columns\n      # @return [Array<RowSpecification>] row specifications limiting the\n      #   result rows returned by this data set\n      attr_reader :row_specifications\n      # @return [Hash<Symbol,Symbol>] map of column names to sort directions\n      attr_reader :sort_order\n      # @return [Integer] maximum number of rows to return, `nil` if no limit\n      attr_reader :row_limit\n      # @return [Symbol] what consistency level queries from this data set will\n      #   use\n      # @since 1.1.0\n      attr_reader :query_consistency\n\n      def_delegator :keyspace, :write_with_consistency\n\n      #\n      # @param table_name [Symbol] column family for this data set\n      # @param keyspace [Keyspace] keyspace this data set's table lives in\n      #\n      # @see Keyspace#[]\n      # @api private\n      #\n      def initialize(table_name, keyspace)\n        @table_name, @keyspace = table_name, keyspace\n        @select_columns, @ttl_columns, @writetime_columns, @row_specifications,\n          @sort_order = [], [], [], [], {}\n      end\n\n      #\n      # Insert a row into the column family.\n      #\n      # @param data [Hash] column-value pairs\n      # @param options [Options] options for persisting the row\n      # @option (see Writer#initialize)\n      # @return [void]\n      #\n      # @note `INSERT` statements will succeed even if a row at the specified\n      #   primary key already exists. In this case, column values specified in\n      #   the insert will overwrite the existing row.\n      # @note If a enclosed in a Keyspace#batch block, this method will be\n      #   executed as part of the batch.\n      # @see http://cassandra.apache.org/doc/cql3/CQL.html#insertStmt\n      #   CQL documentation for INSERT\n      #\n      def insert(data, options = {})\n        inserter { insert(data) }.execute(options)\n      end\n\n      #\n      # Upsert data into one or more rows\n      #\n      # @overload update(column_values, options = {})\n      #   Update the rows specified in the data set with new values\n      #\n      #   @param column_values [Hash] map of column names to new values\n      #   @param options [Options] options for persisting the column data\n      #   @option (see #generate_upsert_options)\n      #\n      #   @example\n      #     posts.where(blog_subdomain: 'cassandra', permalink: 'cequel').\n      #       update(title: 'Announcing Cequel 1.0')\n      #\n      # @overload update(options = {}, &block)\n      #   Construct an update statement consisting of multiple operations\n      #\n      #   @param options [Options] options for persisting the data\n      #   @option (see #generate_upsert_options)\n      #   @yield DSL context for adding write operations\n      #\n      #   @see Updater\n      #   @since 1.0.0\n      #\n      #   @example\n      #     posts.where(blog_subdomain: 'bigdata', permalink: 'cql').update do\n      #       set(title: 'Announcing Cequel 1.0')\n      #       list_append(categories: 'ORMs')\n      #     end\n      #\n      # @return [void]\n      #\n      # @note `UPDATE` statements will succeed even if targeting a row that\n      #   does not exist. In this case a new row will be created.\n      # @note This statement will fail unless one or more rows are fully\n      #   specified by primary key using `where`\n      # @note If a enclosed in a Keyspace#batch block, this method will be\n      #   executed as part of the batch.\n      # @see http://cassandra.apache.org/doc/cql3/CQL.html#updateStmt\n      #   CQL documentation for UPDATE\n      #\n      def update(*args, &block)\n        if block\n          updater(&block).execute(args.extract_options!)\n        else\n          data = args.shift\n          updater { set(data) }.execute(args.extract_options!)\n        end\n      end\n\n      #\n      # Increment one or more counter columns\n      #\n      # @param deltas [Hash<Symbol,Integer>] map of counter column names to\n      #   amount by which to increment each column\n      # @return [void]\n      #\n      # @example\n      #   post_analytics.\n      #     where(blog_subdomain: 'cassandra', permalink: 'cequel').\n      #     increment(pageviews: 10, tweets: 2)\n      #\n      # @note This can only be used on counter tables\n      # @since 0.5.0\n      # @see #decrement\n      # @see http://cassandra.apache.org/doc/cql3/CQL.html#counters\n      #   CQL documentation for counter columns\n      #\n      def increment(deltas, options = {})\n        incrementer { increment(deltas) }.execute(options)\n      end\n      alias_method :incr, :increment\n\n      #\n      # Decrement one or more counter columns\n      #\n      # @param deltas [Hash<Symbol,Integer>] map of counter column names to\n      #   amount by which to decrement each column\n      # @return [void]\n      #\n      # @see #increment\n      # @see http://cassandra.apache.org/doc/cql3/CQL.html#counters\n      #   CQL documentation for counter columns\n      # @since 0.5.0\n      #\n      def decrement(deltas, options = {})\n        incrementer { decrement(deltas) }.execute(options)\n      end\n      alias_method :decr, :decrement\n\n      #\n      # Prepend element(s) to a list in the row(s) matched by this data set.\n      #\n      # @param column [Symbol] name of list column to prepend to\n      # @param elements [Object,Array] one element or an array of elements to\n      #   prepend\n      # @param options [Options] options for persisting the column data\n      # @option (see Writer#initialize)\n      # @return [void]\n      #\n      # @example\n      #   posts.list_prepend(:categories, ['CQL', 'ORMs'])\n      #\n      # @note If multiple elements are passed, they will appear in the list in\n      #   reverse order.\n      # @note If a enclosed in a Keyspace#batch block, this method will be\n      #   executed as part of the batch.\n      # @see #list_append\n      # @see #update\n      #\n      def list_prepend(column, elements, options = {})\n        updater { list_prepend(column, elements) }.execute(options)\n      end\n\n      #\n      # Append element(s) to a list in the row(s) matched by this data set.\n      #\n      # @param column [Symbol] name of list column to append to\n      # @param elements [Object,Array] one element or an array of elements to\n      #   append\n      # @param options [Options] options for persisting the column data\n      # @option (see Writer#initialize)\n      # @return [void]\n      #\n      # @example\n      #   posts.list_append(:categories, ['CQL', 'ORMs'])\n      #\n      # @note If a enclosed in a Keyspace#batch block, this method will be\n      #   executed as part of the batch.\n      # @see #list_append\n      # @see #update\n      # @since 1.0.0\n      #\n      def list_append(column, elements, options = {})\n        updater { list_append(column, elements) }.execute(options)\n      end\n\n      #\n      # Replace a list element at a specified index with a new value\n      #\n      # @param column [Symbol] name of list column\n      # @param index [Integer] which element to replace\n      # @param value [Object] new value at this index\n      # @param options [Options] options for persisting the data\n      # @option (see Writer#initialize)\n      # @return [void]\n      #\n      # @example\n      #   posts.list_replace(:categories, 2, 'Object-Relational Mapper')\n      #\n      # @note if a enclosed in a Keyspace#batch block, this method will be\n      #   executed as part of the batch.\n      # @see #update\n      # @since 1.0.0\n      #\n      def list_replace(column, index, value, options = {})\n        updater { list_replace(column, index, value) }.execute(options)\n      end\n\n      #\n      # Remove all occurrences of a given value from a list column\n      #\n      # @param column [Symbol] name of list column\n      # @param value [Object] value to remove\n      # @param options [Options] options for persisting the data\n      # @option (see Writer#initialize)\n      # @return [void]\n      #\n      # @example\n      #   posts.list_remove(:categories, 'CQL3')\n      #\n      # @note If enclosed in a Keyspace#batch block, this method will be\n      #   executed as part of the batch.\n      # @see #list_remove_at\n      # @see #update\n      # @since 1.0.0\n      #\n      def list_remove(column, value, options = {})\n        updater { list_remove(column, value) }.execute(options)\n      end\n\n      #\n      # @overload list_remove_at(column, *positions, options = {})\n      #   Remove the value from a given position or positions in a list column\n      #\n      #   @param column [Symbol] name of list column\n      #   @param positions [Integer] position(s) in list to remove value from\n      #   @param options [Options] options for persisting the data\n      #   @option (see Writer#initialize)\n      #   @return [void]\n      #\n      #   @example\n      #     posts.list_remove_at(:categories, 2)\n      #\n      #   @note If enclosed in a Keyspace#batch block, this method will be\n      #     executed as part of the batch.\n      #   @see #list_remove\n      #   @see #update\n      #   @since 1.0.0\n      #\n      def list_remove_at(column, *positions)\n        options = positions.extract_options!\n        deleter { list_remove_at(column, *positions) }.execute(options)\n      end\n\n      #\n      # @overload map_remove(column, *keys, options = {})\n      #   Remove a given key from a map column\n      #\n      #   @param column [Symbol] name of map column\n      #   @param keys [Object] map key to remove\n      #   @param options [Options] options for persisting the data\n      #   @option (see Writer#initialize)\n      #   @return [void]\n      #\n      #   @example\n      #     posts.map_remove(:credits, 'editor')\n      #\n      #   @note If enclosed in a Keyspace#batch block, this method will be\n      #     executed as part of the batch.\n      #   @see #update\n      #   @since 1.0.0\n      #\n      def map_remove(column, *keys)\n        options = keys.extract_options!\n        deleter { map_remove(column, *keys) }.execute(options)\n      end\n\n      #\n      # Add one or more elements to a set column\n      #\n      # @param column [Symbol] name of set column\n      # @param values [Object,Set] value or values to add\n      # @param options [Options] options for persisting the data\n      # @option (see Writer#initialize)\n      # @return [void]\n      #\n      # @example\n      #   posts.set_add(:tags, 'cql3')\n      #\n      # @note If enclosed in a Keyspace#batch block, this method will be\n      #   executed as part of the batch.\n      # @see #update\n      # @since 1.0.0\n      #\n      def set_add(column, values, options = {})\n        updater { set_add(column, values) }.execute(options)\n      end\n\n      #\n      # Remove an element from a set\n      #\n      # @param column [Symbol] name of set column\n      # @param value [Object] value to remove\n      # @param options [Options] options for persisting the data\n      # @option (see Writer#initialize)\n      # @return [void]\n      #\n      # @example\n      #   posts.set_remove(:tags, 'cql3')\n      #\n      # @note If enclosed in a Keyspace#batch block, this method will be\n      #   executed as part of the batch.\n      # @see #update\n      # @since 1.0.0\n      #\n      def set_remove(column, value, options = {})\n        updater { set_remove(column, value) }.execute(options)\n      end\n\n      #\n      # Update one or more keys in a map column\n      #\n      # @param column [Symbol] name of set column\n      # @param updates [Hash] map of map keys to new values\n      # @param options [Options] options for persisting the data\n      # @option (see Writer#initialize)\n      # @return [void]\n      #\n      # @example\n      #   posts.map_update(:credits, 'editor' => 34)\n      #\n      # @note If enclosed in a Keyspace#batch block, this method will be\n      #   executed as part of the batch.\n      # @see #update\n      # @since 1.0.0\n      #\n      def map_update(column, updates, options = {})\n        updater { map_update(column, updates) }.execute(options)\n      end\n\n      #\n      # @overload delete(options = {})\n      #   Delete one or more rows from the table\n      #\n      #   @param options [Options] options for persistence\n      #   @option (See Writer#initialize)\n      #\n      #   @example\n      #     posts.where(blog_subdomain: 'cassandra', permalink: 'cequel').\n      #       delete\n      #\n      # @overload delete(*columns, options = {})\n      #   Delete data from given columns in the specified rows. This is\n      #   equivalent to setting columns to `NULL` in an SQL database.\n      #\n      #   @param columns [Symbol] columns to remove\n      #   @param options [Options] options for persistence\n      #   @option (see Writer#initialize)\n      #\n      #   @example\n      #     posts.where(blog_subdomain: 'cassandra', permalink: 'cequel').\n      #       delete(:body)\n      #\n      # @overload delete(options = {}, &block)\n      #   Construct a `DELETE` statement with multiple operations (column\n      #   deletions, collection element removals, etc.)\n      #\n      #   @param options [Options] options for persistence\n      #   @option (see Writer#initialize)\n      #   @yield DSL context for construction delete statement\n      #\n      #   @example\n      #     posts.where(blog_subdomain: 'bigdata', permalink: 'cql').delete do\n      #       delete_columns :body\n      #       list_remove_at :categories, 2\n      #     end\n      #\n      #   @see Deleter\n      #\n      # @return [void]\n      #\n      # @note If enclosed in a Keyspace#batch block, this method will be\n      #   executed as part of the batch.\n      # @see http://cassandra.apache.org/doc/cql3/CQL.html#deleteStmt\n      #   CQL documentation for DELETE\n      #\n      def delete(*columns, &block)\n        options = columns.extract_options!\n        if block\n          deleter(&block).execute(options)\n        elsif columns.empty?\n          deleter { delete_row }.execute(options)\n        else\n          deleter { delete_columns(*columns) }.execute(options)\n        end\n      end\n\n      #\n      # Select specified columns from this data set.\n      #\n      # @param columns [Symbol] columns columns to select\n      # @return [DataSet] new data set scoped to specified columns\n      #\n      def select(*columns)\n        clone.tap do |data_set|\n          data_set.select_columns.concat(columns.flatten)\n        end\n      end\n\n      #\n      # Return the remaining TTL for the specified columns from this data set.\n      #\n      # @param columns [Symbol] columns to select\n      # @return [DataSet] new data set scoped to specified columns\n      #\n      # @since 1.0.0\n      #\n      def select_ttl(*columns)\n        clone.tap do |data_set|\n          data_set.ttl_columns.concat(columns.flatten)\n        end\n      end\n\n      #\n      # Return the write time for the specified columns in the data set\n      #\n      # @param columns [Symbol] columns to select\n      # @return [DataSet] new data set scoped to specified columns\n      #\n      # @since 1.0.0\n      #\n      def select_writetime(*columns)\n        clone.tap do |data_set|\n          data_set.writetime_columns.concat(columns.flatten)\n        end\n      end\n      alias_method :select_timestamp, :select_writetime\n\n      #\n      # Select specified columns from this data set, overriding chained scope.\n      #\n      # @param columns [Symbol,Array] columns to select\n      # @return [DataSet] new data set scoped to specified columns\n      #\n      def select!(*columns)\n        clone.tap do |data_set|\n          data_set.select_columns.replace(columns.flatten)\n        end\n      end\n\n      #\n      # Filter this data set with a row specification\n      #\n      # @overload where(column_values)\n      #   @param column_values [Hash] Map of column name to values to match\n      #\n      #   @example\n      #     database[:posts].where(title: 'Hey')\n      #\n      # @overload where(cql, *bind_vars)\n      #   @param cql [String] CQL fragment representing `WHERE` statement\n      #   @param bind_vars [Object] Bind variables for the CQL fragment\n      #\n      #   @example\n      #     DB[:posts].where('title = ?', 'Hey')\n      #\n      # @return [DataSet] New data set scoped to the row specification\n      #\n      def where(row_specification, *bind_vars)\n        clone.tap do |data_set|\n          data_set.row_specifications\n            .concat(build_row_specifications(row_specification, bind_vars))\n        end\n      end\n\n      #\n      # Replace existing row specifications\n      #\n      # @see #where\n      # @return [DataSet] New data set with only row specifications given\n      #\n      def where!(row_specification, *bind_vars)\n        clone.tap do |data_set|\n          data_set.row_specifications\n            .replace(build_row_specifications(row_specification, bind_vars))\n        end\n      end\n\n      #\n      # Limit the number of rows returned by this data set\n      #\n      # @param limit [Integer] maximum number of rows to return\n      # @return [DataSet] new data set scoped with given limit\n      #\n      def limit(limit)\n        clone.tap { |data_set| data_set.row_limit = limit }\n      end\n\n      #\n      # Control how the result rows are sorted\n      #\n      # @param pairs [Hash] Map of column name to sort direction\n      # @return [DataSet] new data set with the specified ordering\n      #\n      # @note The only valid ordering column is the first clustering column\n      # @since 1.0.0\n      #\n      def order(pairs)\n        clone.tap do |data_set|\n          data_set.sort_order.merge!(pairs.symbolize_keys)\n        end\n      end\n\n      # rubocop:disable LineLength\n\n      #\n      # Change the consistency for queries performed by this data set\n      #\n      # @param consistency [Symbol] a consistency level\n      # @return [DataSet] new data set tuned to the given consistency\n      #\n      # @see http://www.datastax.com/documentation/cassandra/2.0/cassandra/dml/dml_config_consistency_c.html\n      # @since 1.1.0\n      #\n      def consistency(consistency)\n        clone.tap do |data_set|\n          data_set.query_consistency = consistency\n        end\n      end\n\n      # rubocop:enable LineLength\n\n      #\n      # Enumerate over rows in this data set. Along with #each, all other\n      # Enumerable methods are implemented.\n      #\n      # @overload each\n      #   @return [Enumerator] enumerator for rows, if no block given\n      #\n      # @overload each(&block)\n      #   @yield [Hash] result rows\n      #   @return [void]\n      #\n      # @return [Enumerator,void]\n      #\n      def each\n        return enum_for(:each) unless block_given?\n        result = execute_cql(*cql)\n        result.each { |row| yield Row.from_result_row(row) }\n      end\n\n      #\n      # @return [Hash] the first row in this data set\n      #\n      def first\n        row = execute_cql(*limit(1).cql).first\n        Row.from_result_row(row)\n      end\n\n      #\n      # @return [Fixnum] the number of rows in this data set\n      #\n      def count\n        execute_cql(*count_cql).first['count']\n      end\n\n      #\n      # @return [String] CQL `SELECT` statement encoding this data set's scope.\n      #\n      def cql\n        statement = Statement.new\n          .append(select_cql)\n          .append(\" FROM #{table_name}\")\n          .append(*row_specifications_cql)\n          .append(sort_order_cql)\n          .append(limit_cql)\n          .args\n      end\n\n      #\n      # @return [String] CQL statement to get count of rows in this data set\n      #\n      def count_cql\n        Statement.new\n          .append(\"SELECT COUNT(*) FROM #{table_name}\")\n          .append(*row_specifications_cql)\n          .append(limit_cql).args\n      end\n\n      #\n      # @return [String]\n      #\n      def inspect\n        \"#<#{self.class.name}: \" \\\n          \"#{Keyspace.sanitize(cql.first, cql.drop(1))}>\"\n      end\n\n      #\n      # @return [Boolean]\n      #\n      def ==(other)\n        cql == other.cql\n      end\n\n      # @private\n      def row_specifications_cql\n        if row_specifications.any?\n          cql_fragments, bind_vars = [], []\n          row_specifications.each do |spec|\n            cql_with_vars = spec.cql\n            cql_fragments << cql_with_vars.shift\n            bind_vars.concat(cql_with_vars)\n          end\n          [\" WHERE #{cql_fragments.join(' AND ')}\", *bind_vars]\n        else ['']\n        end\n      end\n\n      protected\n\n      attr_writer :row_limit, :query_consistency\n\n      private\n\n      def execute_cql(cql, *bind_vars)\n        keyspace.execute_with_consistency(cql, bind_vars, query_consistency)\n      end\n\n      def inserter(&block)\n        Inserter.new(self, &block)\n      end\n\n      def incrementer(&block)\n        Incrementer.new(self, &block)\n      end\n\n      def updater(&block)\n        Updater.new(self, &block)\n      end\n\n      def deleter(&block)\n        Deleter.new(self, &block)\n      end\n\n      def initialize_copy(source)\n        super\n        @select_columns = source.select_columns.clone\n        @ttl_columns = source.ttl_columns.clone\n        @writetime_columns = source.writetime_columns.clone\n        @row_specifications = source.row_specifications.clone\n        @sort_order = source.sort_order.clone\n      end\n\n      def select_cql\n        all_columns = select_columns +\n          ttl_columns.map { |column| \"TTL(#{column})\" } +\n          writetime_columns.map { |column| \"WRITETIME(#{column})\" }\n\n        if all_columns.any?\n          \"SELECT #{all_columns.join(',')}\"\n        else\n          'SELECT *'\n        end\n      end\n\n      def limit_cql\n        row_limit ? \" LIMIT #{row_limit}\" : ''\n      end\n\n      def sort_order_cql\n        if sort_order.any?\n          order = sort_order\n            .map { |column, direction| \"#{column} #{direction.to_s.upcase}\" }\n            .join(', ')\n          \" ORDER BY #{order}\"\n        end\n      end\n\n      def build_row_specifications(row_specification, bind_vars)\n        case row_specification\n        when Hash\n          RowSpecification.build(row_specification)\n        when String\n          CqlRowSpecification.build(row_specification, bind_vars)\n        else\n          fail ArgumentError,\n               \"Invalid argument #{row_specification.inspect}; \" \\\n               \"expected Hash or String\"\n        end\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[428,20],[428,30]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":129,"autoscroll":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/cequel/lib/cequel/metal/data_set.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"6ad94797460e21d23f8d251e16d5f92b92ab2e29","deserializer":"TextBuffer"},{"text":"# -*- encoding : utf-8 -*-\nmodule Cequel\n  module Metal\n    #\n    # Internal representation of a data manipulation statement\n    #\n    # @abstract Subclasses must implement #write_to_statement, which writes\n    #   internal state to a Statement instance\n    #\n    # @since 1.0.0\n    # @api private\n    #\n    class Writer\n      extend Forwardable\n\n      #\n      # @param data_set [DataSet] data set to write to\n      #\n      def initialize(data_set, &block)\n        @data_set, @options, @block = data_set, options, block\n        @statements, @bind_vars = [], []\n        SimpleDelegator.new(self).instance_eval(&block) if block\n      end\n\n      #\n      # Execute the statement as a write operation\n      #\n      # @param options [Options] options\n      # @opiton options [Symbol] :consistency what consistency level to use for\n      #   the operation\n      # @option options [Integer] :ttl time-to-live in seconds for the written\n      #   data\n      # @option options [Time,Integer] :timestamp the timestamp associated with\n      #   the column values\n      # @return [void]\n      #\n      def execute(options = {})\n        options.assert_valid_keys(:timestamp, :ttl, :consistency)\n        return if empty?\n        statement = Statement.new\n        consistency = options.fetch(:consistency, data_set.query_consistency)\n        write_to_statement(statement, options)\n        statement.append(*data_set.row_specifications_cql)\n        data_set.write_with_consistency(\n          statement.cql, statement.bind_vars, consistency)\n      end\n\n      private\n\n      attr_reader :data_set, :options, :statements, :bind_vars\n      def_delegator :data_set, :table_name\n      def_delegator :statements, :empty?\n\n      def prepare_upsert_value(value)\n        case value\n        when ::Array\n          yield '[?]', value\n        when ::Set then\n          yield '{?}', value.to_a\n        when ::Hash then\n          binding_pairs = ::Array.new(value.length) { '?:?' }.join(',')\n          yield \"{#{binding_pairs}}\", *value.flatten\n        else\n          yield '?', value\n        end\n      end\n\n      #\n      # Generate CQL option statement for inserts and updates\n      #\n      def generate_upsert_options(options)\n        upsert_options = options.slice(:timestamp, :ttl)\n        if upsert_options.empty?\n          ''\n        else\n          ' USING ' <<\n          upsert_options.map do |key, value|\n            serialized_value =\n              case key\n              when :timestamp then (value.to_f * 1_000_000).to_i\n              else value\n              end\n            \"#{key.to_s.upcase} #{serialized_value}\"\n          end.join(' AND ')\n        end\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[49,40],[49,50]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":133,"autoscroll":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/cequel/lib/cequel/metal/writer.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"7c9898733a2d9c697cdb7804ceb93158b6299261","deserializer":"TextBuffer"},{"text":"# -*- encoding : utf-8 -*-\nrequire 'delegate'\n\nmodule Cequel\n  module Record\n    #\n    # The value of a collection column in a {Record}. Collections track\n    # modifications that can be expressed as atomic collection mutations in\n    # CQL, and persist those modifications when their owning record is saved.\n    # Such modifications can be done even if the collection has not loaded\n    # data from CQL, in the case of an unloaded record or where the collection\n    # column was not included in the `SELECT` statement.\n    #\n    # Mutation operations that require reading data before writing it are not\n    # supported (e.g. `Array#map!).\n    #\n    # Each collection implementation wraps a built-in Ruby collection type.\n    #\n    # @abstract Including classes must descend from `Delegator` and implement\n    #   the `::empty` class method.\n    #\n    # @example\n    #   class Blog\n    #     include Cequel::Record\n    #\n    #     key :subdomain\n    #\n    #     list :categories, :text\n    #   end\n    #\n    #   # Get an unloaded Blog instance; no data read\n    #   blog = Blog['cassandra']\n    #\n    #   # Stage modification to collection, still no data read\n    #   blog.categories << 'Big Data'\n    #\n    #   # Issue an UPDATE statement which pushes \"Big Data\" onto the\n    #   # collection. Still no data read\n    #   blog.save!\n    #\n    #   # Stage another modification to the collection\n    #   blog.categories.unshift('Distributed Database')\n    #\n    #   # Collection is lazily read from the database, and then staged\n    #   # modifications are made to the loaded collection\n    #   puts blog.categories.join(', ') \n    #\n    #   # Issues an UPDATE statement which prepends \"Distributed Data\" onto the\n    #   # collection\n    #   blog.save! \n    #\n    # @since 1.0.0\n    #\n    module Collection\n      extend ActiveSupport::Concern\n      extend Forwardable\n\n      #\n      # @!method loaded?\n      #   @return [Boolean] `true` if the collection's contents are loaded into\n      #     memory\n      #\n      def_delegators :@model, :loaded?, :updater, :deleter\n      private :updater, :deleter\n\n      #\n      # @!method column_name\n      #   @return [Symbol] the name of the collection column\n      #\n      def_delegator :@column, :name, :column_name\n\n      def_delegators :__getobj__, :clone, :dup\n\n      included do\n        define_method(\n          :method_missing,\n          BasicObject.instance_method(:method_missing))\n        private :method_missing\n      end\n\n      #\n      # @param model [Record] record that contains this collection\n      # @param column [Schema::Column] column this collection's data belongs to\n      # @return [Collection] a new collection\n      #\n      def initialize(model, column)\n        @model, @column = model, column\n      end\n\n      #\n      # @return [String] inspected underlying Ruby collection object\n      #\n      def inspect\n        __getobj__.inspect\n      end\n\n      #\n      # Notify the collection that its underlying data is loaded in memory.\n      #\n      # @return [void]\n      #\n      # @api private\n      #\n      def loaded!\n        modifications.each { |modification| modification.call() }.clear\n      end\n\n      #\n      # Notify the collection that its staged changes have been written to the\n      # data store.\n      #\n      # @return [void]\n      #\n      # @api private\n      #\n      def persisted!\n        modifications.clear\n      end\n\n      protected\n\n      def __getobj__\n        model.__send__(:read_attribute, column_name)\n      end\n\n      def __setobj__(obj)\n        fail \"Attempted to call __setobj__ on read-only delegate!\"\n      end\n\n      private\n\n      attr_reader :model, :column\n      def_delegator :column, :cast, :cast_collection\n      def_delegator 'column.type', :cast, :cast_element\n      private :cast_collection, :cast_element\n\n      def to_modify(&block)\n        if loaded?\n          model.__send__(\"#{column_name}_will_change!\")\n          block.call()\n        else modifications << block\n        end\n        self\n      end\n\n      def modifications\n        @modifications ||= []\n      end\n    end\n\n    #\n    # The value of a list column in a {Record} instance. List collections\n    # encapsulate and behave like the built-in `Array` type.\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#list\n    #   CQL documentation for the list type\n    # @since 1.0.0\n    #\n    class List < DelegateClass(Array)\n      include Collection\n\n      # These methods are not available on lists because they require reading\n      # collection data before writing it.\n      NON_ATOMIC_MUTATORS = [\n        :collect!,\n        :delete_if,\n        :fill,\n        :flatten!,\n        :insert,\n        :keep_if,\n        :map!,\n        :pop,\n        :reject!,\n        :reverse!,\n        :rotate!,\n        :select!,\n        :shift,\n        :shuffle!,\n        :slice!,\n        :sort!,\n        :sort_by!,\n        :uniq!\n      ]\n      NON_ATOMIC_MUTATORS\n        .each { |method| undef_method(method) if method_defined? method }\n\n      #\n      # Set the value at a position or range of positions. This modification\n      # will be staged and persisted as an atomic list update when the record\n      # is saved. If the collection data is loaded in memory, it will also be\n      # modified accordingly.\n      #\n      # @return [void]\n      #\n      # @see DataSet#list_replace\n      # @note Negative positions are not supported, as they are not allowed in\n      #   CQL list operations.\n      #\n      # @overload []=(position, element)\n      #\n      #   @param position [Integer] position at which to set element\n      #   @param element element to insert at position in list\n      #\n      # @overload []=(range, elements)\n      #\n      #   @param range [Range] range of positions at which to replace elements\n      #   @param elements [Array] new elements to replace in this range\n      #\n      # @overload []=(start_position, count, elements)\n      #\n      #   @param start_position [Integer] position at which to begin replacing\n      #     elements\n      #   @param count [Integer] number of elements to replace\n      #   @param elements [Array] new elements to replace in this range\n      #\n      def []=(position, *args)\n        if position.is_a?(Range)\n          first, count = position.first, position.count\n        else\n          first, count = position, args[-2]\n        end\n\n        element = args[-1] =\n          if args[-1].is_a?(Array) then cast_collection(args[-1])\n          else cast_element(args[-1])\n          end\n\n        if first < 0\n          fail ArgumentError,\n               \"Bad index #{position}: CQL lists do not support negative \" \\\n               \"indices\"\n        end\n\n        if count.nil?\n          updater.list_replace(column_name, first, element)\n        else\n          element = Array.wrap(element)\n          count.times do |i|\n            if i < element.length\n              updater.list_replace(column_name, first+i, element[i])\n            else\n              deleter.list_remove_at(column_name, first+i)\n            end\n          end\n        end\n        to_modify { super }\n      end\n\n      #\n      # Remove all elements from the list. This will propagate to the database\n      # as a DELETE of the list column.\n      #\n      # @return [List] self\n      #\n      def clear\n        deleter.delete_columns(column_name)\n        to_modify { super }\n      end\n\n      #\n      # Concatenate another collection onto this list.\n      #\n      # @param array [Array] elements to concatenate\n      # @return [List] self\n      #\n      def concat(array)\n        array = cast_collection(array)\n        updater.list_append(column_name, array)\n        to_modify { super }\n      end\n\n      #\n      # Remove all instances of a given value from the list.\n      #\n      # @param object value to remove\n      # @return [List] self\n      #\n      def delete(object)\n        object = cast_element(object)\n        updater.list_remove(column_name, object)\n        to_modify { super }\n      end\n\n      #\n      # Remove the element at a given position from the list.\n      #\n      # @param index [Integer] position from which to remove the element\n      # @return [List] self\n      #\n      def delete_at(index)\n        deleter.list_remove_at(column_name, index)\n        to_modify { super }\n      end\n\n      #\n      # Push (append) one or more elements to the end of the list.\n      #\n      # @param objects value(s) to add to the end of the list\n      # @return [List] self\n      #\n      def push(*objects)\n        objects.map! { |object| cast_element(object) }\n        updater.list_append(column_name, objects)\n        to_modify { super }\n      end\n      alias_method :<<, :push\n      alias_method :append, :push\n\n      #\n      # Replace the entire contents of this list with a new collection\n      #\n      # @param array [Array] new elements for this list\n      # @return [List] self\n      #\n      def replace(array)\n        array = cast_collection(array)\n        updater.set(column_name => array)\n        to_modify { super }\n      end\n\n      #\n      # Prepend one or more values to the beginning of this list\n      #\n      # @param objects value(s) to add to the beginning of the list\n      # @return [List] self\n      #\n      def unshift(*objects)\n        objects.map!(&method(:cast_element))\n        updater.list_prepend(column_name, objects.reverse)\n        to_modify { super }\n      end\n      alias_method :prepend, :unshift\n    end\n\n    #\n    # The value of a set column in a {Record} instance. Contains an unordered,\n    # unique set of elements. Encapsulates and behaves like the `Set` type from\n    # the standard library.\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#set\n    #   CQL documentation for set columns\n    # @since 1.0.0\n    #\n    class Set < DelegateClass(::Set)\n      include Collection\n\n      # These methods are not implemented because they cannot be expressed as a\n      # single CQL3 write operation.\n      NON_ATOMIC_MUTATORS = [\n        :add?,\n        :collect!,\n        :delete?,\n        :delete_if,\n        :flatten!,\n        :keep_if,\n        :map!,\n        :reject!,\n        :select!\n      ]\n      NON_ATOMIC_MUTATORS\n        .each { |method| undef_method(method) if method_defined? method }\n\n      #\n      # Add an element to the set\n      #\n      # @param object element to add\n      # @return [Set] self\n      #\n      def add(object)\n        object = cast_element(object)\n        updater.set_add(column_name, object)\n        to_modify { super }\n      end\n      alias_method :<<, :add\n\n      #\n      # Remove everything from the set. Equivalent to deleting the collection\n      # column from the record's row.\n      #\n      # @return [Set] self\n      #\n      def clear\n        deleter.delete_columns(column_name)\n        to_modify { super }\n      end\n\n      #\n      # Remove a single element from the set\n      #\n      # @param object element to remove\n      # @return [Set] self\n      #\n      def delete(object)\n        object = cast_element(object)\n        updater.set_remove(column_name, object)\n        to_modify { super }\n      end\n\n      #\n      # Replace the entire contents of this set with another set\n      #\n      # @param set [::Set] set containing new elements\n      # @return [Set] self\n      #\n      def replace(set)\n        set = cast_collection(set)\n        updater.set(column_name => set)\n        to_modify { super }\n      end\n    end\n\n    #\n    # The value of a `map` column in a {Record} instance. Encapsulates and\n    # behaves like a built-in `Hash`.\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#map\n    #   CQL documentation for map columns\n    # @since 1.0.0\n    #\n    class Map < DelegateClass(::Hash)\n      include Collection\n      extend Forwardable\n\n      # These methods involve mutation that cannot be expressed as a CQL\n      # operation, so are not implemented.\n      NON_ATOMIC_MUTATORS = [\n        :default,\n        :default=,\n        :default_proc,\n        :default_proc=,\n        :delete_if,\n        :deep_merge!,\n        :except!,\n        :extract!,\n        :keep_if,\n        :reject!,\n        :reverse_merge!,\n        :reverse_update,\n        :select!,\n        :shift,\n        :slice!,\n        :stringify_keys!,\n        :symbolize_keys!,\n        :to_options!,\n        :transform_keys!\n      ]\n      NON_ATOMIC_MUTATORS\n        .each { |method| undef_method(method) if method_defined? method }\n\n      #\n      # Set the value of a given key\n      #\n      # @param key the key\n      # @param value the value\n      # @return [Map] self\n      #\n      def []=(key, value)\n        key = cast_key(key)\n        updater.map_update(column_name, key => value)\n        to_modify { super }\n      end\n      alias_method :store, :[]=\n\n      #\n      # Remove all elements from this map. Equivalent to deleting the column\n      # value from the row in CQL\n      #\n      # @return [Map] self\n      #\n      def clear\n        deleter.delete_columns(column_name)\n        to_modify { super }\n      end\n\n      #\n      # Delete one key from the map\n      #\n      # @param key the key to delete\n      # @return [Map] self\n      #\n      def delete(key)\n        key = cast_key(key)\n        deleter.map_remove(column_name, key)\n        to_modify { super }\n      end\n\n      #\n      # Update a collection of keys and values given by a hash\n      #\n      # @param hash [Hash] hash containing keys and values to set\n      # @return [Map] self\n      #\n      def merge!(hash)\n        hash = cast_collection(hash)\n        updater.map_update(column_name, hash)\n        to_modify { super }\n      end\n      alias_method :update, :merge!\n\n      #\n      # Replace the entire contents of this map with a new one\n      #\n      # @param hash [Hash] hash containing new keys and values\n      # @return [Map] self\n      #\n      def replace(hash)\n        hash = cast_collection(hash)\n        updater.set(column_name => hash)\n        to_modify { super }\n      end\n\n      private\n\n      def_delegator 'column.key_type', :cast, :cast_key\n      private :cast_key\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[137,15],[137,15]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":204,"autoscroll":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/cequel/lib/cequel/record/collection.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"67ef4a9a7fa74757093f082d4f1596f9fdea6577","deserializer":"TextBuffer"},{"text":"# -*- encoding : utf-8 -*-\nrequire 'singleton'\n\nmodule Cequel\n  #\n  # The Type module encapsulates information about the CQL3 type system. Each\n  # type has a `cql_name`, which is the name of the type as defined in CQL, and\n  # an `internal_name`, which is the name of the type in the lower-level\n  # interface that is exposed when introspecting table information in the\n  # database.\n  #\n  # As well as knowing their respective names, types also know how to cast Ruby\n  # objects to the correct canonical class corresponding to the type. These\n  # implicit types are used by the underlying `cassandra-cql` library to\n  # determine how to represent values when passing them to Cassandra.\n  #\n  # @since 1.0.0\n  #\n  module Type\n    # Raised if an unknown type is looked up\n    UnknownType = Class.new(ArgumentError)\n\n    BY_CQL_NAME = {}\n    BY_INTERNAL_NAME = {}\n\n    #\n    # Register a type for lookup\n    #\n    # @param type [Type] a new type\n    # @return [void]\n    #\n    def self.register(type)\n      BY_CQL_NAME[type.cql_name] = type\n      type.cql_aliases.each { |aliaz| BY_CQL_NAME[aliaz] = type }\n      type.internal_names.each do |internal_name|\n        BY_INTERNAL_NAME[internal_name] = type\n      end\n    end\n\n    #\n    # Return a type corresponding to the given input\n    #\n    # @param cql_name [Symbol,Base] CQL name of a type, or a type\n    # @return [Base] type with the given CQL name\n    #\n    def self.[](cql_name)\n      cql_name.is_a?(Base) ? cql_name : lookup_cql(cql_name)\n    end\n\n    #\n    # Look up a type by CQL name\n    #\n    # @param cql_name [Symbol] CQL name of a type\n    # @return [Base] type with the given CQL name\n    # @raise [UnknownType] if no type by that name is registered\n    #\n    def self.lookup_cql(cql_name)\n      BY_CQL_NAME.fetch(cql_name.to_sym)\n    rescue KeyError\n      raise UnknownType, \"Unrecognized CQL type #{cql_name.inspect}\"\n    end\n\n    #\n    # Look up a type by internal name\n    #\n    # @param internal_name [String] internal name of a type\n    # @return [Base] type with the given internal name\n    # @raise [UnknownType] if no type by that name is registered\n    #\n    def self.lookup_internal(internal_name)\n      BY_INTERNAL_NAME.fetch(internal_name)\n    rescue KeyError\n      raise UnknownType, \"Unrecognized internal type #{internal_name.inspect}\"\n    end\n\n    #\n    # Quote an arbitrary value for use in a CQL statement by inferring the\n    # equivalent CQL type to the value's Ruby type\n    #\n    # @return [String] quoted value\n    #\n    def self.quote(value)\n      if value.is_a?(Array)\n        return value.map { |element| quote(element) }.join(',')\n      end\n      case value\n      when ::String\n        quote_string(value)\n      when Time, ActiveSupport::TimeWithZone, DateTime\n        value.strftime('%s%L')\n      when Date\n        quote(Time.gm(value.year, value.month, value.day))\n      when Numeric, true, false, Cql::Uuid\n        value.to_s\n      else\n        quote_string(value.to_s)\n      end\n    end\n\n    def self.quote_string(string)\n      if string.encoding == Encoding::ASCII_8BIT && string =~ /^[[:xdigit:]]+$/\n        \"0x#{string}\"\n      else\n        \"'#{string.gsub(\"'\", \"''\")}'\"\n      end\n    end\n    private_class_method :quote_string\n\n    #\n    # The base class for all type objects. Types are singletons.\n    #\n    # @abstract Subclasses should implement {#cast}, and may implement\n    #   {#internal_names} if it cannot be inferred from the class name.\n    #   The name of the type class should be the camel-cased CQL name of the\n    #   type\n    #\n    class Base\n      include Singleton\n\n      #\n      # @return the name of the type used in CQL. This is also the name that is\n      #   used in all of Cequel's public interfaces\n      #\n      def cql_name\n        self.class.name.demodulize.underscore.to_sym\n      end\n\n      #\n      # @return [Array<Symbol>] other names used in CQL for this type\n      #\n      def cql_aliases\n        []\n      end\n\n      #\n      # @return [Array<String>] full class name of this type used in\n      #   Cassandra's underlying representation\n      #\n      # @deprecated use {internal_names}\n      #\n      def internal_name\n        internal_names.first\n      end\n\n      #\n      # @return [Array<String>] full class name(s) of this type used in\n      #   Cassandra's underlying representation (allows for multiple values for\n      #   types that have different names between different versions)\n      #\n      def internal_names\n        [\"org.apache.cassandra.db.marshal.#{self.class.name.demodulize}Type\"]\n      end\n\n      #\n      # @param value the value to cast\n      # @return the value cast to the correct Ruby class for this type\n      #\n      def cast(value)\n        value\n      end\n\n      #\n      # CQL only allows changing column types when the old type's binary\n      # representation is compatible with the new type.\n      #\n      # @return [Array<Type>] new types that columns of this type may be\n      #   altered to\n      #\n      def compatible_types\n        [Type[:blob]]\n      end\n\n      #\n      # A string representation of this type\n      #\n      def to_s\n        cql_name.to_s\n      end\n    end\n\n    #\n    # Abstract superclass for types that represent character data\n    #\n    # @abstract Subclasses must implement `#encoding`, which returns the name\n    #   of the Ruby encoding corresponding to the character encoding used for\n    #   values of this type\n    #\n    class String < Base\n      def cast(value)\n        str = String(value)\n        str.encoding.name == encoding ? str : str.dup.force_encoding(encoding)\n      end\n    end\n\n    #\n    # `ascii` columns store 7-bit ASCII character data\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Ascii < String\n      def compatible_types\n        super + [Type[:text]]\n      end\n\n      private\n\n      def encoding\n        'US-ASCII'\n      end\n    end\n    register Ascii.instance\n\n    #\n    # `blob` columns store arbitrary bytes of data, represented as 8-bit ASCII\n    # strings of hex digits\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Blob < String\n      def internal_names\n        ['org.apache.cassandra.db.marshal.BytesType']\n      end\n\n      def cast(value)\n        value = value.to_s(16) if value.is_a?(Integer)\n        super\n      end\n\n      private\n\n      def encoding\n        'ASCII-8BIT'\n      end\n    end\n    register Blob.instance\n\n    #\n    # `boolean` types store boolean values\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Boolean < Base\n      def cast(value)\n        !!value\n      end\n    end\n    register Boolean.instance\n\n    #\n    # Counter columns are a special type of column in Cassandra that can be\n    # incremented and decremented atomically. Counter columns cannot comingle\n    # with regular data columns in the same table. Unlike other columns,\n    # counter columns cannot be updated without Cassandra internally reading\n    # the existing state of the column\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Counter < Base\n      def internal_names\n        ['org.apache.cassandra.db.marshal.CounterColumnType']\n      end\n\n      def compatible_types\n        []\n      end\n\n      def cast(value)\n        Integer(value)\n      end\n    end\n    register Counter.instance\n\n    #\n    # `decimal` columns store decimal numeric values\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Decimal < Base\n      def cast(value)\n        value.is_a?(BigDecimal) ? value : BigDecimal.new(value, 0)\n      end\n    end\n    register Decimal.instance\n\n    #\n    # `double` columns store 64-bit floating-point numeric values\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Double < Base\n      def cast(value)\n        Float(value)\n      end\n    end\n    register Double.instance\n\n    #\n    # `inet` columns store IP addresses\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Inet < Base\n      def internal_names\n        ['org.apache.cassandra.db.marshal.InetAddressType']\n      end\n    end\n    register Inet.instance\n\n    #\n    # `int` columns store 32-bit integer values\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Int < Base\n      def internal_names\n        ['org.apache.cassandra.db.marshal.Int32Type']\n      end\n\n      def cast(value)\n        Integer(value)\n      end\n    end\n    register Int.instance\n\n    #\n    # `float` columns store 32-bit floating-point numeric values\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Float < Double; end\n    register Float.instance\n\n    #\n    # `bigint` columns store 64-bit integer values\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Bigint < Int\n      def internal_names\n        ['org.apache.cassandra.db.marshal.LongType']\n      end\n    end\n    register Bigint.instance\n\n    #\n    # `text` columns store UTF-8 character data. They are also known as\n    # `varchar` columns; the names can be used interchangeably. Text columns do\n    # not have a length limit\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Text < String\n      def internal_names\n        ['org.apache.cassandra.db.marshal.UTF8Type']\n      end\n\n      def cql_aliases\n        [:varchar]\n      end\n\n      private\n\n      def encoding\n        'UTF-8'\n      end\n    end\n    register Text.instance\n\n    #\n    # `timestamp` columns store timestamps. Timestamps do not include time zone\n    # data, and all input times are cast to UTC before being stored.\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#usingdates\n    #   CQL3 documentation for date columns\n    #\n    class Timestamp < Base\n      def internal_names\n        ['org.apache.cassandra.db.marshal.DateType',\n         'org.apache.cassandra.db.marshal.TimestampType']\n      end\n\n      def cast(value)\n        if value.is_a?(::String) then Time.parse(value)\n        elsif value.respond_to?(:to_time) then value.to_time\n        elsif value.is_a?(Numeric) then Time.at(value)\n        else Time.parse(value.to_s)\n        end.utc\n      end\n    end\n    register Timestamp.instance\n\n    #\n    # `uuid` columns store type 1 and type 4 UUIDs. New UUID instances can be\n    # created using the {Cequel.uuid} method, and a value can be checked to see\n    # if it is a UUID recognized by Cequel using the {Cequel.uuid?} method.\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Uuid < Base\n      def internal_names\n        ['org.apache.cassandra.db.marshal.UUIDType']\n      end\n\n      def cast(value)\n        if value.is_a? Cql::Uuid then value\n        elsif defined?(SimpleUUID::UUID) && value.is_a?(SimpleUUID::UUID)\n          Cql::Uuid.new(value.to_i)\n        elsif value.is_a?(::Integer) || value.is_a?(::String)\n          Cql::Uuid.new(value)\n        else\n          fail ArgumentError,\n               \"Don't know how to cast #{value.inspect} to a UUID\"\n        end\n      end\n    end\n    register Uuid.instance\n\n    #\n    # `timeuuid` columns are a special type of UUID column that support\n    # time-based queries. For instance, a `timeuuid` clustering column can be\n    # filtered by ranges of times into which the UUIDs must fall. This\n    # functionality presumes the use of type 1 UUIDs, which encode the\n    # timestamp of their creation.\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Timeuuid < Uuid\n      def cast(value)\n        Cql::TimeUuid.new(super.value)\n      end\n\n      def internal_names\n        ['org.apache.cassandra.db.marshal.TimeUUIDType']\n      end\n    end\n    register Timeuuid.instance\n\n    #\n    # `varint` columns store arbitrary-length integer data\n    #\n    # @see http://cassandra.apache.org/doc/cql3/CQL.html#types\n    #   CQL3 data type documentation\n    #\n    class Varint < Int\n      def internal_names\n        ['org.apache.cassandra.db.marshal.IntegerType']\n      end\n    end\n    register Varint.instance\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[18,9],[18,13]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":224,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/cequel/lib/cequel/type.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"d48bfd16ac9cd38e0c724fb068d82aa7a469116c","deserializer":"TextBuffer"},{"text":"# -*- encoding : utf-8 -*-\nmodule Cequel\n  module Record\n    #\n    # Properties on a Cequel record acts as attributes on record instances, and\n    # are persisted as column values to Cassandra. Properties are declared\n    # explicitly on a record instance in the body.\n    #\n    # Properties can be **key columns**, **data columns**, or **collection\n    # columns**. Key columns combine to form the primary key for the record;\n    # they cannot be changed once a record has been saved. Data columns contain\n    # scalar data values like strings, integers, and timestamps. Collection\n    # columns are lists, sets, or maps that can be atomically updated.\n    #\n    # All varieties of column have a type; see {Cequel::Type} for the full\n    # list of possibilities. A collection column's type is the type of its\n    # elements (in the case of a map collection, there is both a key type and a\n    # value type).\n    #\n    # @example\n    #   class Post\n    #     key :blog_subdomain, :text\n    #     key :id, :timeuuid, auto: true\n    #\n    #     column :title, :text\n    #     column :body, :text\n    #     column :updated_at, :timestamp\n    #\n    #     list :categories, :text\n    #     set :tags, :text\n    #     map :referers, :text, :integer\n    #   end\n    #\n    # @see ClassMethods Methods for defining properties\n    #\n    module Properties\n      extend ActiveSupport::Concern\n\n      included do\n        class_attribute :default_attributes, instance_writer: false\n        class_attribute :empty_attributes, instance_writer: false\n        self.default_attributes, self.empty_attributes = {}, {}\n\n        class <<self; alias_method :new_empty, :new; end\n        extend ConstructorMethods\n\n        attr_reader :collection_proxies\n        private :collection_proxies\n      end\n\n      # @private\n      module ConstructorMethods\n        def new(*args, &block)\n          new_empty.tap do |record|\n            record.__send__(:initialize_new_record, *args)\n            yield record if block_given?\n          end\n        end\n      end\n\n      #\n      # Methods for defining columns on a record\n      #\n      # @see Properties\n      #\n      module ClassMethods\n        protected\n\n        # rubocop:disable LineLength\n\n        # @!visibility public\n\n        #\n        # Define a key column. By default, the first key column defined for a\n        # record will be a partition key, and the following keys will be\n        # clustering columns. This behavior can be changed using the\n        # `:partition` option\n        #\n        # @param name [Symbol] the name of the key column\n        # @param type [Symbol] the type of the key column\n        # @param options [Options] options for the key column\n        # @option options [Boolean] :partition (false) make this a partition\n        #   key even if it is not the first key column\n        # @option options [Boolean] :auto (false) automatically initialize this\n        #   key with a UUID value for new records. Only valid for `uuid` and\n        #   `timeuuid` columns.\n        # @option options [:asc,:desc] :order whether rows should be ordered\n        #   ascending or descending by this column. Only valid for clustering\n        #   columns\n        # @return [void]\n        #\n        # @note {Associations::ClassMethods#belongs_to belongs_to} implicitly\n        #   defines key columns.\n        #\n        # @see\n        #   http://cassandra.apache.org/doc/cql3/CQL.html#createTablepartitionClustering\n        #   CQL documentation on compound primary keys\n        #\n        def key(name, type, options = {})\n          def_accessors(name)\n          if options.fetch(:auto, false)\n            unless Type[type].is_a?(Cequel::Type::Uuid)\n              fail ArgumentError, \":auto option only valid for UUID columns\"\n            end\n            default = -> { Cequel.uuid } if options[:auto]\n          else\n            default = options[:default]\n          end\n          set_attribute_default(name, default)\n        end\n\n        # rubocop:enable LineLength\n\n        #\n        # Define a data column\n        #\n        # @param name [Symbol] the name of the column\n        # @param type [Symbol] the type of the column\n        # @param options [Options] options for the column\n        # @option options [Object,Proc] :default a default value for the\n        #   column, or a proc that returns a default value for the column\n        # @option options [Boolean,Symbol] :index create a secondary index on\n        #   this column\n        # @return [void]\n        #\n        # @note Secondary indexes are not nearly as flexible as primary keys:\n        #   you cannot query for multiple values or for ranges of values. You\n        #   also cannot combine a secondary index restriction with a primary\n        #   key restriction in the same query, nor can you combine more than\n        #   one secondary index restriction in the same query.\n        #\n        def column(name, type, options = {})\n          def_accessors(name)\n          set_attribute_default(name, options[:default])\n        end\n\n        #\n        # Define a list column\n        #\n        # @param name [Symbol] the name of the list\n        # @param type [Symbol] the type of the elements in the list\n        # @param options [Options] options for the list\n        # @option options [Object,Proc] :default ([]) a default value for the\n        #   column, or a proc that returns a default value for the column\n        # @return [void]\n        #\n        # @see Record::List\n        # @since 1.0.0\n        #\n        def list(name, type, options = {})\n          def_collection_accessors(name, List)\n          set_attribute_default(name, options[:default])\n          set_empty_attribute(name) { [] }\n        end\n\n        #\n        # Define a set column\n        #\n        # @param name [Symbol] the name of the set\n        # @param type [Symbol] the type of the elements in the set\n        # @param options [Options] options for the set\n        # @option options [Object,Proc] :default (Set[]) a default value for\n        #   the column, or a proc that returns a default value for the column\n        # @return [void]\n        #\n        # @see Record::Set\n        # @since 1.0.0\n        #\n        def set(name, type, options = {})\n          def_collection_accessors(name, Set)\n          set_attribute_default(name, options[:default])\n          set_empty_attribute(name) { ::Set[] }\n        end\n\n        #\n        # Define a map column\n        #\n        # @param name [Symbol] the name of the map\n        # @param key_type [Symbol] the type of the keys in the set\n        # @param options [Options] options for the set\n        # @option options [Object,Proc] :default ({}) a default value for the\n        #   column, or a proc that returns a default value for the column\n        # @return [void]\n        #\n        # @see Record::Map\n        # @since 1.0.0\n        #\n        def map(name, key_type, value_type, options = {})\n          def_collection_accessors(name, Map)\n          set_attribute_default(name, options[:default])\n          set_empty_attribute(name) { {} }\n        end\n\n        private\n\n        def def_accessors(name)\n          name = name.to_sym\n          def_reader(name)\n          def_writer(name)\n        end\n\n        def def_reader(name)\n          module_eval <<-RUBY, __FILE__, __LINE__+1\n            def #{name}; read_attribute(#{name.inspect}); end\n          RUBY\n        end\n\n        def def_writer(name)\n          module_eval <<-RUBY, __FILE__, __LINE__+1\n            def #{name}=(value); write_attribute(#{name.inspect}, value); end\n          RUBY\n        end\n\n        def def_collection_accessors(name, collection_proxy_class)\n          def_collection_reader(name, collection_proxy_class)\n          def_collection_writer(name)\n        end\n\n        def def_collection_reader(name, collection_proxy_class)\n          module_eval <<-RUBY, __FILE__, __LINE__+1\n            def #{name}\n              proxy_collection(#{name.inspect}, #{collection_proxy_class})\n            end\n          RUBY\n        end\n\n        def def_collection_writer(name)\n          module_eval <<-RUBY, __FILE__, __LINE__+1\n            def #{name}=(value)\n              reset_collection_proxy(#{name.inspect})\n              write_attribute(#{name.inspect}, value)\n            end\n          RUBY\n        end\n\n        def set_attribute_default(name, default)\n          default_attributes[name.to_sym] = default\n        end\n\n        def set_empty_attribute(name, &block)\n          empty_attributes[name.to_sym] = block\n        end\n      end\n\n      # @private\n      def initialize(attributes = {}, record_collection = nil)\n        @attributes, @record_collection = attributes, record_collection\n        @collection_proxies = {}\n      end\n\n      #\n      # @return [Array<Symbol>] list of names of attributes on this record\n      #\n      def attribute_names\n        @attributes.keys\n      end\n\n      #\n      # @return [Hash<Symbol,Object>] map of column names to values currently\n      #   set on this record\n      #\n      def attributes\n        attribute_names.each_with_object({}) do |name, attributes|\n          attributes[name] = read_attribute(name)\n        end\n      end\n\n      #\n      # Set attributes on the record. Each attribute is set via the setter\n      # method; virtual (non-column) attributes are allowed.\n      #\n      # @param attributes [Hash] map of attribute names to values\n      # @return [void]\n      #\n      def attributes=(attributes)\n        attributes.each_pair do |attribute, value|\n          __send__(:\"#{attribute}=\", value)\n        end\n      end\n\n      #\n      # Read an attribute\n      #\n      # @param column_name [Symbol] the name of the column\n      # @return the value of that column\n      # @raise [MissingAttributeError] if the attribute has not been loaded\n      # @raise [UnknownAttributeError] if the attribute does not exist\n      #\n      def [](column_name)\n        read_attribute(column_name)\n      end\n\n      #\n      # Write an attribute\n      #\n      # @param column_name [Symbol] name of the column to write\n      # @param value the value to write to the column\n      # @return [void]\n      # @raise [UnknownAttributeError] if the attribute does not exist\n      #\n      def []=(column_name, value)\n        write_attribute(column_name, value)\n      end\n\n      #\n      # @return [Boolean] true if this record has the same type and key\n      #   attributes as the other record\n      def ==(other)\n        if key_values.any? { |value| value.nil? }\n          super\n        else\n          self.class == other.class && key_values == other.key_values\n        end\n      end\n\n      #\n      # @return [String] string representation of the record\n      #\n      def inspect\n        inspected_attributes = attributes.each_pair.map do |attr, value|\n          inspected_value = Cequel.uuid?(value) ?\n            value.to_s :\n            value.inspect\n          \"#{attr}: #{inspected_value}\"\n        end\n        \"#<#{self.class} #{inspected_attributes.join(\", \")}>\"\n      end\n\n      protected\n\n      def read_attribute(name)\n        @attributes.fetch(name)\n      rescue KeyError\n        if self.class.reflect_on_column(name)\n          fail MissingAttributeError, \"missing attribute: #{name}\"\n        else\n          fail UnknownAttributeError, \"unknown attribute: #{name}\"\n        end\n      end\n\n      def write_attribute(name, value)\n        unless self.class.reflect_on_column(name)\n          fail UnknownAttributeError, \"unknown attribute: #{name}\"\n        end\n        @attributes[name] = value\n      end\n\n      private\n\n      def proxy_collection(column_name, proxy_class)\n        column = self.class.reflect_on_column(column_name)\n        collection_proxies[column_name] ||= proxy_class.new(self, column)\n      end\n\n      def reset_collection_proxy(name)\n        collection_proxies.delete(name)\n      end\n\n      def init_attributes(new_attributes)\n        @attributes = {}\n        new_attributes.each_pair do |name, value|\n          if value.nil?\n            value = empty_attributes.fetch(name.to_sym) { -> {} }.call\n          end\n          @attributes[name.to_sym] = value\n        end\n        @attributes\n      end\n\n      def initialize_new_record(attributes = {})\n        dynamic_defaults = default_attributes\n          .select { |name, value| value.is_a?(Proc) }\n        new_attributes = Marshal.load(Marshal.dump(\n          default_attributes.except(*dynamic_defaults.keys)))\n        dynamic_defaults.each { |name, p| new_attributes[name] = p.call }\n        init_attributes(new_attributes)\n\n        @new_record = true\n        yield self if block_given?\n        self.attributes = attributes\n        loaded!\n        self\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[197,0],[197,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":232,"goalBufferRange":null,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[{"patches":[{"oldRange":[[198,0],[198,0]],"newRange":[[198,0],[198,0]],"oldText":"","newText":"","normalizeLineEndings":true,"markerPatches":{},"deserializer":"BufferPatch"},{"oldRange":[[197,0],[198,0]],"newRange":[[197,0],[197,0]],"oldText":"\n","newText":"","normalizeLineEndings":{},"markerPatches":{},"deserializer":"BufferPatch"}],"deserializer":"Transaction"}],"deserializer":"History"},"filePath":"/Users/tra/github/cequel/lib/cequel/record/properties.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"7b99999b41a00d4309af7a98a6f904119f8a388e","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":56,"softTabs":true,"displayBuffer":{"id":57,"softWrap":false,"editorWidthInChars":163,"scrollTop":12,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/cequel/spec/examples/record/map_spec.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":204,"softTabs":true,"displayBuffer":{"id":205,"softWrap":false,"editorWidthInChars":156,"scrollTop":11129,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/cequel/lib/cequel/record/collection.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":232,"softTabs":true,"displayBuffer":{"id":233,"softWrap":false,"editorWidthInChars":156,"scrollTop":18,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/cequel/lib/cequel/record/properties.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":224,"softTabs":true,"displayBuffer":{"id":225,"softWrap":false,"editorWidthInChars":156,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/cequel/lib/cequel/type.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":129,"softTabs":true,"displayBuffer":{"id":130,"softWrap":false,"editorWidthInChars":163,"scrollTop":10388,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/cequel/lib/cequel/metal/data_set.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":133,"softTabs":true,"displayBuffer":{"id":134,"softWrap":false,"editorWidthInChars":163,"scrollTop":761,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/cequel/lib/cequel/metal/writer.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":109,"softTabs":true,"displayBuffer":{"id":110,"softWrap":false,"editorWidthInChars":163,"scrollTop":1070,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/cequel/spec/support/helpers.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":113,"softTabs":true,"displayBuffer":{"id":114,"softWrap":false,"editorWidthInChars":163,"scrollTop":6814,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/cequel/lib/cequel/record/persistence.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":125,"softTabs":true,"displayBuffer":{"id":126,"softWrap":false,"editorWidthInChars":163,"scrollTop":672,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/cequel/lib/cequel/metal/deleter.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/tra/github/cequel/lib/cequel/record/collection.rb","focused":false,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-ruby"],"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":{"findHistory":["deleter","de","@delete_row","empty","class Map","to_mod","statements","concat","statements","read_attr","def_reader"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}},"projectViewState":{"findHistory":["logger","delete_row","[](","Type","include","[](","include","[](","include","type'","::Type","def []"],"replaceHistory":[],"pathsHistory":[],"modelState":{"useRegex":false,"caseSensitive":true}},"resultsModelState":{"useRegex":false,"caseSensitive":true}},"fuzzy-finder":{"/Users/tra/github/cequel/spec/examples/record/map_spec.rb":1405551755179,"/Users/tra/github/cequel/lib/cequel/record/collection.rb":1405635979051,"/Users/tra/github/cequel/lib/cequel/record/properties.rb":1405635286909,"/Users/tra/github/cequel/lib/cequel/type.rb":1405635089385,"/Users/tra/github/cequel/lib/cequel/metal/data_set.rb":1405550115882,"/Users/tra/github/cequel/lib/cequel/metal/writer.rb":1405551488721,"/Users/tra/github/cequel/spec/support/helpers.rb":1405549863640,"/Users/tra/github/cequel/lib/cequel/record/persistence.rb":1405549923871,"/Users/tra/github/cequel/lib/cequel/metal/deleter.rb":1405551243017},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":164319934},"tree-view":{"directoryExpansionStates":{"lib":{"cequel":{"metal":{},"record":{}}},"spec":{"examples":{"record":{}}}},"selectedPath":"/Users/tra/github/cequel/lib/cequel/record/collection.rb","hasFocus":false,"attached":true,"scrollLeft":1,"scrollTop":0,"width":269}}}