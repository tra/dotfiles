{"mode":"editor","version":1,"windowDimensions":{"x":141,"y":24,"width":1375,"height":1398},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/tra/github/weather-forecasts","buffers":[{"text":"module WeatherForecasts\n  module_function\n\n  def env\n    @@env ||= (ENV['ENV'] || :production)\n  end\n\n  def client(options = {})\n    Client.new(options)\n  end\n\n  def root_path\n    File.expand_path(File.join(File.dirname(__FILE__), \"../\"))\n  end\n\n  def vendor_path\n    File.join(root_path, \"vendor\")\n  end\nend\n\nrequire 'weather_forecasts/dwml'\nrequire 'weather_forecasts/client'\nrequire 'weather_forecasts/client/version'\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":41},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"54c3b7d69601cf73cb8f25abce429ee5374d8c10","deserializer":"TextBuffer"},{"text":"lib = File.expand_path('../lib/', __FILE__)\n$:.unshift lib unless $:.include?(lib)\n\nrequire 'weather_forecasts/client/version'\n\nGem::Specification.new do |s|\n  s.name = \"weather-forecasts\"\n  s.version = WeatherForecasts::Client::VERSION\n  s.platform = Gem::Platform::RUBY\n  s.authors = [\"Angelo Lakra\"]\n  s.email = [\"angelo.lakra@gmail.com\"]\n  s.summary = \"Client library for retrieving data from NOAA's weather forecast API\"\n\n  s.description = <<-EOT\n   Utilizing the NDFD (NWS Digital Forecast Database), weather forecasts are retrieved from NOAA's SOAP API and then translated into simple array/hash structures in Ruby.\"\n  EOT\n\n  s.homepage = \"https://github.com/alakra/weather-forecasts\"\n  s.bindir = 'bin'\n  s.licenses = ['MIT']\n\n  s.extra_rdoc_files = ['README.md']\n\n  s.executables << 'wf-console'\n\n  s.add_runtime_dependency 'savon', '~> 2.4.0', '>= 2.4.0'\n  s.add_runtime_dependency 'nokogiri', '~> 1.6.1', '>= 1.6.1'\n  s.add_runtime_dependency 'multi_json', '~> 1.9.0', '>= 1.9.0'\n  s.add_runtime_dependency 'activesupport', '~> 4.1.0', '>= 4.1.0'\n  s.add_runtime_dependency 'http_logger', '~> 0.4.2', '>= 0.4.2'\n\n  s.post_install_message = \"To start querying weather forecasts immediately, type `wf-console`.\"\n\n  s.required_ruby_version = '>= 1.9.3'\n\n  s.files = `git ls-files`.split(\"\\n\")\n  s.test_files = `git ls-files -- spec/*`.split(\"\\n\")\n  s.require_path = 'lib'\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":53},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/weather-forecasts/weather-forecasts.gemspec","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"6ff73b9f8b24560362a0af88b45d0e751074c600","deserializer":"TextBuffer"},{"text":"require 'nokogiri'\nrequire 'savon'\nrequire 'http_logger'\n\nrequire 'weather_forecasts/client/error'\nrequire 'weather_forecasts/client/query'\n\n# Original web service description: http://graphical.weather.gov/xml/\nmodule WeatherForecasts\n  class Client\n    DEFAULT_WSDL = \"http://graphical.weather.gov/xml/DWMLgen/wsdl/ndfdXML.wsdl\"\n\n    def initialize(options = {})\n      @options = options\n\n      if options[:wsdl].blank?\n        @options.merge!(:wsdl => DEFAULT_WSDL)\n      end\n\n      if options[:logger].present?\n        HttpLogger.logger = options[:logger]\n      end\n    end\n\n    def soap_client\n      @soap_client ||= Savon.client(@options)\n    end\n\n    #\n    # Query Methods\n    ############################################################################\n\n    def select(*options)\n      SelectQuery.new(soap_client, options)\n    end\n\n    def select_by_days\n      SelectByDaysQuery.new(soap_client)\n    end\n\n    def select_coordinates_by_zip\n      SelectCoordinatesByZipQuery.new(soap_client)\n    end\n\n    def select_coordinates_by_cities\n      SelectCoordinatesByCitiesQuery.new(soap_client)\n    end\n\n    def select_square_coordinates\n      SelectSquareCoordinatesQuery.new(soap_client)\n    end\n\n    def select_gridpoint_coordinates\n      SelectGridpointCoordinatesQuery.new(soap_client)\n    end\n\n    def select_linepoint_coordinates\n      SelectLinepointCoordinatesQuery.new(soap_client)\n    end\n\n    def select_corner_coordinates\n      SelectCornerCoordinatesQuery.new(soap_client)\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[10,4],[10,16]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":85,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/client.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"474dea0ac077a357798cd283aced8cf99ab4d370","deserializer":"TextBuffer"},{"text":"require 'spec_helper'\n\ndescribe WeatherForecasts::Client do\n  subject { WeatherForecasts.client }\n\n  let(:options) { double }\n\n  describe \"#soap_client\" do\n    it \"returns a soap client\" do\n      subject.soap_client.should be_a(Savon::Client)\n    end\n  end\n\n  describe \"#select\" do\n    it \"returns as WeatherForecasts::Client::SelectQuery object\" do\n      subject.select(options).should be_a(WeatherForecasts::Client::SelectQuery)\n    end\n  end\n\n  describe \"#select_by_days\" do\n    it \"returns as WeatherForecasts::Client::SelectByDaysQuery object\" do\n      subject.select_by_days.should be_a(WeatherForecasts::Client::SelectByDaysQuery)\n    end\n  end\n\n  describe \"#select_coordinates_by_zip\" do\n    it \"returns as WeatherForecasts::Client::SelectCoordinatesByZipQuery object\" do\n      subject.select_coordinates_by_zip.should be_a(WeatherForecasts::Client::SelectCoordinatesByZipQuery)\n    end\n  end\n\n  describe \"#select_gridpoint_coordinates\" do\n    it \"returns as WeatherForecasts::Client::SelectGridpointCoordinatesQuery object\" do\n      subject.select_gridpoint_coordinates.should be_a(WeatherForecasts::Client::SelectGridpointCoordinatesQuery)\n    end\n  end\n\n  describe \"#select_linepoint_coordinates\" do\n    it \"returns as WeatherForecasts::Client::SelectLinepointCoordinatesQuery object\" do\n      subject.select_linepoint_coordinates.should be_a(WeatherForecasts::Client::SelectLinepointCoordinatesQuery)\n    end\n  end\n\n  describe \"#select_cities_coordinates\" do\n    it \"returns as WeatherForecasts::Client::SelectCitiesCoordinatesQuery object\" do\n      subject.select_coordinates_by_cities.should be_a(WeatherForecasts::Client::SelectCoordinatesByCitiesQuery)\n    end\n  end\n\n  describe \"#select_corner_coordinates\" do\n    it \"returns as WeatherForecasts::Client::SelectCornerCoordinatesQuery object\" do\n      subject.select_corner_coordinates.should be_a(WeatherForecasts::Client::SelectCornerCoordinatesQuery)\n    end\n  end\n\n  describe \"#select_square_coordinates\" do\n    it \"returns as WeatherForecasts::Client::SelectSquareCoordinatesQuery object\" do\n      subject.select_square_coordinates.should be_a(WeatherForecasts::Client::SelectSquareCoordinatesQuery)\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":128},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/weather-forecasts/spec/lib/ndfd/client_spec.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"e07476c769e3647cd4c34a78797547805f77e523","deserializer":"TextBuffer"},{"text":"require 'spec_helper'\n\ndescribe WeatherForecasts::Client::SelectCornerCoordinatesQuery do\n  let(:conditions) {\n    {\n      :sector => :conus\n    }\n  }\n\n  let(:null_logger)  { Logger.new(File.open(\"/dev/null\", \"w\")) }\n\n  subject { WeatherForecasts.client(:logger => null_logger).select_corner_coordinates }\n\n  # Silence savon's HTTP request logger\n  before(:each) do\n    HTTPI.logger = null_logger\n  end\n\n  describe \"#execute\" do\n    before(:each) do\n      VCR.use_cassette('select_corner_coordinates_query') do\n        @response = subject.where(conditions).execute\n      end\n    end\n\n    it \"returns a valid response\" do\n      @response.should be_a(Array)\n\n      @response.first.keys.should include(:latitude, :longitude)\n      @response.first.values.each do |value|\n        value.should be_a(Numeric)\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":144},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/weather-forecasts/spec/lib/ndfd/client/query/select_corner_coordinates_query_spec.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"31942c19e111079ffa59148a26d00f36b4687e9a","deserializer":"TextBuffer"},{"text":"module WeatherForecasts\n  class Client\n    class SelectQuery < Query\n      include QueryUtilities\n\n      set_selection_attributes *FORECAST_ELEMENTS.keys\n\n      property :coordinates, :type => Array, :required => true, :required_keys => [:latitude, :longitude]\n      property :product,     :type => String, :options => [\"time-series\", \"glance\"], :required => true, :default => \"time-series\"\n      property :unit,        :type => String, :options => [\"e\", \"m\"], :default => \"e\"\n\n      property :start_time,  :type => ActiveSupport::TimeWithZone\n      property :end_time,    :type => ActiveSupport::TimeWithZone\n\n      def execute\n        validate\n\n        response = soap_client.call(:ndf_dgen_lat_lon_list, :message => build_message)\n        document = Nokogiri::XML(response.body[:ndf_dgen_lat_lon_list_response][:dwml_out])\n        transform_to_hash(document)\n      end\n\n      protected\n\n      def transform_to_hash(doc)\n        WeatherForecasts::DWML.new(doc).process\n      end\n\n      def build_message\n        {\n          :listLatLon        => build_coordinates(conditions[:coordinates]),\n          :product           => conditions[:product],\n          :startTime         => conditions[:start_time].iso8601,\n          :endTime           => conditions[:end_time].iso8601,\n          :Unit              => conditions[:unit],\n          :weatherParameters => build_weather_parameters\n        }\n      end\n\n      def build_weather_parameters\n        available_selections.attributes.inject({}) do |memo, attr|\n          is_requested = select_attributes.include?(attr) ? 1 : 0\n          memo.merge!(attr => is_requested)\n        end\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":175},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/client/query/select_query.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"28776aa19f405c768b6f0bc083e340882bcb8824","deserializer":"TextBuffer"},{"text":"require 'weather_forecasts/dwml/location'\nrequire 'weather_forecasts/dwml/time_layout'\nrequire 'weather_forecasts/dwml/parameter_extractor'\n\nmodule WeatherForecasts\n  class DWML\n    class DataExtractor\n      attr_reader :output, :element\n\n      def initialize(element)\n        @element = element\n        @locations = []\n        @time_layouts = []\n        @output = {}\n      end\n\n      def process\n        extract_locations\n        extract_time_layouts\n        extract_parameters\n\n        output\n      end\n\n      protected\n\n      def extract_locations\n        @locations = Location.extract(element.xpath(\"location\"))\n      end\n\n      def extract_time_layouts\n        @time_layouts = TimeLayout.extract(element.xpath(\"time-layout\"))\n      end\n\n      def extract_parameters\n        parameters = element.xpath(\"parameters\")\n\n        @output.merge!(\n          :parameters => parameters.inject({}) do |memo, parameter|\n            location = location_for_parameter(parameter)\n            extractor = ParameterExtractor.new(parameter, location, @time_layouts)\n            memo.merge!(location.location_key => extractor.process)\n            memo\n          end\n        )\n      end\n\n      def location_for_parameter(parameter)\n        @locations.detect do |location|\n          parameter.attributes[\"applicable-location\"].text == location.location_key\n        end\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":184},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/data_extractor.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"c84d384ab1ad607984ca29d596e99d7c62f21716","deserializer":"TextBuffer"},{"text":"module WeatherForecasts\n  class DWML\n    class TimeLayout\n      class << self\n        def extract(elements)\n          elements.map { |element| new(element) }\n        end\n      end\n\n      attr_reader :element, :time_coordinate, :summarization, :layout_key, :valid_times\n\n      def initialize(element)\n        @element = element\n        @valid_times = []\n\n        extract_time_coordinate\n        extract_summarization\n        extract_layout_key\n        extract_valid_times\n      end\n\n      protected\n\n      def extract_time_coordinate\n        @time_coordinate = element.attributes[\"time-coordinate\"].text\n      end\n\n      def extract_summarization\n        @summarization = element.attributes[\"summarization\"].text\n      end\n\n      def extract_layout_key\n        @layout_key = element.xpath(\"layout-key\").first.text\n      end\n\n      def extract_valid_times\n        start_times = element.xpath(\"start-valid-time\")\n        stop_times  = element.xpath(\"end-valid-time\")\n\n        start_times.each_with_index do |start_time, index|\n          @valid_times << ValidTime.new(start_time.text, stop_times[index].try(:text))\n        end\n      end\n\n      class ValidTime\n        attr_reader :start, :stop\n\n        def initialize(start, stop)\n          @start = Time.zone.parse(start.to_s)\n          @stop = Time.zone.parse(stop.to_s)\n        end\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":188},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/time_layout.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"e2b84256eb7135b549129b1f07dfefdc5672aefa","deserializer":"TextBuffer"},{"text":"module WeatherForecasts\n  class DWML\n    class ParameterExtractor\n      attr_reader :output, :element, :location, :time_layouts\n\n      def initialize(element, location, time_layouts)\n        @element      = element\n        @location     = location\n        @time_layouts = time_layouts\n\n        @output = {\n          :latitude  => location.latitude,\n          :longitude => location.longitude\n        }\n      end\n\n      def process\n        extract_temperatures\n        extract_precipitation\n        extract_wind_speed\n        extract_wind_direction\n        extract_cloud_cover\n        extract_probability_of_precipitation\n        extract_fire_weather\n        extract_convective_hazard\n        extract_climate_anomaly\n        extract_humidity\n        extract_weather\n        extract_conditions_icons\n        extract_hazards\n        extract_water_state\n\n        output\n      end\n\n      protected\n\n      def extract_temperatures\n        extract_basic_time_series(:temperature)\n      end\n\n      def extract_precipitation\n        extract_basic_time_series(:precipitation)\n      end\n\n      def extract_wind_speed\n        extract_basic_time_series(:\"wind-speed\")\n      end\n\n      def extract_wind_direction\n        extract_basic_time_series(:direction)\n      end\n\n      def extract_cloud_cover\n        extract_basic_time_series(:\"cloud-amount\")\n      end\n\n      def extract_probability_of_precipitation\n        extract_basic_time_series(:\"probability-of-precipitation\")\n      end\n\n      def extract_humidity\n        extract_basic_time_series(:humidity)\n      end\n\n      def extract_fire_weather\n        extract_basic_time_series(:\"fire-weather\")\n      end\n\n      def extract_water_state\n        node = element.xpath(\"water-state\").first\n        return if node.blank?\n\n        @output[:\"water-state\"] = {}\n        layout = lookup_time_layout(node)\n\n        waves_node = node.xpath(\"waves\").first\n        @output[:\"water-state\"][:type] = waves_node.attributes[\"type\"].text\n        @output[:\"water-state\"][:unit] = waves_node.attributes[\"units\"].text\n        @output[:\"water-state\"][:values] = []\n\n        waves_node.xpath(\"value\").each_with_index do |value, index|\n          @output[:\"water-state\"][:values] << {\n            :value      => value.text,\n            :start_time => layout.valid_times[index].start\n          }\n        end\n      end\n\n      def extract_hazards\n        node = element.xpath(\"hazards\").first\n        return if node.blank?\n\n        layout = lookup_time_layout(node)\n\n        @output[:hazards] = {\n          :name => node.xpath(\"name\").first.text,\n          :conditions => node.xpath(\"hazard-conditions\").each_with_index.map do |condition_node, index|\n            hazard_node = condition_node.xpath(\"hazard\").first\n            next if hazard_node.blank?\n\n            {\n              :code         => hazard_node.attributes[\"hazardCode\"].text,\n              :phenomena    => hazard_node.attributes[\"phenomena\"].text,\n              :significance => hazard_node.attributes[\"significance\"].text,\n              :type         => hazard_node.attributes[\"hazardType\"].text,\n              :url          => hazard_node.xpath(\"hazardTextURL\").first.text,\n              :start_time   => layout.valid_times[index].start\n            }\n          end.compact\n        }\n      end\n\n      def extract_conditions_icons\n        node = element.xpath(\"conditions-icon\").first\n        return if node.blank?\n\n        layout = lookup_time_layout(node)\n\n        @output[:\"conditions-icon\"] = {\n          :name  => node.xpath(\"name\").text,\n          :type  => node.attributes[\"type\"].text,\n          :links => node.xpath(\"icon-link\").each_with_index.map do |icon_node, index|\n            {\n              :link        => icon_node.text,\n              :start_time  => layout.valid_times[index].start\n            }\n          end\n        }\n      end\n\n      def extract_convective_hazard\n        return if element.xpath(\"convective-hazard\").blank?\n\n        @output[:\"convective-hazard\"] ||= {\n          :outlook => { :name => nil, :values => []},\n          :\"severe-component\" => []\n        }\n\n        extract_convective_hazard_outlook\n        extract_convective_hazard_severity\n      end\n\n      def extract_convective_hazard_outlook\n        outlook_node = element.xpath(\"convective-hazard/outlook\").first\n        layout = lookup_time_layout(outlook_node)\n\n        @output[:\"convective-hazard\"][:outlook][:name] = outlook_node.xpath(\"node\").text\n\n        outlook_node.xpath(\"value\").each_with_index do |value, index|\n          @output[:\"convective-hazard\"][:outlook][:values] << {\n            :start_time => layout.valid_times[index].start,\n            :end_time   => layout.valid_times[index].stop,\n            :value      => value.text\n          }\n        end\n      end\n\n      def extract_convective_hazard_severity\n        element.xpath(\"convective-hazard/severe-component\").each do |node|\n          layout = lookup_time_layout(node)\n\n          hsh = {\n            :name   => node.xpath(\"name\").first.text,\n            :type   => node.attributes[\"type\"].text,\n            :unit   => node.attributes[\"units\"].text,\n            :values => node.xpath(\"value\").each_with_index.map do |value, index|\n              {\n                :value      => value.text,\n                :start_time => layout.valid_times[index].start,\n                :end_time   => layout.valid_times[index].stop\n              }\n            end\n          }\n\n          @output[:\"convective-hazard\"][:\"severe-component\"] << hsh\n        end\n      end\n\n      def extract_climate_anomaly\n        return if element.xpath(\"climate-anomaly\").blank?\n\n        [:weekly, :monthly, :seasonal].each do |period|\n          element.xpath(\"climate-anomaly/#{period.to_s}\").each_with_index do |node|\n            layout = lookup_time_layout(node)\n            valid_time = layout.valid_times.first\n\n            @output[:\"climate-anomaly\"] ||= {}\n            @output[:\"climate-anomaly\"][period] ||= []\n            @output[:\"climate-anomaly\"][period] << {\n              :name       => node.xpath(\"name\").first.text,\n              :value      => node.xpath(\"value\").first.text,\n              :type       => node.attributes[\"type\"].text,\n              :unit       => node.attributes[\"units\"].text,\n              :start_time => valid_time.start,\n              :end_time   => valid_time.stop\n            }\n          end\n        end\n      end\n\n      def extract_weather\n        node = element.xpath(\"weather\")\n        return if node.blank?\n\n        node.map do |weather_node|\n          @output[:weather] ||= {}\n          @output[:weather][:name] = weather_node.xpath(\"name\").text\n          @output[:weather][:conditions] ||= []\n\n          layout = lookup_time_layout(weather_node)\n\n          weather_node.xpath(\"weather-conditions\").each_with_index do |condition, index|\n            value = condition.xpath(\"value\").first\n            next if value.blank?\n\n            visibility_node = value.xpath(\"visibility\").first\n            visibility = if visibility_node.present? && visibility_node.text.present?\n                           {\n                             :unit => visibility_node.attributes[\"units\"].text,\n                             :value => visibility_node.text.to_f\n                           }\n                         else\n                           \"\"\n                         end\n\n            hsh = {\n              :start_time     => layout.valid_times[index].start,\n              :coverage       => value.attributes[\"coverage\"].text,\n              :intensity      => value.attributes[\"intensity\"].text,\n              :\"weather-type\" => value.attributes[\"weather-type\"].text,\n              :qualifier      => value.attributes[\"qualifier\"].text,\n              :visibility     => visibility\n            }\n\n            additive = value.attributes[\"additive\"]\n            hsh.merge!(:additive => additive) if additive.present?\n\n            @output[:weather][:conditions] << hsh\n          end\n        end\n      end\n\n      def extract_basic_time_series(metric)\n        metric_node = element.xpath(metric.to_s)\n        return if metric_node.blank?\n\n        metric_node.map do |node|\n          layout = lookup_time_layout(node)\n          type = node.attributes[\"type\"].text.to_sym\n          unit = node.attributes[\"units\"].try(:text)\n\n          @output[metric] ||= {}\n          @output[metric][type] ||= {}\n          @output[metric][type][:name] = node.xpath(\"name\").text\n          @output[metric][type][:values] = []\n\n          node.xpath(\"value\").each_with_index do |value, index|\n            hsh = {\n              :value      => value.text.to_f,\n              :start_time => layout.valid_times[index].start\n            }\n\n            end_time = layout.valid_times[index].stop\n\n            hsh.merge!(:unit => unit) if unit.present?\n            hsh.merge!(:end_time => end_time) if end_time.present?\n\n            @output[metric][type][:values] << hsh\n          end\n        end\n      end\n\n      def lookup_time_layout(node)\n        @time_layouts.detect do |layout|\n          node.attributes[\"time-layout\"].text == layout.layout_key\n        end\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":192},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/parameter_extractor.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"5b1003e2c4542d662505c6f3a2fa33d49c283a9a","deserializer":"TextBuffer"},{"text":"module WeatherForecasts\n  class DWML\n    class Location\n      class << self\n        def extract(elements)\n          elements.map { |element| new(element) }\n        end\n      end\n\n      attr_reader :element, :location_key, :latitude, :longitude\n\n      def initialize(element)\n        @element = element\n\n        extract_key\n        extract_coords\n      end\n\n      protected\n\n      def extract_key\n        @location_key = element.xpath(\"location-key\").first.text\n      end\n\n      def extract_coords\n        point = element.xpath('point').first\n\n        @latitude  = point.attributes[\"latitude\"].text.to_f\n        @longitude = point.attributes[\"longitude\"].text.to_f\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":196},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/location.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"7169e2baf003e43f4b470bf4fa7b99230ebee013","deserializer":"TextBuffer"},{"text":"module WeatherForecasts\n  class DWML\n    class HeadExtractor\n      attr_reader :output, :element\n\n      def initialize(element)\n        @element = element\n        @output = {}\n      end\n\n      def process\n        build_product\n        build_source\n        output\n      end\n\n      protected\n\n      def build_product\n        creation_date = Time.zone.parse(element.xpath('product/creation-date').text)\n\n        @output.merge!(\n          :product => {\n            :title         => element.xpath('product/title').text,\n            :field         => element.xpath('product/field').text,\n            :category      => element.xpath('product/category').text,\n            :creation_date => creation_date\n          }\n        )\n      end\n\n      def build_source\n        sub_center = element.xpath('source/production-center/sub-center').text\n        production_center = element.xpath('source/production-center').text\n\n        @output.merge!(\n          :source => {\n            :more_information => element.xpath('source/more-information').text,\n            :product_center   => production_center.gsub(sub_center, \" - #{sub_center}\"),\n            :disclaimer       => element.xpath('source/disclaimer').text,\n            :credit           => element.xpath('source/credit').text,\n            :credit_logo      => element.xpath('source/credit-logo').text,\n            :feedback         => element.xpath('source/feedback').text\n          }\n        )\n      end\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":200},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/head_extractor.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"a77f5169c2ffd7979ea0634cbdb42565a6e6c544","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":41,"softTabs":true,"displayBuffer":{"id":42,"softWrap":false,"editorWidthInChars":101,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":53,"softTabs":true,"displayBuffer":{"id":54,"softWrap":false,"editorWidthInChars":104,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/weather-forecasts/weather-forecasts.gemspec","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":85,"softTabs":true,"displayBuffer":{"id":86,"softWrap":false,"editorWidthInChars":108,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/client.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":184,"softTabs":true,"displayBuffer":{"id":185,"softWrap":false,"editorWidthInChars":115,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/data_extractor.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":188,"softTabs":true,"displayBuffer":{"id":189,"softWrap":false,"editorWidthInChars":115,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/time_layout.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":192,"softTabs":true,"displayBuffer":{"id":193,"softWrap":false,"editorWidthInChars":115,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/parameter_extractor.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":196,"softTabs":true,"displayBuffer":{"id":197,"softWrap":false,"editorWidthInChars":115,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/location.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":200,"softTabs":true,"displayBuffer":{"id":201,"softWrap":false,"editorWidthInChars":115,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/head_extractor.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":175,"softTabs":true,"displayBuffer":{"id":176,"softWrap":false,"editorWidthInChars":115,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/client/query/select_query.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":128,"softTabs":true,"displayBuffer":{"id":129,"softWrap":false,"editorWidthInChars":108,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/weather-forecasts/spec/lib/ndfd/client_spec.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":144,"softTabs":true,"displayBuffer":{"id":145,"softWrap":false,"editorWidthInChars":108,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/weather-forecasts/spec/lib/ndfd/client/query/select_corner_coordinates_query_spec.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/client.rb","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":{"findHistory":["client"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}}},"fuzzy-finder":{"/Users/tra/github/weather-forecasts/lib/weather_forecasts.rb":1400186541780,"/Users/tra/github/weather-forecasts/weather-forecasts.gemspec":1400186216826,"/Users/tra/github/weather-forecasts/lib/weather_forecasts/client.rb":1400186703669,"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/data_extractor.rb":1400186660244,"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/time_layout.rb":1400186656394,"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/parameter_extractor.rb":1400186657194,"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/location.rb":1400186657855,"/Users/tra/github/weather-forecasts/lib/weather_forecasts/dwml/head_extractor.rb":1400186658964,"/Users/tra/github/weather-forecasts/lib/weather_forecasts/client/query/select_query.rb":1400186583051,"/Users/tra/github/weather-forecasts/spec/lib/ndfd/client_spec.rb":1400186550020,"/Users/tra/github/weather-forecasts/spec/lib/ndfd/client/query/select_corner_coordinates_query_spec.rb":1400186544292},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":419979240},"tree-view":{"directoryExpansionStates":{".git":{},"lib":{"weather_forecasts":{"client":{},"dwml":{}}},"spec":{"lib":{"ndfd":{"client":{"query":{}}}}}},"selectedPath":"/Users/tra/github/weather-forecasts/lib/weather_forecasts/client.rb","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":2,"width":200}}}