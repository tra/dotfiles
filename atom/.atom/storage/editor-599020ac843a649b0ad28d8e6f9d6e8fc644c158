{"mode":"editor","version":1,"windowDimensions":{"x":606,"y":46,"width":1878,"height":1362,"maximized":false},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{"/Users/tra/src/advanced-apps/aa-prediction/config/persist.yml.example":"source.yaml","/Users/tra/src/advanced-apps/aa-observations/jobs/src/main/scala/com/comverge/BackfillMetricOrientedView.scala":"source.ruby"}},"project":{"path":"/Users/tra/src/advanced-apps","buffers":[{"text":"module Predictors\n  class GbmModel < RPredictorBase\n    R_CODE_LOC = Rails.root + 'R' + 'load.R'\n\n    attr_accessor :rms_errors\n\n    def initialize(*args)\n      super\n      prepare_model\n      initialize_prediction_tracking\n    end\n\n    def temporary_model_file\n      @temporary_model_file ||= Tempfile.new(\"gbm_model\")\n    end\n\n    def prepare_model\n      $statsd.time 'gbm_model.prepare_model' do\n        r_model = RModel[node.href].first\n        @rms_errors = (r_model.rms_errors || {})\n        encoded_blob = r_model.serialized_model\n        decoded_blob = [encoded_blob].pack(\"H*\")\n        File.open(temporary_model_file.path, \"wb\") { |f| f.write(decoded_blob) }\n      end\n    rescue => e\n      raise PredictionError, \"Unable to load serialized model\"\n    end\n\n    # Sorta hacky - tracks which index of the predictions array from R matches each time\n    def initialize_prediction_tracking\n      @predictions_for_time = {}\n      @prediction_counter = 0.step(Float::INFINITY, 1)\n    end\n\n    def initialize_r(an_r_in_ruby)\n      $statsd.time 'gbm_model.initialize_r' do\n        an_r_in_ruby.eval <<-EOF\n          require(gbm)\n          source('#{R_CODE_LOC}')\n          fit = readRDS('#{temporary_model_file.path}')\n        EOF\n      end\n    rescue StandardError, RinRuby::EngineClosed => e\n      raise PredictionError, \"Prediction Initialization Error: #{e.message}\"\n    end\n\n    # When we get our times adjusted, we have to redo predictions, and request\n    # new features. And for now, reset the faked weather.\n    # Basically just reset everything except the R instance we have with the model loaded.\n\n    def times_adjusted\n      @time_request = nil\n      @weather_lines = nil\n      @all_predictions = nil\n      @requests = nil\n      initialize_prediction_tracking\n    end\n\n    def predict(time, features)\n      @all_predictions ||= begin\n                             r.with_retry do\n                               feature_csv = features.r_formatted_csv\n                               Rails.logger.info { \"Feature CSV:\\n#{feature_csv}\" }\n                               $statsd.time 'gbm_model.predict' do\n                                 r.eval <<-EOF\n                                   s1 = Sys.time()\n                                   #{feature_csv}\n                                   elapsed_features = as.numeric(Sys.time() - s1)\n                                   start = Sys.time()\n                                   predictions = predict(fit, data)\n                                   elapsed = as.numeric(Sys.time() - start)\n                                 EOF\n                               end\n\n                               elapsed_in_features = r.pull(\"elapsed_features\")\n                               Rails.logger.info(\"Duration inside of Feature Send: #{elapsed_in_features}\")\n\n                               elapsed_in_r = r.pull(\"elapsed\")\n                               Rails.logger.info(\"Duration inside of R: #{elapsed_in_r}\")\n\n                               Array.wrap(r.pull(\"predictions\"))\n                             end\n                           end\n\n      @all_predictions[offset_for_time(time)]\n    rescue StandardError, RinRuby::EngineClosed => e\n      raise PredictionError, \"Prediction Error: #{e.message}\"\n    end\n\n    def requested_features\n      @requests ||=\n        [FeatureRequests::HourOfDayRequest,\n         FeatureRequests::DayOfWeekRequest,\n         FeatureRequests::DayOfYearRequest,\n         FeatureRequests::OutdoorAirTemperatureRequest,\n         FeatureRequests::DewPointRequest,\n         FeatureRequests::PreviousLoadRequest,\n      ].map{|klass| klass.new(node, since, before, interval) }\n    end\n\n    protected\n\n    def offset_for_time(time)\n      (time - since).div interval\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[38,0],[39,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":180,"goalBufferRange":null,"autoscroll":true,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/advanced-apps/aa-prediction/app/models/predictors/gbm_model.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"a4178484e1fc6ebc2a7b588815489961642e1474","deserializer":"TextBuffer"},{"text":"class AvailableLoadFactory\n  CACHE_CHECK_INTERVAL = 1.hour\n  MODEL_CLASS = Predictors::GbmModel\n\n  def self.fetch(node, since, before, interval)\n    cache[node].tap { |model|\n      model.adjust_times(since, before, interval)\n    }\n  end\n\n  def self.create_model(node)\n    MODEL_CLASS.new(node)\n  end\n\n  def self.prediction_type\n    :available_load\n  end\n\n  def self.cache\n    @cache ||= initialize_cache\n  end\n\n  # If needed, sets up the model cache.\n  # Wrap the values in additional layer of procs, since we need value_proc to\n  # have access to more than just the key & time.\n  def self.initialize_cache\n      RefreshingCache.new(timeout: CACHE_CHECK_INTERVAL,\n                          check_proc: ->(node, time) { RModel[node.href].first.at.to_time > time },\n                          value_proc: ->(node, time) { create_model(node) }\n                         )\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[13,0],[13,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":196,"autoscroll":true,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/advanced-apps/aa-prediction/app/models/available_load_factory.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"6873d7a262e8e4ab1b40f3cf9891aa10910fb092","deserializer":"TextBuffer"},{"text":"require 'forwardable'\n\n# Collection of feature vectors created from the specified feature\n# requests.\nclass FeatureCollection\n  include Enumerable\n  extend Forwardable\n\n  def initialize(feature_requests)\n    @feature_requests = feature_requests\n    future_responses # start the requests.\n  end\n\n  def_delegators :feature_vectors, :[], :each\n\n  def reify!\n    tap do\n      responses\n    end\n  end\n\n  def headers\n    feature_requests.map {|req| req.header_name }\n  end\n\n  # Writes a CSV block.  Does not attempt to wrap in R formatting, so if you\n  # send this straight to R, you'll want to use `r_formatted_csv`\n  def write_csv(io=StringIO.new)\n    $statsd.time 'feature_collection.write_csv' do\n      io.puts headers.join(\",\")\n      each do |features_vector|\n        io.puts features_vector.join(\",\")\n      end\n      io\n    end\n  end\n\n  # Returns a string with the CSV written in the format that can be EVAL'd by R.\n  # If you are having R just load in a file, use `write_csv` instead, as the\n  # `read.csv()` call here is only for direct EVALing of this block in R\n  def r_formatted_csv(r_variable_name=\"data\")\n    io = StringIO.new\n    io.write %|#{r_variable_name} = read.csv(text = \"|\n    write_csv(io)\n    io.write %|\")|\n    io.string\n  end\n\n  protected\n\n  attr_reader :feature_requests\n\n  def feature_vectors\n    responses.first.zip *responses[1..-1]\n  end\n\n  def responses\n    $statsd.time 'feature_collection.responses' do\n      future_responses.map do |it|\n        it.value\n      end\n    end\n  end\n\n  def future_responses\n    @future_responses ||= feature_requests.map{|it| Celluloid::Future.new {\n      $statsd.time \"feature_collection.#{it.header_name}\" do\n        it.call\n      end\n    } }\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[40,21],[40,21]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":200,"autoscroll":true,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/advanced-apps/aa-prediction/app/models/feature_collection.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"a8503192ba2d93415ccb9f488e4e0a24595c0e0f","deserializer":"TextBuffer"},{"text":"require 'r_with_reconninit'\n\n# Base Class for any models that wish to use R.\n#\n# Handles reconnecting to broken pipes\nmodule Predictors\n  class RPredictorBase\n    def initialize(node, since=nil, before=nil, interval=nil)\n      @node = node\n      if since && before && interval\n        adjust_times(since, before, interval)\n      end\n    end\n\n    # Adjust times, but bail out if we're already at this time\n    def adjust_times(since, before, interval)\n      if since == @since && before == @before && interval == @interval\n        Rails.logger.info(\"Adjusting times aborted - already at this time\")\n        return\n      end\n      Rails.logger.info(\"adjusting time\")\n\n      @since = since\n      @before = before\n      @interval = interval\n      times_adjusted\n    end\n\n    attr_reader :node, :since, :before, :interval\n\n    # Hook for initializing the R environment. Subclasses should\n    # override with class specific setup for the R process\n    #\n    # an_r_in_ruby - The RinRuby instance that should be initialized\n    def initialize_r(an_r_in_ruby)\n    end\n\n    # Callback for children to do any cleanup necessary\n    def times_adjusted\n    end\n\n    def instantaneous?\n      true\n    end\n\n    protected\n\n    def r\n      @r ||= RWithReconninit.new self.method(:initialize_r)\n    end\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":228,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/advanced-apps/aa-prediction/app/models/predictors/r_predictor_base.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"7d40084e99d7fc66a568db5e98e140e0f3d8eeb5","deserializer":"TextBuffer"},{"text":"require 'bookmark'\n\nclass LoadThreshold < ActiveRecord::Base\n  INFINITY_TIME = Time.parse(\"3000-01-01T00:00:00Z\")\n\n  belongs_to :applied_to_equipment_bookmark, class_name: \"Bookmark\"\n\n  delegate :href, to: :applied_to_equipment_bookmark, prefix: \"equipment\"\n\n  # The default first & last don't work with UUID\n  def self.first; order(\"created_at\").first; end\n  def self.last;  order(\"created_at DESC\").first; end\n\n  scope :for_equipment, ->(eq) { where(applied_to_equipment_bookmark: Bookmark(eq) ) }\n\n  scope :active_during, ->(since, before) {\n     where(\"NOT (since <  ? AND before <= ?)\", since, since)   # Not totally before or ending exactly on requested since time\n    .where(\"NOT (since >  ? AND before >  ?)\", before, before) # Not totally after requested times\n  }\n\n  scope :infinite, -> { where(before: INFINITY_TIME) }\n\n  attr_accessor :unit\n\n  def before\n    read_attribute(:before) || (self.before = INFINITY_TIME)\n  end\n\n\n  ##################################################\n  # Callbacks\n  ##################################################\n\n  # End any previous infinite thresholds with this new record's since time\n  before_create :update_previous_infinite_times\n  def update_previous_infinite_times\n    self.class\n      .for_equipment(equipment_href)\n      .where(\"before > ?\", self.since)\n      .each{ |lt| lt.before = self.since; lt.save! }\n  end\n\n  ##################################################\n  # Validations\n  ##################################################\n\n  validates :unit,  inclusion: { in: [\"KW\", \"kw\", \"Kw\", \"kW\"] }, on: :create\n  validates :since, presence: true\n  validates :before, presence: true\n  validate :since_before_before\n\n  def since_before_before\n    return if since.nil? or before.nil?\n    errors.add(:since, \"Since must occur before Before\") unless since <= before\n  end\n\n  def applied_to=(equip_url)\n    self.applied_to_equipment_bookmark = Bookmark(equip_url)\n  end\n\n  # Signature\n  #\n  #     applied_to\n  #     applied_to(hal_client)\n  #\n  # Returns the URL or (when `hal_client` is provided) a\n  # HalClient::Representation of this equipment to which this\n  # threshold applies.\n  def applied_to(hal_client=nil)\n    if hal_client\n      hal_client.get applied_to_equipment_bookmark.href\n    else\n      applied_to_equipment_bookmark.href\n    end\n  end\n\n  def owner_org_href(hal_client)\n    @owner_org_href ||= hal_client\n      .get(applied_to)\n      .related_hrefs(\"https://rels.comverge.com/owner\")\n      .first\n  end\n\n  def upper_limit\n    Power(upper_limit_kw, :kw)\n  end\n\n  def upper_limit=(new_limit)\n    self.upper_limit_kw = new_limit.to(:kw)\n  end\n\nend\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":244,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/advanced-apps/aa-control/app/models/load_threshold.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"b12b7c25f5c66d2b2c265c7fb25c528effff2255","deserializer":"TextBuffer"},{"text":"require(gbm)\nrequire(stats)\n\nload.train = function(data.train) {\n  # if/when we change the model, then we change the call here\n  # this call should return an object which can be serialized and \"responds to\" predict\n  load.gbm.dual(data=data.train)\n}\n\n\nload.gbm.dual = function(formula=load~temperature+dew_point+hour+yday+wday, data, ...) {\n  # for small data sets, may need to tweak n.minobsinnode\n  bag.fraction = 0.5\n  args = list(distribution      = \"gaussian\",\n              n.trees           = 1000,\n              bag.fraction      = bag.fraction,\n              n.minobsinnode    = min(10, as.integer(nrow(data)*bag.fraction/2) - 1),\n              interaction.depth = 4,\n              shrinkage         = 0.25)\n  args = c(args, ...)\n\n  # add 'control' to the forumla if 'data' has that column\n  if (\"control\" %in% names(data)) {\n    formula = update(terms(formula, data=data), ~.+control)\n  }\n\n  # train short-term model\n  formula.short = update(terms(formula, data=data), ~.+load.prev)\n  fit.short = do.call(gbm, c(list(formula.short, data=data), args))\n  fit.short$data = NULL\n  fit.short$m = NULL\n  fit.short$call = NULL\n  fit.short$fit = NULL\n\n  # train long-term model\n  formula.long = update(terms(formula, data=data), ~.-load.prev)\n  fit.long = do.call(gbm, c(list(formula.long, data=data), args))\n  fit.long$data = NULL\n  fit.long$m = NULL\n  fit.long$call = NULL\n  fit.long$fit = NULL\n\n  fit = list(short = list(fit=fit.short, args=args),\n             long  = list(fit=fit.long,  args=args))\n  class(fit) = \"load.gbm.dual\"\n  return(fit)\n}\n\npredict.load.gbm.dual = function(fit, data, impute.columns=c('temperature', 'dew_point')) {\n  if (length(impute.columns) > 0) {\n    data = impute.data(data, impute.columns)\n  }\n  # use short-term model with feed-forward for the first 12 hours\n  predict.short = vector()\n\n  data.1 = data[1,]\n  load.prev = data.1$load.prev\n  yday = data.1$yday\n  hour = data.1$hour\n\n  short = (data$yday == yday & data$hour <= hour+12) |\n    (hour+12 >= 24 & data$yday == (yday + 1) & data$hour <= (hour+12)%%24)\n  short = short & !is.na(short)\n  data.short = data[short,]\n  data.long = data[!short,]\n\n  for (index in seq_len(nrow(data.short))) {\n    row = data.short[index,]\n    row['load.prev'] = load.prev  # feed-forward from previous prediction\n    load = do.call(predict, c(list(fit[['short']]$fit, row), fit[['short']]$args))\n    predict.short = c(predict.short, load)\n    load.prev = load\n  }\n\n  # user long-term model for the rest of the data\n  predict.long = do.call(predict, c(list(fit[['long']]$fit, data.long), fit[['long']]$args))\n\n  # output the combined prediction\n  c(predict.short, predict.long)\n}\n\n# fill in missing/NA values by interpolating between the non-missing values\nimpute.data = function(data, fields) {\n  data.copy = data\n\n  # interpolate using cubic spline\n  for (field in fields) {\n    # require at least 3 values before spline fitting\n    if (sum(!is.na(data.copy[field])) > 2) {\n      interpolated = spline(data.copy[field], xout=1:nrow(data.copy), method=\"natural\")$y\n      data.copy[field] = interpolated\n    }\n  }\n\n  data.copy\n}\n","markers":{"markers":{"1":{"id":1,"range":[[29,0],[33,0]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":262,"goalBufferRange":null,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"encoding":"utf8","filePath":"/Users/tra/src/advanced-apps/aa-prediction/R/load.R","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"806c78ad8a4656f375ec461c8b0eda830997f54b","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":262,"softTabs":true,"displayBuffer":{"id":263,"softWrapped":false,"editorWidthInChars":null,"scrollTop":13,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/advanced-apps/aa-prediction/R/load.R","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":244,"softTabs":true,"displayBuffer":{"id":245,"softWrapped":false,"editorWidthInChars":null,"scrollTop":565,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/advanced-apps/aa-control/app/models/load_threshold.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":180,"softTabs":true,"displayBuffer":{"id":181,"softWrapped":false,"editorWidthInChars":null,"scrollTop":66,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/advanced-apps/aa-prediction/app/models/predictors/gbm_model.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":228,"softTabs":true,"displayBuffer":{"id":229,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/advanced-apps/aa-prediction/app/models/predictors/r_predictor_base.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":200,"softTabs":true,"displayBuffer":{"id":201,"softWrapped":false,"editorWidthInChars":null,"scrollTop":145,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/advanced-apps/aa-prediction/app/models/feature_collection.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"},{"id":196,"softTabs":true,"displayBuffer":{"id":197,"softWrapped":false,"editorWidthInChars":null,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/src/advanced-apps/aa-prediction/app/models/available_load_factory.rb","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemUri":"/Users/tra/src/advanced-apps/aa-prediction/R/load.R","focused":true,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-ruby","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":"","modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false},"projectViewState":"","resultsModelState":{"useRegex":false,"caseSensitive":true},"findHistory":["configs","valid_password","Noaaish","noaaish","relative_url_root","sample size is insuf","password","PasswordCompl","model_factory","NodeTotalLoad","requested_fea","features","predict(","requested_features","FeatureRequests","predict","predict(","GbmModel","r_formatted_csv","interval","sleep","SetThreshold","FinalizeControlLine","load.R","R_CODE_LOC"],"replaceHistory":[],"pathsHistory":[]},"fuzzy-finder":{"/Users/tra/src/advanced-apps/aa-prediction/R/load.R":1425417450921,"/Users/tra/src/advanced-apps/aa-control/app/models/load_threshold.rb":1424971692929,"/Users/tra/src/advanced-apps/aa-prediction/app/models/predictors/gbm_model.rb":1424975470925,"/Users/tra/src/advanced-apps/aa-prediction/app/models/predictors/r_predictor_base.rb":1422395084381,"/Users/tra/src/advanced-apps/aa-prediction/app/models/feature_collection.rb":1422390640826,"/Users/tra/src/advanced-apps/aa-prediction/app/models/available_load_factory.rb":1422390263890},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":615397650},"tree-view":{"directoryExpansionStates":{"ai-weather":{"lib":{"ai":{"weather":{"ish":{}}}},"libexec":{}}},"selectedPath":"/Users/tra/src/advanced-apps/aa-prediction","hasFocus":false,"attached":true,"scrollLeft":3,"scrollTop":0,"width":280}}}