{"mode":"editor","version":1,"windowDimensions":{"x":463,"y":57,"width":1893,"height":1370},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"path":"/Users/tra/github/hal-interpretation","buffers":[{"text":"module HalInterpretation\n  class ItemInterpreter\n    # opts - named args\n    #   :location - \n    #   :interpreter - \n    def initialize(a_representation, opts)\n      @repr = a_representation\n      @location = opts.fetch(:location) { fail ArgumentError, \"location is required\" }\n      @problems = []\n      @interpreter = opts.fetch(:interpreter) { fail ArgumentError, \"interpreter is required\" }\n    end\n\n    def items\n      interpret unless done?\n\n      (raise InvalidRepresentationError.new problems) if problems.any?\n\n      @items\n    end\n\n    def problems\n      interpret unless done?\n\n      @problems\n    end\n\n    protected\n\n    extend Forwardable\n\n    def_delegators :interpreter, :extractors, :extractor_for, :item_class\n\n    attr_reader :repr, :location, :interpreter\n\n    def done?\n      !@items.nil? || @problems.any?\n    end\n\n    def interpret\n      new_item = item_class.new do |it|\n        e = extractors\n        e.each do |an_extractor|\n          @problems += an_extractor.extract(from: repr, to: it)\n            .map {|msg| \"#{json_path_for an_extractor.attr} #{msg}\" }\n        end\n      end\n\n      apply_validations(new_item)\n\n      return if @problems.any?\n\n      @items = [new_item]\n    end\n\n    def apply_validations(an_item)\n      an_item.valid?\n      an_item.errors.each do |attr, msg|\n        @problems << \"#{json_path_for attr} #{msg}\"\n      end\n    end\n\n    def json_path_for(attr)\n      json_pointer_join(location, extractor_for(attr).location)\n    end\n\n    def json_pointer_join(head, tail)\n      head = head[0..-2] if head.end_with?(\"/\")\n      tail = tail[1..-1] if tail.start_with?(\"/\")\n\n      head + \"/\" + tail\n    end\n  end\n\nend","markers":{"markers":{"1":{"id":1,"range":[[39,17],[39,27]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":35,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/hal-interpretation/lib/hal_interpretation/item_interpreter.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"44d8e448d58687dcd343ecd651e0d3aa8a06f9b1","deserializer":"TextBuffer"},{"text":"module HalInterpretation\n  Error = Class.new(StandardError)\n\n  class InvalidRepresentationError < Error\n    # Initializes a new instance of this error\n    #\n    # problems - list of problems detected with the representation.\n    def initialize(problems)\n      @problems = problems = Array(problems)\n\n      msg = problems.first\n      msg += \" and #{problems.count - 1} more problems\" if problems.count > 1\n\n      super msg\n    end\n\n    attr_reader :problems\n  end\nend\n","markers":{"markers":{"1":{"id":1,"range":[[11,41],[11,54]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":47,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/hal-interpretation/lib/hal_interpretation/errors.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"7c2479453cf8669076f213958e62dcc9063a4578","deserializer":"TextBuffer"},{"text":"require \"forwardable\"\nrequire \"multi_json\"\nrequire \"hal-client\"\n\n# Declarative interpretation of HAL documents into ActiveModel style\n# objects.\nmodule HalInterpretation\n\n  # Returns array of models created from the HAL representation we are\n  # interpreting.\n  #\n  # Raises InvalidRepresentationError if any of the models are invalid\n  #   or the representation is not a HAL document.\n  def items\n    (fail InvalidRepresentationError.new(problems)) if problems.any?\n\n    @observations ||= interpreters.flat_map(&:items)\n  end\n\n  # Returns array of problems messages, or empty array if there are\n  # none. This will do a complete interpretation of the representation\n  # if it has not already been done.\n  def problems\n    @problems ||= interpreters.flat_map(&:problems)\n  end\n\n  extend Forwardable\n  def_delegators \"self.class\", :extractors, :extractor_for\n\n  protected\n\n  # opts\n  #   :location - The json path of `a_representation` in the\n  #     complete document\n  def initialize(a_representation, opts)\n    @repr = a_representation\n    @location = opts.fetch(:location) { raise ArgumentError, \"location is required\" }\n  end\n\n  attr_reader :repr, :location\n\n  def interpreters\n    @interpreters ||=\n      begin\n        if repr.has_related? 'item'\n          repr\n            .related('item')\n            .each_with_index\n            .map{ |item_repr, idx|\n          ItemInterpreter.new(item_repr,\n                              location: location + \"_embedded/item/#{idx}/\",\n                              interpreter: self) }\n        else\n          [ItemInterpreter.new(repr, location: location, interpreter: self)]\n        end\n      end\n  end\n\n  # Back stop method to be overridden by individual interpreters.\n  def item_class\n    fail NotImplementedError, \"interpreter classes must call `item_class <model class>` in the class defintion\"\n  end\n\n  module ClassMethods\n    # Returns new interpreter for the provided JSON document.\n    #\n    # Raises HalInterpretation::InvalidRepresentationError if the\n    #   provided JSON document is not parseable\n    def new_from_json(json)\n      self.new HalClient::Representation.new(parsed_json: MultiJson.load(json)),\n               location: \"/\"\n\n    rescue MultiJson::ParseError => err\n      fail InvalidRepresentationError, \"Parse error: \" + err.message\n    end\n\n    # internal stuff\n\n    # Returns collection of attribute extractors.\n    def extractors\n      @extractors ||= []\n    end\n\n    # Returns the attribute extractor for the specified attribute.\n    def extractor_for(attr_name)\n      extractors.find {|it| it.attr == attr_name }\n    end\n  end\n\n\n  def self.included(klass)\n    klass.extend ClassMethods\n    klass.extend Dsl\n  end\n\n\n  autoload :Dsl, \"hal_interpretation/dsl\"\n  autoload :ItemInterpreter, \"hal_interpretation/item_interpreter\"\n  autoload :Extractor, \"hal_interpretation/extractor\"\n  autoload :Error, \"hal_interpretation/errors\"\n  autoload :InvalidRepresentationError, \"hal_interpretation/errors\"\n\nend\n\nrequire \"hal_interpretation/version\"\n","markers":{"markers":{"1":{"id":1,"range":[[92,17],[92,20]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":51,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/hal-interpretation/lib/hal_interpretation.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"d799c293032928673f8628e0abe4f49480f42d90","deserializer":"TextBuffer"},{"text":"[![Build Status](https://travis-ci.org/pezra/hal-interpretation.png?branch=master)](https://travis-ci.org/pezra/hal-interpretation)\n[![Code Climate](https://codeclimate.com/github/pezra/hal-interpretation.png)](https://codeclimate.com/github/pezra/hal-interpretation)\n\n# HalInterpretation\n\nBuild ActiveModels from HAL documents with good error messages\nfor validity issues.\n\n## Usage\n\n`HalInterpretation` provides a DSL for declaring how to build one or\nmore `ActiveModel` objects from a HAL document.\n\n```ruby\nclass UserHalInterpreter\n  include HalInterpretation\n\n  item_class User\n\n  extract :name\n  extract :address_line, from: \"address/line1\"\nend\n```\n\nTo interpret a HAL document simply create a new interpreter from the\nJSON document to interpret and then call its `#items` method.\n\n```ruby\nclass Users < ApplicationController\n  def create\n    @users = UserHalInterpreter.new_from_json(request.raw_post).items\n\n  rescue HalInterpretation::InvalidRepresentationError => err\n    render template: \"shared/error\", status: 422, locals: { problems: err.problems }\n  end\nend\n```\n\nThe `items` method returns an `Enumerable` of valid `item_class` objects.\n\n### Errors\n\n If the JSON being interpreted is invalid or malformed\n`HalInterpretation` provides a list of the problems encountered\nthrough the `#problems` method. Each problem message includes a\n[JSON pointer][] to the exact location in the original document that\ncaused the problem. This is true even when interpreting\n[collections][] for example if name of the third user in a collection\nis null the problem message would be\n\n    /_embedded/item/2/name cannot be blank\n\nValidity is determined using the `#valid?` method of the models being\nbuilt.\n\n\n## Installation\n\nAdd this line to your application's Gemfile:\n\n    gem 'hal-interpretation'\n\nAnd then execute:\n\n    $ bundle\n\nOr install it yourself as:\n\n    $ gem install hal-interpretation\n\n## Contributing\n\n1. Fork it ( http://github.com/pezra/hal-interpretation/fork )\n2. Create your feature branch (`git checkout -b my-new-feature`)\n3. Make your improvement\n4. Update the version following [semver][] rules\n5. Commit your changes (`git commit -am 'Add some feature'`)\n6. Push to the branch (`git push origin my-new-feature`)\n7. Create new Pull Request\n\n\n[semver]: http://semver.org/\n[json pointer]: http://tools.ietf.org/html/rfc6901\n[collections]: https://tools.ietf.org/html/rfc6573","markers":{"markers":{"1":{"id":1,"range":[[27,7],[27,7]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":55,"autoscroll":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/hal-interpretation/README.md","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"40042f73527c6bd999a0acd21b934e7128f2709d","deserializer":"TextBuffer"},{"text":"module HalInterpretation\n  module Dsl\n    # Declare the class of models this interpreter builds.\n    def item_class(klass)\n      define_method(:item_class) do\n        klass\n      end\n    end\n\n    # Declare that an attribute should be extract from the HAL\n    # document.\n    #\n    # attr_name - name of attribute on model to extract\n    #\n    # opts - hash of named arguments to method\n    #\n    #   :from - JSON path from which to get the value for\n    #     attribute. Default: \"/#{attr_name}\".\n    #\n    #   :with - Callable that can extract the value when\n    #     passed a HalClient::Representation of the item.\n    #\n    #   :coercion - callable with which the raw value should be\n    #     transformed before being stored.\n    def extract(attr_name, opts={})\n      extractor_opts = {\n        attr: attr_name,\n        location: opts.fetch(:from) { \"/#{attr_name}\" }\n      }\n      extractor_opts[:extraction_proc] = opts.fetch(:with) if opts.key? :with\n      extractor_opts[:coercion] = opts[:coercion] if opts.key? :coercion\n\n      extractors << Extractor.new(extractor_opts)\n    end\n  end\nend","markers":{"markers":{"1":{"id":1,"range":[[3,8],[3,18]],"tailed":true,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":60,"autoscroll":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/tra/github/hal-interpretation/lib/hal_interpretation/dsl.rb","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"beab54f5c8bcc4a660bc7f5ee7fbc65400d787c9","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":35,"softTabs":true,"displayBuffer":{"id":36,"softWrap":false,"editorWidthInChars":167,"scrollTop":76,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/hal-interpretation/lib/hal_interpretation/item_interpreter.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":60,"softTabs":true,"displayBuffer":{"id":61,"softWrap":false,"editorWidthInChars":82,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/hal-interpretation/lib/hal_interpretation/dsl.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":55,"softTabs":true,"displayBuffer":{"id":56,"softWrap":false,"editorWidthInChars":167,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/hal-interpretation/README.md","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":51,"softTabs":true,"displayBuffer":{"id":52,"softWrap":false,"editorWidthInChars":167,"scrollTop":940,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/hal-interpretation/lib/hal_interpretation.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":47,"softTabs":true,"displayBuffer":{"id":48,"softWrap":false,"editorWidthInChars":167,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/tra/github/hal-interpretation/lib/hal_interpretation/errors.rb","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/tra/github/hal-interpretation/lib/hal_interpretation/item_interpreter.rb","focused":true,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-ruby","language-gfm"],"deserializer":"Workspace"},"packageStates":{"find-and-replace":{"viewState":{"findHistory":["No route","recog","item_class"],"replaceHistory":[],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}},"projectViewState":{"findHistory":["No Permissions","No route","more problems","InvalidRepresentationError","recognize","item_class","Dsl","item_class"],"replaceHistory":[],"pathsHistory":[],"modelState":{"useRegex":false,"caseSensitive":false}},"resultsModelState":{"useRegex":false,"caseSensitive":false}},"fuzzy-finder":{"/Users/tra/github/hal-interpretation/lib/hal_interpretation/item_interpreter.rb":1406836300645,"/Users/tra/github/hal-interpretation/lib/hal_interpretation/dsl.rb":1406836264134,"/Users/tra/github/hal-interpretation/README.md":1406827855019,"/Users/tra/github/hal-interpretation/lib/hal_interpretation.rb":1406828145854,"/Users/tra/github/hal-interpretation/lib/hal_interpretation/errors.rb":1406751830796},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":515935720},"tree-view":{"directoryExpansionStates":{"lib":{"hal_interpretation":{}}},"selectedPath":"/Users/tra/github/hal-interpretation/lib/hal_interpretation/item_interpreter.rb","hasFocus":false,"attached":true,"scrollLeft":1,"scrollTop":0,"width":200}}}